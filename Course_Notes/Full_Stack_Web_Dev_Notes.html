<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full-Stack Web Development - Complete Notes</title>
    <link rel="stylesheet" href="notes-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Back to Website Button -->
    <div class="back-button-container">
        <a href="#" id="back-to-website" class="back-button">
            <i class="fas fa-arrow-left"></i> Back to Website
        </a>
    </div>
    
    <div class="container">
        <header>
            <h1>Full-Stack Web Development - Complete Notes</h1>
            <p class="subtitle">22 Videos - Comprehensive Study Guide with Examples and Explanations</p>
        </header>
        
        <div class="toc no-print">
            <h2>Table of Contents</h2>
            <ul id="toc-list">
                <!-- TOC will be generated by JavaScript -->
            </ul>
        </div>
        
        <!-- Video 01: Web Foundations -->
        <div class="video-section" id="video-01">
            <div class="video-header">
                <span class="video-number">Video 01</span>
                <h2 class="video-title">Web Foundations: HTML, CSS, Tailwind & JS Basics</h2>
            </div>
            
            <!-- Topic 1: HTML Elements, Structure, Semantics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>HTML Elements, Structure, Semantics</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>HTML Document Structure</h3>
                        <p>HTML (HyperText Markup Language) is the foundation of web pages. Every HTML document follows a basic structure:</p>
                        
                        <div class="code-block">
<code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Content goes here --&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
                        </div>
                        
                        <h3>Semantic HTML Elements</h3>
                        <p>Semantic HTML provides meaning to the content, making it more accessible and SEO-friendly:</p>
                        
                        <table>
                            <tr>
                                <th>Element</th>
                                <th>Purpose</th>
                                <th>Example</th>
                            </tr>
                            <tr>
                                <td>&lt;header&gt;</td>
                                <td>Header section</td>
                                <td>Site logo, navigation</td>
                            </tr>
                            <tr>
                                <td>&lt;nav&gt;</td>
                                <td>Navigation links</td>
                                <td>Menu items</td>
                            </tr>
                            <tr>
                                <td>&lt;main&gt;</td>
                                <td>Main content</td>
                                <td>Primary page content</td>
                            </tr>
                            <tr>
                                <td>&lt;article&gt;</td>
                                <td>Independent content</td>
                                <td>Blog post, news article</td>
                            </tr>
                            <tr>
                                <td>&lt;section&gt;</td>
                                <td>Thematic grouping</td>
                                <td>Chapter, topic section</td>
                            </tr>
                            <tr>
                                <td>&lt;aside&gt;</td>
                                <td>Sidebar content</td>
                                <td>Related links, ads</td>
                            </tr>
                            <tr>
                                <td>&lt;footer&gt;</td>
                                <td>Footer section</td>
                                <td>Copyright, contact info</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Semantic HTML Structure</h4>
                            <div class="code-block">
<code>&lt;header&gt;
    &lt;nav&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href="#home"&gt;Home&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#about"&gt;About&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/nav&gt;
&lt;/header&gt;

&lt;main&gt;
    &lt;article&gt;
        &lt;h1&gt;Article Title&lt;/h1&gt;
        &lt;p&gt;Article content...&lt;/p&gt;
    &lt;/article&gt;
    
    &lt;aside&gt;
        &lt;h2&gt;Related Links&lt;/h2&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href="#"&gt;Link 1&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/aside&gt;
&lt;/main&gt;

&lt;footer&gt;
    &lt;p&gt;&copy; 2026 Company Name&lt;/p&gt;
&lt;/footer&gt;</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always use semantic HTML elements instead of generic &lt;div&gt; tags when possible. This improves accessibility for screen readers and helps search engines understand your content structure.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: CSS Basics, Layout, Flexbox, Grid -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>CSS Basics, Layout, Flexbox, Grid</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>CSS Fundamentals</h3>
                        <p>CSS (Cascading Style Sheets) controls the visual appearance of HTML elements. There are three ways to add CSS:</p>
                        <ol>
                            <li><strong>Inline CSS:</strong> Styles applied directly to HTML elements</li>
                            <li><strong>Internal CSS:</strong> Styles in &lt;style&gt; tag within HTML</li>
                            <li><strong>External CSS:</strong> Separate .css file linked via &lt;link&gt; tag</li>
                        </ol>
                        
                        <div class="code-block">
<code>/* External CSS file: styles.css */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f4f4f4;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}</code>
                        </div>
                        
                        <h3>CSS Box Model</h3>
                        <p>Every HTML element is a rectangular box with four areas:</p>
                        <ul>
                            <li><strong>Content:</strong> The actual content (text, images)</li>
                            <li><strong>Padding:</strong> Space between content and border</li>
                            <li><strong>Border:</strong> Border around padding</li>
                            <li><strong>Margin:</strong> Space outside the border</li>
                        </ul>
                        
                        <div class="code-block">
<code>.box {
    width: 300px;
    height: 200px;
    padding: 20px;        /* Inner space */
    border: 2px solid #333;  /* Border */
    margin: 10px;         /* Outer space */
    box-sizing: border-box;   /* Includes padding/border in width */
}</code>
                        </div>
                        
                        <h3>Flexbox Layout</h3>
                        <p>Flexbox is a one-dimensional layout method for arranging items in rows or columns:</p>
                        
                        <div class="code-block">
<code>.flex-container {
    display: flex;
    flex-direction: row;      /* or column */
    justify-content: center;   /* Main axis alignment */
    align-items: center;      /* Cross axis alignment */
    gap: 20px;                /* Space between items */
    flex-wrap: wrap;          /* Allow wrapping */
}

.flex-item {
    flex: 1;                 /* Grow to fill space */
    flex-basis: 200px;       /* Initial size */
    flex-shrink: 1;          /* Can shrink if needed */
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Centered Card Layout with Flexbox</h4>
                            <div class="code-block">
<code>.card-container {
    display: flex;
    justify-content: space-around;
    align-items: stretch;
    gap: 20px;
    padding: 20px;
}

.card {
    flex: 1;
    max-width: 300px;
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}</code>
                            </div>
                        </div>
                        
                        <h3>CSS Grid Layout</h3>
                        <p>Grid is a two-dimensional layout system for rows and columns:</p>
                        
                        <div class="code-block">
<code>.grid-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);  /* 3 equal columns */
    grid-template-rows: auto;
    gap: 20px;
    grid-template-areas:
        "header header header"
        "sidebar main main"
        "footer footer footer";
}

.header { grid-area: header; }
.sidebar { grid-area: sidebar; }
.main { grid-area: main; }
.footer { grid-area: footer; }</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Responsive Grid</h4>
                            <div class="code-block">
<code>.responsive-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
}

/* On mobile: 1 column, on tablet: 2 columns, on desktop: 3+ columns */
@media (max-width: 768px) {
    .responsive-grid {
        grid-template-columns: 1fr;
    }
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use Flexbox for one-dimensional layouts (navigation bars, card rows). Use Grid for two-dimensional layouts (page layouts, complex designs).</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Tailwind Setup + Utility Classes -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Tailwind Setup + Utility Classes</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Installing Tailwind CSS</h3>
                        <p>Tailwind CSS is a utility-first CSS framework. Installation via npm:</p>
                        
                        <div class="code-block">
<code># Install Tailwind CSS
npm install -D tailwindcss

# Initialize Tailwind config
npx tailwindcss init

# Create tailwind.config.js
module.exports = {
  content: ["./src/**/*.{html,js}"],
  theme: {
    extend: {},
  },
  plugins: [],
}</code>
                        </div>
                        
                        <h3>Setting up Tailwind in CSS</h3>
                        <div class="code-block">
<code>/* input.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Custom utilities */
@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}</code>
                        </div>
                        
                        <h3>Common Utility Classes</h3>
                        <table>
                            <tr>
                                <th>Category</th>
                                <th>Classes</th>
                                <th>Purpose</th>
                            </tr>
                            <tr>
                                <td>Spacing</td>
                                <td>p-4, m-2, gap-6</td>
                                <td>Padding, margin, gaps</td>
                            </tr>
                            <tr>
                                <td>Typography</td>
                                <td>text-xl, font-bold, text-center</td>
                                <td>Text size, weight, alignment</td>
                            </tr>
                            <tr>
                                <td>Colors</td>
                                <td>bg-blue-500, text-white</td>
                                <td>Background and text colors</td>
                            </tr>
                            <tr>
                                <td>Layout</td>
                                <td>flex, grid, hidden</td>
                                <td>Display properties</td>
                            </tr>
                            <tr>
                                <td>Responsive</td>
                                <td>md:flex, lg:text-2xl</td>
                                <td>Breakpoint-specific styles</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Tailwind Card Component</h4>
                            <div class="code-block">
<code>&lt;div class="max-w-sm mx-auto bg-white rounded-xl shadow-lg 
     overflow-hidden m-4"&gt;
    &lt;div class="p-6"&gt;
        &lt;h2 class="text-2xl font-bold text-gray-800 mb-2"&gt;
            Card Title
        &lt;/h2&gt;
        &lt;p class="text-gray-600"&gt;
            Card description text goes here.
        &lt;/p&gt;
        &lt;button class="mt-4 bg-blue-500 hover:bg-blue-700 
             text-white font-bold py-2 px-4 rounded"&gt;
            Click Me
        &lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Tailwind uses a purge process to remove unused CSS. Make sure your content paths in tailwind.config.js are correct, or you'll lose styles in production.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Responsive Design Fundamentals -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Responsive Design Fundamentals</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Viewport Meta Tag</h3>
                        <p>Essential for responsive design - tells browsers how to control page dimensions:</p>
                        
                        <div class="code-block">
<code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</code>
                        </div>
                        
                        <h3>Media Queries</h3>
                        <p>Apply styles based on screen size:</p>
                        
                        <div class="code-block">
<code>/* Mobile First Approach */
.container {
    width: 100%;
    padding: 10px;
}

/* Tablet */
@media (min-width: 768px) {
    .container {
        max-width: 750px;
        padding: 20px;
    }
}

/* Desktop */
@media (min-width: 1024px) {
    .container {
        max-width: 1200px;
        padding: 30px;
    }
}</code>
                        </div>
                        
                        <h3>Common Breakpoints</h3>
                        <table>
                            <tr>
                                <th>Device</th>
                                <th>Width</th>
                                <th>Media Query</th>
                            </tr>
                            <tr>
                                <td>Mobile</td>
                                <td>&lt; 768px</td>
                                <td>@media (max-width: 767px)</td>
                            </tr>
                            <tr>
                                <td>Tablet</td>
                                <td>768px - 1023px</td>
                                <td>@media (min-width: 768px)</td>
                            </tr>
                            <tr>
                                <td>Desktop</td>
                                <td>&gt; 1024px</td>
                                <td>@media (min-width: 1024px)</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Responsive Navigation</h4>
                            <div class="code-block">
<code>/* Mobile: Stacked menu */
.nav {
    flex-direction: column;
}

/* Desktop: Horizontal menu */
@media (min-width: 768px) {
    .nav {
        flex-direction: row;
        justify-content: space-between;
    }
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: JavaScript Basics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>JavaScript Basics: Variables, Loops, Events</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Variables in JavaScript</h3>
                        <p>Three ways to declare variables:</p>
                        
                        <div class="code-block">
<code>// var (function-scoped, avoid in modern JS)
var oldVariable = "Avoid this";

// let (block-scoped, can be reassigned)
let name = "John";
name = "Jane";  // OK

// const (block-scoped, cannot be reassigned)
const PI = 3.14159;
// PI = 3.14;  // Error!</code>
                        </div>
                        
                        <h3>Data Types</h3>
                        <ul>
                            <li><strong>Primitive:</strong> string, number, boolean, null, undefined, symbol, bigint</li>
                            <li><strong>Object:</strong> arrays, functions, objects, dates</li>
                        </ul>
                        
                        <div class="code-block">
<code>// String
let message = "Hello World";

// Number
let age = 25;
let price = 19.99;

// Boolean
let isActive = true;

// Array
let fruits = ["apple", "banana", "orange"];

// Object
let person = {
    name: "John",
    age: 30,
    city: "New York"
};</code>
                        </div>
                        
                        <h3>Loops</h3>
                        <p>Different types of loops for iteration:</p>
                        
                        <div class="code-block">
<code>// For loop
for (let i = 0; i < 5; i++) {
    console.log(i);
}

// For...of loop (arrays)
const colors = ["red", "green", "blue"];
for (const color of colors) {
    console.log(color);
}

// For...in loop (objects)
const person = { name: "John", age: 30 };
for (const key in person) {
    console.log(key, person[key]);
}

// While loop
let count = 0;
while (count < 5) {
    console.log(count);
    count++;
}

// Array methods
colors.forEach(color => console.log(color));
const doubled = [1, 2, 3].map(num => num * 2);</code>
                        </div>
                        
                        <h3>Event Handling</h3>
                        <p>JavaScript can respond to user interactions:</p>
                        
                        <div class="code-block">
<code>// Method 1: Inline event handler (not recommended)
&lt;button onclick="handleClick()"&gt;Click Me&lt;/button&gt;

// Method 2: addEventListener (recommended)
const button = document.querySelector('button');
button.addEventListener('click', function() {
    console.log('Button clicked!');
});

// Method 3: Arrow function
button.addEventListener('click', () => {
    console.log('Button clicked!');
});

// Common events
element.addEventListener('click', handler);
element.addEventListener('mouseenter', handler);
element.addEventListener('keydown', handler);
element.addEventListener('submit', handler);</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Interactive Counter</h4>
                            <div class="code-block">
<code>&lt;button id="increment"&gt;+&lt;/button&gt;
&lt;span id="count"&gt;0&lt;/span&gt;
&lt;button id="decrement"&gt;-&lt;/button&gt;

&lt;script&gt;
let count = 0;
const countDisplay = document.getElementById('count');
const incrementBtn = document.getElementById('increment');
const decrementBtn = document.getElementById('decrement');

incrementBtn.addEventListener('click', () => {
    count++;
    countDisplay.textContent = count;
});

decrementBtn.addEventListener('click', () => {
    count--;
    countDisplay.textContent = count;
});
&lt;/script&gt;</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: DOM Manipulation Basics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>DOM Manipulation Basics</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>What is the DOM?</h3>
                        <p>The Document Object Model (DOM) is a programming interface for HTML documents. It represents the page structure as a tree of objects.</p>
                        
                        <h3>Selecting Elements</h3>
                        <div class="code-block">
<code>// By ID
const element = document.getElementById('myId');

// By class (returns first)
const element = document.querySelector('.myClass');

// By class (returns all)
const elements = document.querySelectorAll('.myClass');

// By tag
const paragraphs = document.querySelectorAll('p');

// By attribute
const link = document.querySelector('[href="#"]');</code>
                        </div>
                        
                        <h3>Modifying Content</h3>
                        <div class="code-block">
<code>// Change text content
element.textContent = "New text";
element.innerText = "New text";
element.innerHTML = "&lt;strong&gt;Bold text&lt;/strong&gt;";

// Change attributes
element.setAttribute('class', 'new-class');
element.id = 'new-id';
element.href = 'https://example.com';

// Change styles
element.style.color = 'red';
element.style.backgroundColor = 'blue';
element.classList.add('active');
element.classList.remove('inactive');
element.classList.toggle('visible');</code>
                        </div>
                        
                        <h3>Creating and Removing Elements</h3>
                        <div class="code-block">
<code>// Create element
const newDiv = document.createElement('div');
newDiv.textContent = 'New element';
newDiv.className = 'my-class';

// Append to parent
const parent = document.querySelector('.container');
parent.appendChild(newDiv);

// Insert before
parent.insertBefore(newDiv, parent.firstChild);

// Remove element
element.remove();
// or
parent.removeChild(element);</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Dynamic List</h4>
                            <div class="code-block">
<code>&lt;ul id="todo-list"&gt;&lt;/ul&gt;
&lt;input type="text" id="todo-input"&gt;
&lt;button id="add-btn"&gt;Add&lt;/button&gt;

&lt;script&gt;
const todoList = document.getElementById('todo-list');
const input = document.getElementById('todo-input');
const addBtn = document.getElementById('add-btn');

addBtn.addEventListener('click', () => {
    const text = input.value.trim();
    if (text) {
        const li = document.createElement('li');
        li.textContent = text;
        li.addEventListener('click', () => li.remove());
        todoList.appendChild(li);
        input.value = '';
    }
});
&lt;/script&gt;</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always wait for DOM to load before manipulating it. Use <code>DOMContentLoaded</code> event or place scripts at the end of body tag.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 02: Modern JavaScript (ES6 ‚Üí ES2025) -->
        <div class="video-section" id="video-02">
            <div class="video-header">
                <span class="video-number">Video 02</span>
                <h2 class="video-title">Modern JavaScript (ES6 ‚Üí ES2025) Complete Guide</h2>
            </div>
            
            <!-- Topic 1: let/const, arrow functions, template literals -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>let/const, arrow functions, template literals</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>let and const</h3>
                        <p>ES6 introduced <code>let</code> and <code>const</code> as block-scoped alternatives to <code>var</code>, providing better variable management and preventing common bugs.</p>
                        
                        <h4>Key Differences from var</h4>
                        <table>
                            <tr>
                                <th>Feature</th>
                                <th>var</th>
                                <th>let</th>
                                <th>const</th>
                            </tr>
                            <tr>
                                <td>Scope</td>
                                <td>Function-scoped</td>
                                <td>Block-scoped</td>
                                <td>Block-scoped</td>
                            </tr>
                            <tr>
                                <td>Hoisting</td>
                                <td>Hoisted, initialized as undefined</td>
                                <td>Hoisted, not initialized (TDZ)</td>
                                <td>Hoisted, not initialized (TDZ)</td>
                            </tr>
                            <tr>
                                <td>Reassignment</td>
                                <td>Yes</td>
                                <td>Yes</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>Redeclaration</td>
                                <td>Allowed</td>
                                <td>Not allowed in same scope</td>
                                <td>Not allowed in same scope</td>
                            </tr>
                        </table>
                        
                        <div class="code-block">
<code>// var - function scoped
function example() {
    if (true) {
        var x = 1;
    }
    console.log(x);  // 1 (accessible)
}

// let - block scoped
function example() {
    if (true) {
        let y = 1;
    }
    console.log(y);  // ReferenceError: y is not defined
}

// const - block scoped, cannot reassign
const PI = 3.14159;
// PI = 3.14;  // TypeError: Assignment to constant variable

// const with objects/arrays (can modify contents)
const person = { name: "John" };
person.name = "Jane";  // OK
person.age = 30;       // OK
// person = {};         // Error: cannot reassign</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Loop Variable Scoping</h4>
                            <div class="code-block">
<code>// Problem with var
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3 (all closures share same i)

// Solution with let
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2 (each iteration has its own i)

// const in for...of loops
const items = ['a', 'b', 'c'];
for (const item of items) {
    console.log(item);  // a, b, c
}</code>
                            </div>
                        </div>
                        
                        <h4>Arrow Functions</h4>
                        <p>Arrow functions provide concise syntax and lexical <code>this</code> binding, making code more readable and predictable.</p>
                        
                        <div class="code-block">
<code>// Traditional function
function add(a, b) {
    return a + b;
}

// Arrow function - single expression
const add = (a, b) => a + b;

// Arrow function - with body
const multiply = (a, b) => {
    const result = a * b;
    return result;
};

// Single parameter (parentheses optional)
const square = x => x * x;

// No parameters
const greet = () => "Hello!";

// Returning object literal
const createUser = (name, age) => ({ name, age });

// Arrow functions preserve 'this'
const obj = {
    name: "John",
    traditional: function() {
        console.log(this.name);  // 'this' refers to obj
    },
    arrow: () => {
        console.log(this.name);  // 'this' refers to global/window
    }
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Array Methods with Arrow Functions</h4>
                            <div class="code-block">
<code>const numbers = [1, 2, 3, 4, 5];

// map - transform each element
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8, 10]

// filter - select elements
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4]

// reduce - accumulate values
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 15

// find - find first match
const found = numbers.find(n => n > 3);
// 4

// forEach - iterate
numbers.forEach(n => console.log(n));</code>
                            </div>
                        </div>
                        
                        <h4>Template Literals</h4>
                        <p>Template literals (backticks) allow embedded expressions, multi-line strings, and tagged templates.</p>
                        
                        <div class="code-block">
<code>const name = "John";
const age = 30;

// Old way - concatenation
const message = "Hello, " + name + "! You are " + age + " years old.";

// Template literal
const message = `Hello, ${name}! You are ${age} years old.`;

// Multi-line strings
const html = `
    <div class="card">
        <h1>${name}</h1>
        <p>Age: ${age}</p>
    </div>
`;

// Expressions
const calculation = `2 + 2 = ${2 + 2}`;  // "2 + 2 = 4"
const isAdult = `Is adult: ${age >= 18}`;  // "Is adult: true"

// Nested template literals
const greeting = `Hello, ${name}, ${age >= 18 ? 'adult' : 'minor'}!`;

// Tagged templates (advanced)
function highlight(strings, ...values) {
    return strings.reduce((result, str, i) => {
        return result + str + (values[i] ? `<mark>${values[i]}</mark>` : '');
    }, '');
}

const highlighted = highlight`Hello ${name}, you are ${age} years old.`;</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use <code>const</code> by default, and only use <code>let</code> when you need to reassign the variable. This makes your code more predictable and helps prevent bugs. Use arrow functions for callbacks and when you want to preserve lexical <code>this</code>.</p>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Arrow functions don't have their own <code>this</code>, <code>arguments</code>, <code>super</code>, or <code>new.target</code>. Don't use arrow functions for object methods where you need <code>this</code> to refer to the object, or when you need function hoisting.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Modules, imports/exports -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Modules, imports/exports</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>ES6 Modules</h3>
                        <p>ES6 modules provide a standardized way to organize and share code between files, replacing older module systems like CommonJS and AMD.</p>
                        
                        <h4>Exporting from Modules</h4>
                        <div class="code-block">
<code>// Named exports (multiple per file)
export const PI = 3.14159;
export function add(a, b) {
    return a + b;
}
export class Calculator {
    multiply(a, b) {
        return a * b;
    }
}

// Or export at the end
const PI = 3.14159;
function add(a, b) {
    return a + b;
}
export { PI, add };

// Renaming exports
export { add as sum };

// Default export (one per file)
export default function subtract(a, b) {
    return a - b;
}

// Or
function subtract(a, b) {
    return a - b;
}
export default subtract;</code>
                        </div>
                        
                        <h4>Importing Modules</h4>
                        <div class="code-block">
<code>// Named imports
import { PI, add } from './math.js';
import { add as sum } from './math.js';
import { PI, add, Calculator } from './math.js';

// Default import
import subtract from './math.js';

// Mixed imports
import subtract, { PI, add } from './math.js';

// Import everything as namespace
import * as math from './math.js';
math.PI;  // 3.14159
math.add(1, 2);  // 3

// Dynamic import (async)
const module = await import('./math.js');
const { add } = module;</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Module Structure</h4>
                            <p><strong>utils.js</strong></p>
                            <div class="code-block">
<code>// Utility functions
export function formatDate(date) {
    return new Intl.DateTimeFormat('en-US').format(date);
}

export function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

export const API_URL = 'https://api.example.com';

export default {
    formatDate,
    capitalize,
    API_URL
};</code>
                            </div>
                            <p><strong>main.js</strong></p>
                            <div class="code-block">
<code>// Using the utilities
import utils, { formatDate, capitalize, API_URL } from './utils.js';

const today = formatDate(new Date());
const name = capitalize('john');
console.log(API_URL);</code>
                            </div>
                        </div>
                        
                        <h4>HTML Integration</h4>
                        <div class="code-block">
<code>&lt;!-- In HTML file --&gt;
&lt;script type="module" src="main.js"&gt;&lt;/script&gt;

&lt;!-- Or inline --&gt;
&lt;script type="module"&gt;
    import { add } from './math.js';
    console.log(add(2, 3));
&lt;/script&gt;</code>
                        </div>
                        
                        <div class="note-info">
                            <h4>‚ÑπÔ∏è Info</h4>
                            <p>Modules are automatically in strict mode. They have their own scope, so variables declared in a module aren't global. Modules are deferred by default and execute only once, even if imported multiple times.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Promises, async/await -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Promises, async/await</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Promises</h3>
                        <p>Promises represent the eventual completion (or failure) of an asynchronous operation, providing a cleaner alternative to callbacks.</p>
                        
                        <h4>Promise States</h4>
                        <ul>
                            <li><strong>Pending:</strong> Initial state, neither fulfilled nor rejected</li>
                            <li><strong>Fulfilled:</strong> Operation completed successfully</li>
                            <li><strong>Rejected:</strong> Operation failed</li>
                        </ul>
                        
                        <div class="code-block">
<code>// Creating a Promise
const promise = new Promise((resolve, reject) => {
    // Async operation
    setTimeout(() => {
        const success = true;
        if (success) {
            resolve('Operation successful!');
        } else {
            reject(new Error('Operation failed!'));
        }
    }, 1000);
});

// Consuming a Promise
promise
    .then(result => {
        console.log(result);  // "Operation successful!"
    })
    .catch(error => {
        console.error(error);  // Handle error
    })
    .finally(() => {
        console.log('Always executes');
    });</code>
                        </div>
                        
                        <h4>Promise Methods</h4>
                        <div class="code-block">
<code>// Promise.all - wait for all promises
const promises = [
    fetch('/api/user'),
    fetch('/api/posts'),
    fetch('/api/comments')
];

Promise.all(promises)
    .then(results => {
        // All promises resolved
        const [user, posts, comments] = results;
    })
    .catch(error => {
        // If any promise rejects
        console.error(error);
    });

// Promise.allSettled - wait for all (even if some fail)
Promise.allSettled(promises)
    .then(results => {
        results.forEach((result, index) => {
            if (result.status === 'fulfilled') {
                console.log(`Promise ${index} succeeded`);
            } else {
                console.log(`Promise ${index} failed`);
            }
        });
    });

// Promise.race - first to resolve/reject
Promise.race(promises)
    .then(result => {
        // First promise to resolve
    });

// Promise.any - first to resolve (ignores rejections)
Promise.any(promises)
    .then(result => {
        // First successful promise
    });</code>
                        </div>
                        
                        <h4>async/await</h4>
                        <p><code>async/await</code> provides syntactic sugar over Promises, making asynchronous code look and behave like synchronous code.</p>
                        
                        <div class="code-block">
<code>// async function always returns a Promise
async function fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const user = await response.json();
    return user;
}

// Using async/await
async function displayUser(id) {
    try {
        const user = await fetchUser(id);
        console.log(user.name);
    } catch (error) {
        console.error('Failed to fetch user:', error);
    }
}

// Multiple awaits
async function fetchUserData(id) {
    const user = await fetchUser(id);
    const posts = await fetchUserPosts(id);
    const comments = await fetchUserComments(id);
    
    return { user, posts, comments };
}

// Parallel execution with Promise.all
async function fetchUserDataParallel(id) {
    const [user, posts, comments] = await Promise.all([
        fetchUser(id),
        fetchUserPosts(id),
        fetchUserComments(id)
    ]);
    
    return { user, posts, comments };
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Error Handling Patterns</h4>
                            <div class="code-block">
<code>// Pattern 1: try/catch
async function example1() {
    try {
        const data = await fetchData();
        return data;
    } catch (error) {
        console.error(error);
        throw error;  // Re-throw if needed
    }
}

// Pattern 2: .catch() on promise
async function example2() {
    const data = await fetchData().catch(error => {
        console.error(error);
        return null;  // Return default value
    });
    return data;
}

// Pattern 3: Wrapper function
function asyncHandler(fn) {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next))
            .catch(next);
    };
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use <code>async/await</code> for sequential operations, but use <code>Promise.all()</code> when operations can run in parallel to improve performance. Always handle errors with try/catch or .catch().</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Fetch API, error handling -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Fetch API, error handling</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Fetch API</h3>
                        <p>The Fetch API provides a modern, promise-based way to make HTTP requests, replacing the older XMLHttpRequest.</p>
                        
                        <h4>Basic Fetch Request</h4>
                        <div class="code-block">
<code>// GET request
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// With async/await
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}</code>
                        </div>
                        
                        <h4>Request Options</h4>
                        <div class="code-block">
<code>// POST request
fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
    },
    body: JSON.stringify({
        name: 'John',
        email: 'john@example.com'
    })
})
    .then(response => response.json())
    .then(data => console.log(data));

// PUT request
fetch('https://api.example.com/users/1', {
    method: 'PUT',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        name: 'Jane',
        email: 'jane@example.com'
    })
});

// DELETE request
fetch('https://api.example.com/users/1', {
    method: 'DELETE'
});</code>
                        </div>
                        
                        <h4>Response Handling</h4>
                        <div class="code-block">
<code>async function fetchData(url) {
    const response = await fetch(url);
    
    // Check if request was successful
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Check content type
    const contentType = response.headers.get('content-type');
    
    if (contentType.includes('application/json')) {
        return await response.json();
    } else if (contentType.includes('text/html')) {
        return await response.text();
    } else {
        return await response.blob();
    }
}</code>
                        </div>
                        
                        <h4>Error Handling</h4>
                        <div class="code-block">
<code>// Important: fetch only rejects on network errors
// HTTP errors (404, 500, etc.) are still "successful" responses

async function fetchWithErrorHandling(url) {
    try {
        const response = await fetch(url);
        
        // Check response status
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        // Network error or HTTP error
        if (error instanceof TypeError) {
            console.error('Network error:', error.message);
        } else {
            console.error('HTTP error:', error.message);
        }
        throw error;
    }
}

// Better error handling wrapper
async function safeFetch(url, options = {}) {
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            const error = new Error(`HTTP ${response.status}`);
            error.status = response.status;
            error.response = response;
            throw error;
        }
        
        return await response.json();
    } catch (error) {
        if (error.name === 'TypeError') {
            throw new Error('Network error: Unable to reach server');
        }
        throw error;
    }
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete API Client</h4>
                            <div class="code-block">
<code>class ApiClient {
    constructor(baseURL, token = null) {
        this.baseURL = baseURL;
        this.token = token;
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseURL}${endpoint}`;
        const config = {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...(this.token && { 'Authorization': `Bearer ${this.token}` }),
                ...options.headers
            }
        };
        
        try {
            const response = await fetch(url, config);
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `HTTP ${response.status}`);
            }
            
            return await response.json();
        } catch (error) {
            console.error('API request failed:', error);
            throw error;
        }
    }
    
    get(endpoint) {
        return this.request(endpoint);
    }
    
    post(endpoint, data) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data)
        });
    }
    
    put(endpoint, data) {
        return this.request(endpoint, {
            method: 'PUT',
            body: JSON.stringify(data)
        });
    }
    
    delete(endpoint) {
        return this.request(endpoint, {
            method: 'DELETE'
        });
    }
}

// Usage
const api = new ApiClient('https://api.example.com', 'token123');
const users = await api.get('/users');
const newUser = await api.post('/users', { name: 'John' });</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Fetch API doesn't reject on HTTP error status codes (404, 500, etc.). Always check <code>response.ok</code> or <code>response.status</code> to handle HTTP errors properly.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Spread, rest, destructuring -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Spread, rest, destructuring</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Spread Operator (...)</h3>
                        <p>The spread operator expands iterables (arrays, strings, objects) into individual elements.</p>
                        
                        <h4>Array Spread</h4>
                        <div class="code-block">
<code>// Copying arrays
const arr1 = [1, 2, 3];
const arr2 = [...arr1];  // [1, 2, 3] (new array)

// Combining arrays
const arr3 = [...arr1, 4, 5];  // [1, 2, 3, 4, 5]
const combined = [...arr1, ...arr2];  // [1, 2, 3, 1, 2, 3]

// Passing array elements as arguments
const numbers = [1, 2, 3];
Math.max(...numbers);  // 3 (instead of Math.max(1, 2, 3))

// Adding elements
const newArr = [...arr1, 4];  // [1, 2, 3, 4]
const withNew = [0, ...arr1, 4];  // [0, 1, 2, 3, 4]</code>
                        </div>
                        
                        <h4>Object Spread</h4>
                        <div class="code-block">
<code>// Copying objects
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1 };  // { a: 1, b: 2 } (new object)

// Merging objects
const obj3 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj3 };  // { a: 1, b: 2, c: 3, d: 4 }

// Overriding properties
const updated = { ...obj1, b: 5 };  // { a: 1, b: 5 }

// Adding new properties
const extended = { ...obj1, c: 3 };  // { a: 1, b: 2, c: 3 }

// Shallow copy (nested objects are still referenced)
const nested = { a: { b: 1 } };
const copied = { ...nested };
copied.a.b = 2;  // nested.a.b is also 2!</code>
                        </div>
                        
                        <h4>Rest Parameters</h4>
                        <p>Rest parameters collect remaining arguments into an array.</p>
                        
                        <div class="code-block">
<code>// Rest in function parameters
function sum(first, second, ...rest) {
    let total = first + second;
    for (const num of rest) {
        total += num;
    }
    return total;
}

sum(1, 2, 3, 4, 5);  // 15 (rest = [3, 4, 5])

// Rest in destructuring
const [first, second, ...rest] = [1, 2, 3, 4, 5];
// first = 1, second = 2, rest = [3, 4, 5]

const { a, b, ...rest } = { a: 1, b: 2, c: 3, d: 4 };
// a = 1, b = 2, rest = { c: 3, d: 4 }</code>
                        </div>
                        
                        <h4>Destructuring</h4>
                        <p>Destructuring extracts values from arrays or properties from objects into distinct variables.</p>
                        
                        <div class="code-block">
<code>// Array destructuring
const arr = [1, 2, 3];
const [a, b, c] = arr;  // a = 1, b = 2, c = 3

// Skip elements
const [first, , third] = arr;  // first = 1, third = 3

// Default values
const [x, y, z = 0] = [1, 2];  // x = 1, y = 2, z = 0

// Swap variables
let a = 1, b = 2;
[a, b] = [b, a];  // a = 2, b = 1

// Object destructuring
const person = { name: 'John', age: 30, city: 'NYC' };
const { name, age } = person;  // name = 'John', age = 30

// Renaming
const { name: personName, age: personAge } = person;

// Default values
const { name, age, country = 'USA' } = person;

// Nested destructuring
const user = {
    name: 'John',
    address: {
        street: '123 Main St',
        city: 'NYC'
    }
};
const { address: { city } } = user;  // city = 'NYC'</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Practical Use Cases</h4>
                            <div class="code-block">
<code>// Function parameters
function createUser({ name, email, age = 18 }) {
    return { name, email, age };
}

createUser({ name: 'John', email: 'john@example.com' });

// React props
function UserCard({ name, email, ...otherProps }) {
    return (
        &lt;div {...otherProps}&gt;
            &lt;h2&gt;{name}&lt;/h2&gt;
            &lt;p&gt;{email}&lt;/p&gt;
        &lt;/div&gt;
    );
}

// API response handling
async function fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    const { data: user, error } = await response.json();
    
    if (error) throw new Error(error);
    return user;
}

// State updates (React)
setState(prevState => ({
    ...prevState,
    count: prevState.count + 1
}));</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use spread operator for immutable updates (creating new objects/arrays instead of mutating). Use destructuring to make function parameters more readable and to extract only what you need from objects/arrays.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Modern browser APIs -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Modern browser APIs</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Modern Browser APIs</h3>
                        <p>Modern browsers provide powerful APIs for enhanced user experiences, including storage, geolocation, notifications, and more.</p>
                        
                        <h4>LocalStorage & SessionStorage</h4>
                        <div class="code-block">
<code>// localStorage - persists until cleared
localStorage.setItem('username', 'John');
const username = localStorage.getItem('username');
localStorage.removeItem('username');
localStorage.clear();  // Clear all

// Storing objects
const user = { name: 'John', age: 30 };
localStorage.setItem('user', JSON.stringify(user));
const stored = JSON.parse(localStorage.getItem('user'));

// sessionStorage - cleared when tab closes
sessionStorage.setItem('token', 'abc123');
const token = sessionStorage.getItem('token');

// Storage event (fires when storage changes in other tabs)
window.addEventListener('storage', (e) => {
    console.log('Storage changed:', e.key, e.newValue);
});</code>
                        </div>
                        
                        <h4>Geolocation API</h4>
                        <div class="code-block">
<code>// Get current position
navigator.geolocation.getCurrentPosition(
    (position) => {
        const { latitude, longitude } = position.coords;
        console.log(`Lat: ${latitude}, Lng: ${longitude}`);
    },
    (error) => {
        console.error('Error:', error.message);
    },
    {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
    }
);

// Watch position (updates as user moves)
const watchId = navigator.geolocation.watchPosition(
    (position) => {
        console.log('Position updated:', position.coords);
    }
);

// Stop watching
navigator.geolocation.clearWatch(watchId);</code>
                        </div>
                        
                        <h4>Notifications API</h4>
                        <div class="code-block">
<code>// Request permission
if ('Notification' in window) {
    Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
            // Show notification
            new Notification('Hello!', {
                body: 'This is a notification',
                icon: '/icon.png',
                badge: '/badge.png',
                tag: 'notification-1',
                requireInteraction: true
            });
        }
    });
}

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    event.waitUntil(
        clients.openWindow('/')
    );
});</code>
                        </div>
                        
                        <h4>Intersection Observer API</h4>
                        <div class="code-block">
<code>// Observe when element enters viewport
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            // Load image, start animation, etc.
        }
    });
}, {
    root: null,  // viewport
    rootMargin: '0px',
    threshold: 0.1  // Trigger when 10% visible
});

const element = document.querySelector('.lazy-load');
observer.observe(element);

// Unobserve
observer.unobserve(element);</code>
                        </div>
                        
                        <h4>Clipboard API</h4>
                        <div class="code-block">
<code>// Copy text to clipboard
async function copyToClipboard(text) {
    try {
        await navigator.clipboard.writeText(text);
        console.log('Copied to clipboard');
    } catch (error) {
        console.error('Failed to copy:', error);
    }
}

// Read from clipboard
async function readFromClipboard() {
    try {
        const text = await navigator.clipboard.readText();
        console.log('Clipboard:', text);
    } catch (error) {
        console.error('Failed to read:', error);
    }
}

// Copy image
async function copyImage(imageBlob) {
    const item = new ClipboardItem({ 'image/png': imageBlob });
    await navigator.clipboard.write([item]);
}</code>
                        </div>
                        
                        <h4>Web Workers</h4>
                        <div class="code-block">
<code>// main.js
const worker = new Worker('worker.js');

// Send message to worker
worker.postMessage({ type: 'calculate', data: [1, 2, 3, 4, 5] });

// Receive message from worker
worker.onmessage = (e) => {
    console.log('Result:', e.data);
};

// Handle errors
worker.onerror = (error) => {
    console.error('Worker error:', error);
};

// Terminate worker
worker.terminate();

// worker.js
self.onmessage = (e) => {
    const { type, data } = e.data;
    
    if (type === 'calculate') {
        const result = data.reduce((sum, num) => sum + num, 0);
        self.postMessage(result);
    }
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Lazy Loading Images</h4>
                            <div class="code-block">
<code>// HTML: &lt;img data-src="image.jpg" class="lazy"&gt;

const lazyImages = document.querySelectorAll('img.lazy');
const imageObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            imageObserver.unobserve(img);
        }
    });
});

lazyImages.forEach(img => imageObserver.observe(img));</code>
                            </div>
                        </div>
                        
                        <div class="note-info">
                            <h4>‚ÑπÔ∏è Info</h4>
                            <p>Many modern browser APIs require user permission or HTTPS. Always check for API availability using feature detection before using them. Some APIs are only available in specific contexts (service workers, secure contexts, etc.).</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 03: Advanced JavaScript + Real Projects -->
        <div class="video-section" id="video-03">
            <div class="video-header">
                <span class="video-number">Video 03</span>
                <h2 class="video-title">Advanced JavaScript + Real Projects</h2>
            </div>
            
            <!-- Topic 1: Closures, scopes, lexical environment -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Closures, scopes, lexical environment</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Understanding Scope</h3>
                        <p>Scope determines the accessibility of variables, functions, and objects in different parts of your code.</p>
                        
                        <h4>Types of Scope</h4>
                        <table>
                            <tr>
                                <th>Scope Type</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                            <tr>
                                <td>Global Scope</td>
                                <td>Accessible everywhere</td>
                                <td>Variables declared outside functions</td>
                            </tr>
                            <tr>
                                <td>Function Scope</td>
                                <td>Accessible within function</td>
                                <td>Variables declared with var</td>
                            </tr>
                            <tr>
                                <td>Block Scope</td>
                                <td>Accessible within block {}</td>
                                <td>Variables declared with let/const</td>
                            </tr>
                            <tr>
                                <td>Module Scope</td>
                                <td>Accessible within module</td>
                                <td>Variables in ES6 modules</td>
                            </tr>
                        </table>
                        
                        <div class="code-block">
<code>// Global scope
const globalVar = 'I am global';

function outerFunction() {
    // Function scope
    const functionVar = 'I am in function scope';
    
    if (true) {
        // Block scope
        const blockVar = 'I am in block scope';
        console.log(globalVar);      // ‚úÖ Accessible
        console.log(functionVar);    // ‚úÖ Accessible
        console.log(blockVar);       // ‚úÖ Accessible
    }
    
    // console.log(blockVar);        // ‚ùå Error: not accessible
}

// Scope chain - inner scopes can access outer scopes
const outer = 'outer';
function inner() {
    const middle = 'middle';
    function innermost() {
        const inner = 'inner';
        console.log(outer);   // ‚úÖ Can access outer
        console.log(middle);  // ‚úÖ Can access middle
        console.log(inner);   // ‚úÖ Can access inner
    }
    innermost();
}</code>
                        </div>
                        
                        <h4>Lexical Environment</h4>
                        <p>A lexical environment is a data structure that holds identifier-variable mappings and a reference to the outer (enclosing) lexical environment.</p>
                        
                        <div class="code-block">
<code>// Lexical environment example
function createCounter() {
    let count = 0;  // Stored in lexical environment
    
    return function() {
        count++;    // Accesses count from outer lexical environment
        return count;
    };
}

const counter1 = createCounter();
const counter2 = createCounter();

console.log(counter1());  // 1
console.log(counter1());  // 2
console.log(counter2());  // 1 (separate lexical environment)
console.log(counter1());  // 3</code>
                        </div>
                        
                        <h4>Closures</h4>
                        <p>A closure is a function that has access to variables in its outer (enclosing) lexical scope, even after the outer function has returned.</p>
                        
                        <div class="code-block">
<code>// Basic closure
function outerFunction(x) {
    // Outer function's variable
    const outerVar = x;
    
    // Inner function (closure)
    function innerFunction(y) {
        // Can access outerVar even after outerFunction returns
        return outerVar + y;
    }
    
    return innerFunction;
}

const closure = outerFunction(10);
console.log(closure(5));  // 15

// Closure with private variables
function createBankAccount(initialBalance) {
    let balance = initialBalance;  // Private variable
    
    return {
        deposit: function(amount) {
            balance += amount;
            return balance;
        },
        withdraw: function(amount) {
            if (amount <= balance) {
                balance -= amount;
                return balance;
            }
            return 'Insufficient funds';
        },
        getBalance: function() {
            return balance;
        }
    };
}

const account = createBankAccount(100);
account.deposit(50);      // 150
account.withdraw(30);     // 120
console.log(account.getBalance());  // 120
// account.balance is not accessible directly</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Module Pattern with Closures</h4>
                            <div class="code-block">
<code>const Calculator = (function() {
    // Private variables and functions
    let history = [];
    
    function addToHistory(operation, result) {
        history.push({ operation, result, timestamp: Date.now() });
    }
    
    // Public API
    return {
        add: function(a, b) {
            const result = a + b;
            addToHistory(`add(${a}, ${b})`, result);
            return result;
        },
        subtract: function(a, b) {
            const result = a - b;
            addToHistory(`subtract(${a}, ${b})`, result);
            return result;
        },
        getHistory: function() {
            return [...history];  // Return copy
        },
        clearHistory: function() {
            history = [];
        }
    };
})();

Calculator.add(5, 3);        // 8
Calculator.subtract(10, 4);  // 6
console.log(Calculator.getHistory());
// history is private, can't access directly</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Closures are powerful for creating private variables, data hiding, and function factories. However, be careful with closures in loops - they can lead to unexpected behavior if not handled correctly.</p>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Closures keep references to outer variables, which can lead to memory leaks if not managed properly. Variables in closures are not garbage collected until the closure itself is no longer referenced.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Execution context, call stack -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Execution context, call stack</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Execution Context</h3>
                        <p>An execution context is an abstract concept that holds information about the environment in which JavaScript code is executed.</p>
                        
                        <h4>Types of Execution Context</h4>
                        <ul>
                            <li><strong>Global Execution Context:</strong> Created when JavaScript engine starts, one per program</li>
                            <li><strong>Function Execution Context:</strong> Created each time a function is called</li>
                            <li><strong>Eval Execution Context:</strong> Created when code is executed inside eval()</li>
                        </ul>
                        
                        <h4>Execution Context Components</h4>
                        <div class="code-block">
<code>// Each execution context has:
// 1. Variable Environment
//    - var declarations
//    - function declarations
//    - arguments object
// 2. Lexical Environment
//    - let/const declarations
//    - this binding
//    - outer environment reference
// 3. this binding

function example(a, b) {
    var x = 10;           // Variable environment
    let y = 20;           // Lexical environment
    const z = 30;         // Lexical environment
    
    function inner() {    // Variable environment
        console.log(x, y, z);
    }
    
    return inner;
}</code>
                        </div>
                        
                        <h4>Creation Phase vs Execution Phase</h4>
                        <div class="code-block">
<code>// Creation Phase (before code execution)
// 1. Create scope chain
// 2. Create variable object (var, function declarations)
// 3. Determine 'this' value

// Example:
console.log(x);           // undefined (not error!)
var x = 5;
console.log(x);           // 5

// What happens:
// Creation phase: var x = undefined (hoisted)
// Execution phase: x = 5

// Function declarations are fully hoisted
sayHello();               // "Hello!" (works!)

function sayHello() {
    console.log('Hello!');
}

// Function expressions are NOT hoisted
// sayHi();               // Error: sayHi is not a function
var sayHi = function() {
    console.log('Hi!');
};</code>
                        </div>
                        
                        <h4>Call Stack</h4>
                        <p>The call stack is a data structure that tracks function calls. It follows LIFO (Last In, First Out) principle.</p>
                        
                        <div class="code-block">
<code>function first() {
    console.log('First function');
    second();
    console.log('First function ends');
}

function second() {
    console.log('Second function');
    third();
    console.log('Second function ends');
}

function third() {
    console.log('Third function');
}

first();

// Call stack:
// [third]        <- top
// [second]
// [first]
// [global]
//
// Output:
// First function
// Second function
// Third function
// Second function ends
// First function ends</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Recursive Function Call Stack</h4>
                            <div class="code-block">
<code>function factorial(n) {
    console.log(`Computing factorial(${n})`);
    
    if (n <= 1) {
        console.log(`Base case: factorial(${n}) = 1`);
        return 1;
    }
    
    const result = n * factorial(n - 1);
    console.log(`factorial(${n}) = ${result}`);
    return result;
}

factorial(4);

// Call stack visualization:
// factorial(1) <- returns 1
// factorial(2) <- returns 2 * 1 = 2
// factorial(3) <- returns 3 * 2 = 6
// factorial(4) <- returns 4 * 6 = 24</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Stack overflow occurs when the call stack exceeds its maximum size, typically from infinite recursion or deeply nested function calls. Always ensure recursive functions have a base case that terminates.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Event loop, microtasks/macrotasks -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Event loop, microtasks/macrotasks</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>JavaScript Event Loop</h3>
                        <p>JavaScript is single-threaded but uses an event loop to handle asynchronous operations efficiently.</p>
                        
                        <h4>Event Loop Components</h4>
                        <ul>
                            <li><strong>Call Stack:</strong> Where function calls are executed</li>
                            <li><strong>Web APIs:</strong> Browser-provided APIs (setTimeout, DOM, fetch, etc.)</li>
                            <li><strong>Callback Queue (Macrotask Queue):</strong> Holds callbacks from Web APIs</li>
                            <li><strong>Microtask Queue:</strong> Holds microtasks (Promises, queueMicrotask)</li>
                            <li><strong>Event Loop:</strong> Continuously checks and processes queues</li>
                        </ul>
                        
                        <h4>Execution Order</h4>
                        <div class="code-block">
<code>console.log('1. Synchronous');

setTimeout(() => {
    console.log('2. Macrotask (setTimeout)');
}, 0);

Promise.resolve().then(() => {
    console.log('3. Microtask (Promise)');
});

queueMicrotask(() => {
    console.log('4. Microtask (queueMicrotask)');
});

console.log('5. Synchronous');

// Output:
// 1. Synchronous
// 5. Synchronous
// 3. Microtask (Promise)
// 4. Microtask (queueMicrotask)
// 2. Macrotask (setTimeout)

// Order: Synchronous ‚Üí Microtasks ‚Üí Macrotasks</code>
                        </div>
                        
                        <h4>Microtasks vs Macrotasks</h4>
                        <table>
                            <tr>
                                <th>Type</th>
                                <th>Examples</th>
                                <th>Priority</th>
                            </tr>
                            <tr>
                                <td>Microtasks</td>
                                <td>Promise.then/catch/finally, queueMicrotask, MutationObserver</td>
                                <td>Higher (executed before macrotasks)</td>
                            </tr>
                            <tr>
                                <td>Macrotasks</td>
                                <td>setTimeout, setInterval, setImmediate, I/O operations</td>
                                <td>Lower (executed after microtasks)</td>
                            </tr>
                        </table>
                        
                        <div class="code-block">
<code>// Microtasks are executed before macrotasks
console.log('Start');

setTimeout(() => console.log('Macrotask 1'), 0);
setTimeout(() => console.log('Macrotask 2'), 0);

Promise.resolve().then(() => {
    console.log('Microtask 1');
    return Promise.resolve();
}).then(() => {
    console.log('Microtask 2');
});

queueMicrotask(() => {
    console.log('Microtask 3');
});

console.log('End');

// Output:
// Start
// End
// Microtask 1
// Microtask 2
// Microtask 3
// Macrotask 1
// Macrotask 2</code>
                        </div>
                        
                        <h4>Event Loop Visualization</h4>
                        <div class="code-block">
<code>// Step-by-step execution
console.log('1');

setTimeout(() => {
    console.log('2');
    Promise.resolve().then(() => console.log('3'));
}, 0);

Promise.resolve().then(() => {
    console.log('4');
    setTimeout(() => console.log('5'), 0);
});

console.log('6');

// Execution:
// 1. Call stack: console.log('1') ‚Üí prints "1"
// 2. Call stack: setTimeout ‚Üí moves to Web API
// 3. Call stack: Promise.resolve().then ‚Üí moves to Microtask Queue
// 4. Call stack: console.log('6') ‚Üí prints "6"
// 5. Call stack empty ‚Üí process Microtask Queue
//    - Promise callback ‚Üí prints "4", setTimeout moves to Web API
// 6. Process Macrotask Queue
//    - setTimeout callback ‚Üí prints "2", Promise moves to Microtask Queue
// 7. Process Microtask Queue again
//    - Promise callback ‚Üí prints "3"
// 8. Process Macrotask Queue
//    - setTimeout callback ‚Üí prints "5"

// Final output: 1, 6, 4, 2, 3, 5</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Understanding Async Behavior</h4>
                            <div class="code-block">
<code>// Common mistake: expecting synchronous behavior
let data = null;

fetch('/api/data')
    .then(response => response.json())
    .then(result => {
        data = result;
    });

console.log(data);  // null (fetch hasn't completed yet!)

// Correct approach
fetch('/api/data')
    .then(response => response.json())
    .then(result => {
        data = result;
        console.log(data);  // Data available here
        processData(data);
    });

// Or with async/await
async function loadData() {
    const response = await fetch('/api/data');
    const data = await response.json();
    console.log(data);  // Data available here
    return data;
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Microtasks are processed after each macrotask completes. This means all microtasks in the queue will execute before the next macrotask runs. Use this knowledge to understand Promise behavior and optimize async code.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Prototypes, OOP in JS -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Prototypes, OOP in JS</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Prototypes in JavaScript</h3>
                        <p>JavaScript uses prototypal inheritance. Every object has a prototype, which is another object that it inherits properties and methods from.</p>
                        
                        <h4>Prototype Chain</h4>
                        <div class="code-block">
<code>// Every object has a prototype
const obj = {};
console.log(obj.__proto__);  // Object.prototype

// Prototype chain
const arr = [];
// arr ‚Üí Array.prototype ‚Üí Object.prototype ‚Üí null

// Accessing prototype
const person = { name: 'John' };
console.log(person.toString());  // "[object Object]"
// person doesn't have toString, but Object.prototype does

// Checking prototype
console.log(Object.getPrototypeOf(person) === Object.prototype);  // true
console.log(person instanceof Object);  // true</code>
                        </div>
                        
                        <h4>Creating Objects with Prototypes</h4>
                        <div class="code-block">
<code>// Method 1: Object.create()
const animal = {
    makeSound: function() {
        return 'Some sound';
    }
};

const dog = Object.create(animal);
dog.name = 'Buddy';
dog.makeSound();  // "Some sound" (inherited)

// Method 2: Constructor functions
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return `Hello, I'm ${this.name}`;
};

const john = new Person('John', 30);
john.greet();  // "Hello, I'm John"

// Method 3: ES6 Classes (syntactic sugar)
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

const jane = new Person('Jane', 25);
jane.greet();  // "Hello, I'm Jane"</code>
                        </div>
                        
                        <h4>Inheritance</h4>
                        <div class="code-block">
<code>// ES6 Class Inheritance
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    makeSound() {
        return 'Some sound';
    }
    
    eat() {
        return `${this.name} is eating`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);  // Call parent constructor
        this.breed = breed;
    }
    
    makeSound() {
        return 'Woof!';
    }
    
    fetch() {
        return `${this.name} is fetching`;
    }
}

const dog = new Dog('Buddy', 'Golden Retriever');
dog.eat();       // "Buddy is eating" (inherited)
dog.makeSound(); // "Woof!" (overridden)
dog.fetch();     // "Buddy is fetching" (own method)

// Prototype-based inheritance (old way)
function Animal(name) {
    this.name = name;
}

Animal.prototype.makeSound = function() {
    return 'Some sound';
};

function Dog(name, breed) {
    Animal.call(this, name);  // Call parent constructor
    this.breed = breed;
}

Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.makeSound = function() {
    return 'Woof!';
};</code>
                        </div>
                        
                        <h4>Prototype Methods</h4>
                        <div class="code-block">
<code>// Adding methods to prototype
Array.prototype.last = function() {
    return this[this.length - 1];
};

const arr = [1, 2, 3, 4, 5];
arr.last();  // 5

// Checking if property is own or inherited
const obj = { a: 1 };
obj.hasOwnProperty('a');        // true
obj.hasOwnProperty('toString'); // false (inherited)

// Getting all properties
Object.keys(obj);                    // ['a'] (own enumerable)
Object.getOwnPropertyNames(obj);     // ['a'] (own all)
Object.getOwnPropertySymbols(obj);   // [] (own symbols)

// for...in includes inherited properties
for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
        console.log(key);  // Only own properties
    }
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Custom Array Methods</h4>
                            <div class="code-block">
<code>// Extending Array prototype (use with caution!)
Array.prototype.groupBy = function(keyFn) {
    return this.reduce((groups, item) => {
        const key = keyFn(item);
        if (!groups[key]) {
            groups[key] = [];
        }
        groups[key].push(item);
        return groups;
    }, {});
};

const users = [
    { name: 'John', age: 25 },
    { name: 'Jane', age: 30 },
    { name: 'Bob', age: 25 }
];

const grouped = users.groupBy(user => user.age);
// { 25: [{name: 'John', age: 25}, {name: 'Bob', age: 25}], 30: [{name: 'Jane', age: 30}] }</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Modifying built-in prototypes (like Array.prototype or Object.prototype) is generally discouraged as it can cause conflicts with other code and future JavaScript features. Use composition or utility functions instead.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Web Storage, local/session storage -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Web Storage, local/session storage</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Web Storage API</h3>
                        <p>Web Storage provides two mechanisms for storing data in the browser: localStorage and sessionStorage.</p>
                        
                        <h4>localStorage vs sessionStorage</h4>
                        <table>
                            <tr>
                                <th>Feature</th>
                                <th>localStorage</th>
                                <th>sessionStorage</th>
                            </tr>
                            <tr>
                                <td>Persistence</td>
                                <td>Until explicitly cleared</td>
                                <td>Until tab/window closes</td>
                            </tr>
                            <tr>
                                <td>Scope</td>
                                <td>All tabs/windows (same origin)</td>
                                <td>Single tab/window</td>
                            </tr>
                            <tr>
                                <td>Storage Limit</td>
                                <td>~5-10MB</td>
                                <td>~5-10MB</td>
                            </tr>
                            <tr>
                                <td>Use Case</td>
                                <td>Persistent user preferences</td>
                                <td>Temporary session data</td>
                            </tr>
                        </table>
                        
                        <h4>Basic Operations</h4>
                        <div class="code-block">
<code>// localStorage
localStorage.setItem('username', 'John');
localStorage.setItem('theme', 'dark');

// Get item
const username = localStorage.getItem('username');  // "John"
const theme = localStorage.getItem('theme');       // "dark"

// Remove item
localStorage.removeItem('theme');

// Clear all
localStorage.clear();

// Get key by index
localStorage.key(0);  // "username"

// Get number of items
localStorage.length;   // 1

// sessionStorage (same API)
sessionStorage.setItem('sessionId', 'abc123');
const sessionId = sessionStorage.getItem('sessionId');
sessionStorage.removeItem('sessionId');
sessionStorage.clear();</code>
                        </div>
                        
                        <h4>Storing Objects and Arrays</h4>
                        <div class="code-block">
<code>// localStorage only stores strings
const user = {
    name: 'John',
    age: 30,
    preferences: {
        theme: 'dark',
        language: 'en'
    }
};

// Store object (must stringify)
localStorage.setItem('user', JSON.stringify(user));

// Retrieve object (must parse)
const storedUser = JSON.parse(localStorage.getItem('user'));

// Storing arrays
const items = ['item1', 'item2', 'item3'];
localStorage.setItem('items', JSON.stringify(items));
const storedItems = JSON.parse(localStorage.getItem('items'));

// Helper functions
const storage = {
    set: (key, value) => {
        localStorage.setItem(key, JSON.stringify(value));
    },
    get: (key) => {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : null;
    },
    remove: (key) => {
        localStorage.removeItem(key);
    },
    clear: () => {
        localStorage.clear();
    }
};

storage.set('user', user);
const user = storage.get('user');</code>
                        </div>
                        
                        <h4>Storage Events</h4>
                        <div class="code-block">
<code>// Listen for storage changes (fires in other tabs/windows)
window.addEventListener('storage', (e) => {
    console.log('Storage changed:', {
        key: e.key,
        oldValue: e.oldValue,
        newValue: e.newValue,
        url: e.url,
        storageArea: e.storageArea
    });
    
    if (e.key === 'theme') {
        updateTheme(e.newValue);
    }
});

// Note: storage event doesn't fire in the same tab
// Use custom events for same-tab updates
function setItemWithEvent(key, value) {
    localStorage.setItem(key, value);
    window.dispatchEvent(new StorageEvent('storage', {
        key,
        newValue: value,
        oldValue: localStorage.getItem(key)
    }));
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: User Preferences Manager</h4>
                            <div class="code-block">
<code>class PreferencesManager {
    constructor() {
        this.defaults = {
            theme: 'light',
            language: 'en',
            notifications: true
        };
        this.load();
    }
    
    load() {
        const stored = localStorage.getItem('preferences');
        if (stored) {
            this.preferences = { ...this.defaults, ...JSON.parse(stored) };
        } else {
            this.preferences = { ...this.defaults };
        }
    }
    
    get(key) {
        return this.preferences[key];
    }
    
    set(key, value) {
        this.preferences[key] = value;
        this.save();
        this.notify(key, value);
    }
    
    save() {
        localStorage.setItem('preferences', JSON.stringify(this.preferences));
    }
    
    reset() {
        this.preferences = { ...this.defaults };
        this.save();
    }
    
    notify(key, value) {
        window.dispatchEvent(new CustomEvent('preferenceChanged', {
            detail: { key, value }
        }));
    }
}

const prefs = new PreferencesManager();
prefs.set('theme', 'dark');
prefs.get('theme');  // "dark"

window.addEventListener('preferenceChanged', (e) => {
    console.log(`Preference ${e.detail.key} changed to ${e.detail.value}`);
});</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>localStorage is synchronous and can block the main thread. Don't store large amounts of data. Also, localStorage is not secure - never store sensitive information like passwords or tokens without encryption.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Mini-projects (animations, UI widgets) -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Mini-projects (animations, UI widgets)</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Building Interactive UI Components</h3>
                        <p>Practical mini-projects help solidify JavaScript concepts while building real-world components.</p>
                        
                        <h4>Project 1: Animated Counter</h4>
                        <div class="code-block">
<code>class AnimatedCounter {
    constructor(element, target, duration = 2000) {
        this.element = element;
        this.target = target;
        this.duration = duration;
        this.current = 0;
        this.startTime = null;
    }
    
    animate() {
        const start = this.current;
        const change = this.target - start;
        const startTime = performance.now();
        
        const update = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / this.duration, 1);
            
            // Easing function (ease-out)
            const easeOut = 1 - Math.pow(1 - progress, 3);
            
            this.current = Math.floor(start + change * easeOut);
            this.element.textContent = this.current;
            
            if (progress < 1) {
                requestAnimationFrame(update);
            } else {
                this.current = this.target;
                this.element.textContent = this.target;
            }
        };
        
        requestAnimationFrame(update);
    }
}

// Usage
const counterElement = document.querySelector('.counter');
const counter = new AnimatedCounter(counterElement, 1000);
counter.animate();</code>
                        </div>
                        
                        <h4>Project 2: Modal Dialog</h4>
                        <div class="code-block">
<code>class Modal {
    constructor(modalId) {
        this.modal = document.getElementById(modalId);
        this.overlay = this.modal.querySelector('.modal-overlay');
        this.closeBtn = this.modal.querySelector('.modal-close');
        this.init();
    }
    
    init() {
        this.closeBtn.addEventListener('click', () => this.close());
        this.overlay.addEventListener('click', () => this.close());
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.modal.classList.contains('active')) {
                this.close();
            }
        });
    }
    
    open() {
        this.modal.classList.add('active');
        document.body.style.overflow = 'hidden';
    }
    
    close() {
        this.modal.classList.remove('active');
        document.body.style.overflow = '';
    }
}

// Usage
const modal = new Modal('myModal');
document.querySelector('.open-modal').addEventListener('click', () => {
    modal.open();
});</code>
                        </div>
                        
                        <h4>Project 3: Accordion Component</h4>
                        <div class="code-block">
<code>class Accordion {
    constructor(container) {
        this.container = container;
        this.items = container.querySelectorAll('.accordion-item');
        this.init();
    }
    
    init() {
        this.items.forEach(item => {
            const header = item.querySelector('.accordion-header');
            const content = item.querySelector('.accordion-content');
            
            header.addEventListener('click', () => {
                const isActive = item.classList.contains('active');
                
                // Close all items
                this.items.forEach(i => {
                    i.classList.remove('active');
                    i.querySelector('.accordion-content').style.maxHeight = null;
                });
                
                // Open clicked item if it wasn't active
                if (!isActive) {
                    item.classList.add('active');
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            });
        });
    }
}

// Usage
const accordion = new Accordion(document.querySelector('.accordion'));</code>
                        </div>
                        
                        <h4>Project 4: Drag and Drop</h4>
                        <div class="code-block">
<code>class Draggable {
    constructor(element) {
        this.element = element;
        this.isDragging = false;
        this.currentX = 0;
        this.currentY = 0;
        this.initialX = 0;
        this.initialY = 0;
        this.xOffset = 0;
        this.yOffset = 0;
        this.init();
    }
    
    init() {
        this.element.addEventListener('mousedown', (e) => this.dragStart(e));
        document.addEventListener('mousemove', (e) => this.drag(e));
        document.addEventListener('mouseup', () => this.dragEnd());
    }
    
    dragStart(e) {
        this.initialX = e.clientX - this.xOffset;
        this.initialY = e.clientY - this.yOffset;
        
        if (e.target === this.element) {
            this.isDragging = true;
            this.element.style.cursor = 'grabbing';
        }
    }
    
    drag(e) {
        if (this.isDragging) {
            e.preventDefault();
            this.currentX = e.clientX - this.initialX;
            this.currentY = e.clientY - this.initialY;
            
            this.xOffset = this.currentX;
            this.yOffset = this.currentY;
            
            this.element.style.transform = `translate(${this.currentX}px, ${this.currentY}px)`;
        }
    }
    
    dragEnd() {
        this.initialX = this.currentX;
        this.initialY = this.currentY;
        this.isDragging = false;
        this.element.style.cursor = 'grab';
    }
}

// Usage
const draggable = new Draggable(document.querySelector('.draggable'));</code>
                        </div>
                        
                        <h4>Project 5: Toast Notifications</h4>
                        <div class="code-block">
<code>class Toast {
    static show(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        
        document.body.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Remove after duration
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, duration);
    }
    
    static success(message) {
        this.show(message, 'success');
    }
    
    static error(message) {
        this.show(message, 'error');
    }
    
    static info(message) {
        this.show(message, 'info');
    }
}

// Usage
Toast.success('Operation completed!');
Toast.error('Something went wrong!');
Toast.info('New message received');</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Todo App</h4>
                            <div class="code-block">
<code>class TodoApp {
    constructor(containerId) {
        this.container = document.getElementById(containerId);
        this.todos = this.loadTodos();
        this.render();
        this.init();
    }
    
    init() {
        const form = this.container.querySelector('.todo-form');
        const input = this.container.querySelector('.todo-input');
        
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const text = input.value.trim();
            if (text) {
                this.addTodo(text);
                input.value = '';
            }
        });
    }
    
    addTodo(text) {
        const todo = {
            id: Date.now(),
            text,
            completed: false,
            createdAt: new Date()
        };
        
        this.todos.push(todo);
        this.saveTodos();
        this.render();
    }
    
    toggleTodo(id) {
        const todo = this.todos.find(t => t.id === id);
        if (todo) {
            todo.completed = !todo.completed;
            this.saveTodos();
            this.render();
        }
    }
    
    deleteTodo(id) {
        this.todos = this.todos.filter(t => t.id !== id);
        this.saveTodos();
        this.render();
    }
    
    render() {
        const list = this.container.querySelector('.todo-list');
        list.innerHTML = this.todos.map(todo => `
            &lt;li class="todo-item ${todo.completed ? 'completed' : ''}"&gt;
                &lt;input type="checkbox" ${todo.completed ? 'checked' : ''} 
                       onchange="app.toggleTodo(${todo.id})"&gt;
                &lt;span&gt;${todo.text}&lt;/span&gt;
                &lt;button onclick="app.deleteTodo(${todo.id})"&gt;Delete&lt;/button&gt;
            &lt;/li&gt;
        `).join('');
    }
    
    saveTodos() {
        localStorage.setItem('todos', JSON.stringify(this.todos));
    }
    
    loadTodos() {
        const stored = localStorage.getItem('todos');
        return stored ? JSON.parse(stored) : [];
    }
}

// Usage
const app = new TodoApp('todo-container');</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>When building UI components, always consider accessibility (keyboard navigation, ARIA attributes), performance (use requestAnimationFrame for animations), and user experience (smooth transitions, clear feedback).</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 04: TypeScript Masterclass -->
        <div class="video-section" id="video-04">
            <div class="video-header">
                <span class="video-number">Video 04</span>
                <h2 class="video-title">TypeScript Masterclass (Complete)</h2>
            </div>
            
            <!-- Topic 1: Types, interfaces, generics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Types, interfaces, generics</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>TypeScript Basics</h3>
                        <p>TypeScript is a typed superset of JavaScript that compiles to plain JavaScript, adding static type checking.</p>
                        
                        <h4>Basic Types</h4>
                        <div class="code-block">
<code>// Primitive types
let name: string = "John";
let age: number = 30;
let isActive: boolean = true;
let data: null = null;
let value: undefined = undefined;

// Arrays
let numbers: number[] = [1, 2, 3];
let names: Array&lt;string&gt; = ["John", "Jane"];

// Tuples
let tuple: [string, number] = ["John", 30];
let [name, age] = tuple;

// Any (avoid when possible)
let anything: any = "can be anything";
anything = 42;
anything = true;

// Unknown (safer than any)
let userInput: unknown;
userInput = 5;
userInput = "hello";
// let str: string = userInput;  // Error: unknown needs type checking

// Void
function logMessage(): void {
    console.log("Message");
}

// Never (for functions that never return)
function throwError(): never {
    throw new Error("Error");
}

// Object types
let user: { name: string; age: number } = {
    name: "John",
    age: 30
};</code>
                        </div>
                        
                        <h4>Interfaces</h4>
                        <p>Interfaces define the structure of objects and can be extended or implemented.</p>
                        
                        <div class="code-block">
<code>// Basic interface
interface User {
    name: string;
    age: number;
    email?: string;  // Optional property
    readonly id: number;  // Read-only property
}

const user: User = {
    name: "John",
    age: 30,
    id: 1
};
// user.id = 2;  // Error: id is readonly

// Interface with methods
interface Calculator {
    add(a: number, b: number): number;
    subtract(a: number, b: number): number;
}

// Extending interfaces
interface Admin extends User {
    permissions: string[];
    isAdmin: true;
}

// Interface for functions
interface SearchFunction {
    (source: string, subString: string): boolean;
}

const search: SearchFunction = function(src, sub) {
    return src.indexOf(sub) > -1;
};

// Index signatures
interface StringDictionary {
    [key: string]: string;
}

const dict: StringDictionary = {
    name: "John",
    city: "NYC"
};</code>
                        </div>
                        
                        <h4>Type Aliases</h4>
                        <div class="code-block">
<code>// Type alias
type Point = {
    x: number;
    y: number;
};

type ID = string | number;
type Status = "pending" | "approved" | "rejected";

// Type vs Interface
// Interfaces can be extended and merged
interface Animal {
    name: string;
}

interface Animal {
    age: number;  // Merged with previous declaration
}

// Types can use unions, intersections, and computed properties
type Status = "active" | "inactive";
type UserWithStatus = User & { status: Status };

// Intersection types
type Employee = User & {
    employeeId: number;
    department: string;
};</code>
                        </div>
                        
                        <h4>Generics</h4>
                        <p>Generics allow creating reusable components that work with multiple types.</p>
                        
                        <div class="code-block">
<code>// Generic function
function identity&lt;T&gt;(arg: T): T {
    return arg;
}

const num = identity&lt;number&gt;(42);
const str = identity&lt;string&gt;("hello");
// TypeScript can infer types
const inferred = identity("world");  // T is string

// Generic interface
interface Box&lt;T&gt; {
    value: T;
}

const numberBox: Box&lt;number&gt; = { value: 42 };
const stringBox: Box&lt;string&gt; = { value: "hello" };

// Generic class
class Container&lt;T&gt; {
    private items: T[] = [];
    
    add(item: T): void {
        this.items.push(item);
    }
    
    get(index: number): T {
        return this.items[index];
    }
}

const numberContainer = new Container&lt;number&gt;();
numberContainer.add(1);
numberContainer.add(2);

// Multiple type parameters
function pair&lt;T, U&gt;(first: T, second: U): [T, U] {
    return [first, second];
}

const result = pair&lt;string, number&gt;("John", 30);

// Generic constraints
interface Lengthwise {
    length: number;
}

function logLength&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);
    return arg;
}

logLength("hello");  // OK: string has length
logLength([1, 2, 3]);  // OK: array has length
// logLength(42);  // Error: number doesn't have length

// Using type parameters in constraints
function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

const user = { name: "John", age: 30 };
const name = getProperty(user, "name");  // OK
// const invalid = getProperty(user, "email");  // Error</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Generic API Response Handler</h4>
                            <div class="code-block">
<code>interface ApiResponse&lt;T&gt; {
    data: T;
    status: number;
    message: string;
}

async function fetchData&lt;T&gt;(url: string): Promise&lt;ApiResponse&lt;T&gt;&gt; {
    const response = await fetch(url);
    const data: ApiResponse&lt;T&gt; = await response.json();
    return data;
}

// Usage
interface User {
    id: number;
    name: string;
}

const userResponse = await fetchData&lt;User&gt;("/api/user");
console.log(userResponse.data.name);  // TypeScript knows data is User

interface Product {
    id: number;
    title: string;
    price: number;
}

const productResponse = await fetchData&lt;Product[]&gt;("/api/products");
productResponse.data.forEach(product => {
    console.log(product.title);  // TypeScript knows data is Product[]
});</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use interfaces for object shapes that might be extended or implemented. Use type aliases for unions, intersections, or when you need computed properties. Prefer generics over <code>any</code> for type safety.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Type narrowing, guards -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Type narrowing, guards</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Type Narrowing</h3>
                        <p>Type narrowing is the process of refining types to more specific types within a conditional block.</p>
                        
                        <h4>Typeof Guards</h4>
                        <div class="code-block">
<code>function processValue(value: string | number) {
    if (typeof value === "string") {
        // TypeScript knows value is string here
        console.log(value.toUpperCase());
    } else {
        // TypeScript knows value is number here
        console.log(value.toFixed(2));
    }
}

// Typeof return values
// "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function"

function formatValue(value: unknown) {
    if (typeof value === "string") {
        return value.toUpperCase();
    } else if (typeof value === "number") {
        return value.toFixed(2);
    } else if (typeof value === "boolean") {
        return value ? "Yes" : "No";
    }
    return "Unknown";
}</code>
                        </div>
                        
                        <h4>Instanceof Guards</h4>
                        <div class="code-block">
<code>class Dog {
    bark() {
        return "Woof!";
    }
}

class Cat {
    meow() {
        return "Meow!";
    }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        // TypeScript knows animal is Dog
        return animal.bark();
    } else {
        // TypeScript knows animal is Cat
        return animal.meow();
    }
}

// With Date
function formatDate(date: Date | string) {
    if (date instanceof Date) {
        return date.toISOString();
    } else {
        return new Date(date).toISOString();
    }
}</code>
                        </div>
                        
                        <h4>In Operator Guards</h4>
                        <div class="code-block">
<code>interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

function move(animal: Bird | Fish) {
    if ("fly" in animal) {
        // TypeScript knows animal is Bird
        animal.fly();
    } else {
        // TypeScript knows animal is Fish
        animal.swim();
    }
}</code>
                        </div>
                        
                        <h4>Type Predicates</h4>
                        <div class="code-block">
<code>// Type predicate function
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function isNumber(value: unknown): value is number {
    return typeof value === "number";
}

function process(value: unknown) {
    if (isString(value)) {
        // TypeScript knows value is string
        console.log(value.length);
    } else if (isNumber(value)) {
        // TypeScript knows value is number
        console.log(value.toFixed(2));
    }
}

// Custom type guard
interface User {
    name: string;
    email: string;
}

interface Admin {
    name: string;
    permissions: string[];
}

function isAdmin(user: User | Admin): user is Admin {
    return "permissions" in user;
}

function getUserRole(user: User | Admin) {
    if (isAdmin(user)) {
        // TypeScript knows user is Admin
        return user.permissions;
    } else {
        // TypeScript knows user is User
        return user.email;
    }
}</code>
                        </div>
                        
                        <h4>Discriminated Unions</h4>
                        <div class="code-block">
<code>// Using discriminated unions for type narrowing
interface Circle {
    kind: "circle";
    radius: number;
}

interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}

interface Triangle {
    kind: "triangle";
    base: number;
    height: number;
}

type Shape = Circle | Rectangle | Triangle;

function getArea(shape: Shape): number {
    switch (shape.kind) {
        case "circle":
            // TypeScript knows shape is Circle
            return Math.PI * shape.radius ** 2;
        case "rectangle":
            // TypeScript knows shape is Rectangle
            return shape.width * shape.height;
        case "triangle":
            // TypeScript knows shape is Triangle
            return (shape.base * shape.height) / 2;
        default:
            // Exhaustiveness check
            const _exhaustive: never = shape;
            return _exhaustive;
    }
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: API Response Type Guard</h4>
                            <div class="code-block">
<code>interface SuccessResponse&lt;T&gt; {
    success: true;
    data: T;
}

interface ErrorResponse {
    success: false;
    error: string;
}

type ApiResponse&lt;T&gt; = SuccessResponse&lt;T&gt; | ErrorResponse;

function isSuccess&lt;T&gt;(response: ApiResponse&lt;T&gt;): response is SuccessResponse&lt;T&gt; {
    return response.success === true;
}

async function fetchUser(id: number): Promise&lt;ApiResponse&lt;User&gt;&gt; {
    try {
        const response = await fetch(`/api/users/${id}`);
        const data = await response.json();
        return { success: true, data };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

// Usage
const result = await fetchUser(1);
if (isSuccess(result)) {
    // TypeScript knows result is SuccessResponse
    console.log(result.data.name);
} else {
    // TypeScript knows result is ErrorResponse
    console.error(result.error);
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use discriminated unions with a common "kind" or "type" property for better type narrowing. Always include an exhaustive check in switch statements to catch missing cases at compile time.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Decorators -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Decorators</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>TypeScript Decorators</h3>
                        <p>Decorators are a special kind of declaration that can be attached to classes, methods, properties, and parameters. They use the form <code>@expression</code>.</p>
                        
                        <div class="note-info">
                            <h4>‚ÑπÔ∏è Info</h4>
                            <p>Decorators are an experimental feature. Enable them in <code>tsconfig.json</code> with <code>"experimentalDecorators": true</code> and <code>"emitDecoratorMetadata": true</code>.</p>
                        </div>
                        
                        <h4>Class Decorators</h4>
                        <div class="code-block">
<code>// Simple class decorator
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}

// Decorator factory (returns decorator)
function classDecorator&lt;T extends { new (...args: any[]): {} }&gt;(constructor: T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    };
}

@classDecorator
class Greeter {
    property = "property";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}

const greeter = new Greeter("world");
console.log(greeter);  // Has newProperty and overridden hello</code>
                        </div>
                        
                        <h4>Method Decorators</h4>
                        <div class="code-block">
<code>// Method decorator
function enumerable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
    };
}

class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    
    @enumerable(false)
    greet() {
        return "Hello, " + this.greeting;
    }
}

// Logging decorator
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with args:`, args);
        const result = originalMethod.apply(this, args);
        console.log(`${propertyKey} returned:`, result);
        return result;
    };
    
    return descriptor;
}

class Calculator {
    @log
    add(a: number, b: number): number {
        return a + b;
    }
}</code>
                        </div>
                        
                        <h4>Property Decorators</h4>
                        <div class="code-block">
<code>// Property decorator
function format(formatString: string) {
    return function (target: any, propertyKey: string) {
        let value: string;
        
        const getter = function () {
            return value;
        };
        
        const setter = function (newVal: string) {
            value = formatString.replace("%s", newVal);
        };
        
        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
            enumerable: true,
            configurable: true
        });
    };
}

class User {
    @format("Hello, %s!")
    greeting: string;
}

const user = new User();
user.greeting = "World";
console.log(user.greeting);  // "Hello, World!"</code>
                        </div>
                        
                        <h4>Parameter Decorators</h4>
                        <div class="code-block">
<code>// Parameter decorator
function required(target: any, propertyKey: string | symbol, parameterIndex: number) {
    const existingRequiredParameters: number[] = Reflect.getOwnMetadata("required", target, propertyKey) || [];
    existingRequiredParameters.push(parameterIndex);
    Reflect.defineMetadata("required", existingRequiredParameters, target, propertyKey);
}

class UserService {
    createUser(@required name: string, age: number) {
        // Implementation
    }
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Validation Decorator</h4>
                            <div class="code-block">
<code>// Validation decorator
function validate(min: number, max: number) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        
        descriptor.value = function (...args: any[]) {
            const value = args[0];
            if (value &lt; min || value &gt; max) {
                throw new Error(`${propertyKey}: Value must be between ${min} and ${max}`);
            }
            return originalMethod.apply(this, args);
        };
        
        return descriptor;
    };
}

class Calculator {
    @validate(0, 100)
    setPercentage(value: number) {
        this.percentage = value;
    }
    
    percentage: number = 0;
}

const calc = new Calculator();
calc.setPercentage(50);  // OK
// calc.setPercentage(150);  // Error: Value must be between 0 and 100</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Decorators are still experimental in TypeScript. The syntax and behavior may change in future versions. Use them carefully and keep up with TypeScript updates.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: TSConfig, strict mode -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>TSConfig, strict mode</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>TypeScript Configuration</h3>
                        <p>The <code>tsconfig.json</code> file controls TypeScript compiler options and project settings.</p>
                        
                        <h4>Basic tsconfig.json</h4>
                        <div class="code-block">
<code>{
  "compilerOptions": {
    // Target JavaScript version
    "target": "ES2020",
    
    // Module system
    "module": "ESNext",
    "moduleResolution": "node",
    
    // Output settings
    "outDir": "./dist",
    "rootDir": "./src",
    "sourceMap": true,
    
    // Type checking
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    
    // Additional checks
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    
    // Emit
    "declaration": true,
    "declarationMap": true,
    "removeComments": false,
    
    // Interop
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    
    // Advanced
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}</code>
                        </div>
                        
                        <h4>Strict Mode Options</h4>
                        <table>
                            <tr>
                                <th>Option</th>
                                <th>Description</th>
                                <th>Effect</th>
                            </tr>
                            <tr>
                                <td>strict</td>
                                <td>Enables all strict checks</td>
                                <td>Enables all options below</td>
                            </tr>
                            <tr>
                                <td>noImplicitAny</td>
                                <td>Error on implicit any</td>
                                <td>Requires explicit types</td>
                            </tr>
                            <tr>
                                <td>strictNullChecks</td>
                                <td>Strict null checking</td>
                                <td>null/undefined must be handled</td>
                            </tr>
                            <tr>
                                <td>strictFunctionTypes</td>
                                <td>Strict function types</td>
                                <td>Functions must match exactly</td>
                            </tr>
                            <tr>
                                <td>strictBindCallApply</td>
                                <td>Strict bind/call/apply</td>
                                <td>Arguments must match</td>
                            </tr>
                            <tr>
                                <td>strictPropertyInitialization</td>
                                <td>Strict property init</td>
                                <td>Class properties must be initialized</td>
                            </tr>
                            <tr>
                                <td>noImplicitThis</td>
                                <td>Error on implicit this</td>
                                <td>this must be explicit</td>
                            </tr>
                            <tr>
                                <td>alwaysStrict</td>
                                <td>Parse in strict mode</td>
                                <td>Uses strict mode semantics</td>
                            </tr>
                        </table>
                        
                        <h4>Common Configurations</h4>
                        <div class="code-block">
<code>// Node.js project
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}

// React/Next.js project
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}</code>
                        </div>
                        
                        <h4>Path Mapping</h4>
                        <div class="code-block">
<code>{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"],
      "@types/*": ["src/types/*"]
    }
  }
}

// Usage in code
import { Button } from "@components/Button";
import { formatDate } from "@utils/date";
import { User } from "@types/user";</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always enable <code>"strict": true</code> for new projects. It catches many potential bugs at compile time. For existing JavaScript projects, enable strict options gradually to avoid breaking changes.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Building a small TS application -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Building a small TS application</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Complete TypeScript Application</h3>
                        <p>Building a Todo application demonstrates TypeScript features in a real-world scenario.</p>
                        
                        <h4>Project Structure</h4>
                        <div class="code-block">
<code>// types/todo.ts
export interface Todo {
    id: number;
    text: string;
    completed: boolean;
    createdAt: Date;
    completedAt?: Date;
}

export type TodoFilter = "all" | "active" | "completed";

export interface TodoState {
    todos: Todo[];
    filter: TodoFilter;
}

// utils/storage.ts
export class StorageService {
    private static readonly STORAGE_KEY = "todos";
    
    static save(todos: Todo[]): void {
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(todos));
    }
    
    static load(): Todo[] {
        const stored = localStorage.getItem(this.STORAGE_KEY);
        if (!stored) return [];
        
        const parsed = JSON.parse(stored);
        return parsed.map((todo: any) => ({
            ...todo,
            createdAt: new Date(todo.createdAt),
            completedAt: todo.completedAt ? new Date(todo.completedAt) : undefined
        }));
    }
}

// services/todoService.ts
import { Todo, TodoFilter } from "../types/todo";

export class TodoService {
    private todos: Todo[] = [];
    
    constructor(initialTodos: Todo[] = []) {
        this.todos = initialTodos;
    }
    
    addTodo(text: string): Todo {
        const todo: Todo = {
            id: Date.now(),
            text,
            completed: false,
            createdAt: new Date()
        };
        this.todos.push(todo);
        return todo;
    }
    
    toggleTodo(id: number): Todo | undefined {
        const todo = this.todos.find(t => t.id === id);
        if (todo) {
            todo.completed = !todo.completed;
            todo.completedAt = todo.completed ? new Date() : undefined;
        }
        return todo;
    }
    
    deleteTodo(id: number): boolean {
        const index = this.todos.findIndex(t => t.id === id);
        if (index > -1) {
            this.todos.splice(index, 1);
            return true;
        }
        return false;
    }
    
    getTodos(filter?: TodoFilter): Todo[] {
        if (!filter || filter === "all") {
            return [...this.todos];
        }
        return this.todos.filter(todo => 
            filter === "active" ? !todo.completed : todo.completed
        );
    }
    
    getStats() {
        return {
            total: this.todos.length,
            completed: this.todos.filter(t => t.completed).length,
            active: this.todos.filter(t => !t.completed).length
        };
    }
}

// app.ts
import { TodoService } from "./services/todoService";
import { StorageService } from "./utils/storage";
import { TodoFilter } from "./types/todo";

class TodoApp {
    private todoService: TodoService;
    private currentFilter: TodoFilter = "all";
    
    constructor() {
        const savedTodos = StorageService.load();
        this.todoService = new TodoService(savedTodos);
        this.init();
        this.render();
    }
    
    private init(): void {
        const form = document.querySelector&lt;HTMLFormElement&gt;("#todo-form");
        const filterButtons = document.querySelectorAll&lt;HTMLButtonElement&gt;(".filter-btn");
        
        form?.addEventListener("submit", (e) => {
            e.preventDefault();
            const input = form.querySelector&lt;HTMLInputElement&gt;("#todo-input");
            if (input?.value.trim()) {
                this.addTodo(input.value);
                input.value = "";
            }
        });
        
        filterButtons.forEach(btn => {
            btn.addEventListener("click", () => {
                const filter = btn.dataset.filter as TodoFilter;
                this.setFilter(filter);
            });
        });
    }
    
    private addTodo(text: string): void {
        this.todoService.addTodo(text);
        StorageService.save(this.todoService.getTodos());
        this.render();
    }
    
    private toggleTodo(id: number): void {
        this.todoService.toggleTodo(id);
        StorageService.save(this.todoService.getTodos());
        this.render();
    }
    
    private deleteTodo(id: number): void {
        this.todoService.deleteTodo(id);
        StorageService.save(this.todoService.getTodos());
        this.render();
    }
    
    private setFilter(filter: TodoFilter): void {
        this.currentFilter = filter;
        document.querySelectorAll(".filter-btn").forEach(btn => {
            btn.classList.toggle("active", btn.dataset.filter === filter);
        });
        this.render();
    }
    
    private render(): void {
        const todos = this.todoService.getTodos(this.currentFilter);
        const stats = this.todoService.getStats();
        const list = document.querySelector&lt;HTMLUListElement&gt;("#todo-list");
        const statsEl = document.querySelector&lt;HTMLElement&gt;("#stats");
        
        if (list) {
            list.innerHTML = todos.map(todo => `
                &lt;li class="todo-item ${todo.completed ? "completed" : ""}"&gt;
                    &lt;input type="checkbox" ${todo.completed ? "checked" : ""} 
                           onchange="app.toggleTodo(${todo.id})"&gt;
                    &lt;span&gt;${todo.text}&lt;/span&gt;
                    &lt;button onclick="app.deleteTodo(${todo.id})"&gt;Delete&lt;/button&gt;
                &lt;/li&gt;
            `).join("");
        }
        
        if (statsEl) {
            statsEl.innerHTML = `
                Total: ${stats.total} | 
                Active: ${stats.active} | 
                Completed: ${stats.completed}
            `;
        }
    }
}

// Initialize app
const app = new TodoApp();
(window as any).app = app;</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Type-Safe API Client</h4>
                            <div class="code-block">
<code>// api/client.ts
interface ApiConfig {
    baseURL: string;
    headers?: Record&lt;string, string&gt;;
}

class ApiClient {
    private baseURL: string;
    private headers: Record&lt;string, string&gt;;
    
    constructor(config: ApiConfig) {
        this.baseURL = config.baseURL;
        this.headers = config.headers || {};
    }
    
    async get&lt;T&gt;(endpoint: string): Promise&lt;T&gt; {
        const response = await fetch(`${this.baseURL}${endpoint}`, {
            method: "GET",
            headers: this.headers
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return response.json();
    }
    
    async post&lt;T, D&gt;(endpoint: string, data: D): Promise&lt;T&gt; {
        const response = await fetch(`${this.baseURL}${endpoint}`, {
            method: "POST",
            headers: {
                ...this.headers,
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        return response.json();
    }
}

// Usage
interface User {
    id: number;
    name: string;
    email: string;
}

const api = new ApiClient({
    baseURL: "https://api.example.com",
    headers: { "Authorization": "Bearer token" }
});

const user = await api.get&lt;User&gt;("/users/1");
const newUser = await api.post&lt;User, Omit&lt;User, "id"&gt;&gt;("/users", {
    name: "John",
    email: "john@example.com"
});</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Error-free scalable code patterns -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Error-free scalable code patterns</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Best Practices for Scalable TypeScript</h3>
                        <p>Following patterns and practices that ensure type safety and code maintainability.</p>
                        
                        <h4>Utility Types</h4>
                        <div class="code-block">
<code>interface User {
    id: number;
    name: string;
    email: string;
    age: number;
    isActive: boolean;
}

// Partial - all properties optional
type PartialUser = Partial&lt;User&gt;;
// { id?: number; name?: string; ... }

// Required - all properties required
type RequiredUser = Required&lt;PartialUser&gt;;

// Pick - select specific properties
type UserPreview = Pick&lt;User, "id" | "name"&gt;;
// { id: number; name: string; }

// Omit - exclude specific properties
type UserWithoutId = Omit&lt;User, "id"&gt;;
// { name: string; email: string; age: number; isActive: boolean; }

// Readonly - make all properties readonly
type ReadonlyUser = Readonly&lt;User&gt;;

// Record - object with specific key/value types
type UserMap = Record&lt;string, User&gt;;
// { [key: string]: User }

// Extract - extract types from union
type StringKeys = Extract&lt;keyof User, string&gt;;

// Exclude - exclude types from union
type NonStringKeys = Exclude&lt;keyof User, string&gt;;</code>
                        </div>
                        
                        <h4>Conditional Types</h4>
                        <div class="code-block">
<code>// Basic conditional type
type IsArray&lt;T&gt; = T extends any[] ? true : false;

type Test1 = IsArray&lt;number[]&gt;;  // true
type Test2 = IsArray&lt;string&gt;;     // false

// Extract array element type
type ArrayElement&lt;T&gt; = T extends (infer U)[] ? U : never;

type Element = ArrayElement&lt;number[]&gt;;  // number

// Function return type
type ReturnType&lt;T&gt; = T extends (...args: any[]) => infer R ? R : never;

// NonNullable
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;

// Deep readonly
type DeepReadonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly&lt;T[P]&gt; : T[P];
};</code>
                        </div>
                        
                        <h4>Type-Safe Event System</h4>
                        <div class="code-block">
<code>type EventMap = {
    userCreated: { id: number; name: string };
    userUpdated: { id: number; changes: Partial&lt;User&gt; };
    userDeleted: { id: number };
};

class EventEmitter&lt;T extends Record&lt;string, any&gt;&gt; {
    private listeners: {
        [K in keyof T]?: Array&lt;(data: T[K]) => void&gt;
    } = {};
    
    on&lt;K extends keyof T&gt;(event: K, listener: (data: T[K]) => void): void {
        if (!this.listeners[event]) {
            this.listeners[event] = [];
        }
        this.listeners[event]!.push(listener);
    }
    
    emit&lt;K extends keyof T&gt;(event: K, data: T[K]): void {
        const eventListeners = this.listeners[event];
        if (eventListeners) {
            eventListeners.forEach(listener => listener(data));
        }
    }
}

// Usage
const emitter = new EventEmitter&lt;EventMap&gt;();

emitter.on("userCreated", (data) => {
    // TypeScript knows data is { id: number; name: string }
    console.log(data.id, data.name);
});

emitter.emit("userCreated", { id: 1, name: "John" });</code>
                        </div>
                        
                        <h4>Builder Pattern</h4>
                        <div class="code-block">
<code>class QueryBuilder&lt;T&gt; {
    private filters: Array&lt;(item: T) => boolean&gt; = [];
    private sortFn?: (a: T, b: T) => number;
    private limitCount?: number;
    
    where(predicate: (item: T) => boolean): this {
        this.filters.push(predicate);
        return this;
    }
    
    sort(fn: (a: T, b: T) => number): this {
        this.sortFn = fn;
        return this;
    }
    
    take(count: number): this {
        this.limitCount = count;
        return this;
    }
    
    execute(items: T[]): T[] {
        let result = items.filter(item => 
            this.filters.every(filter => filter(item))
        );
        
        if (this.sortFn) {
            result = result.sort(this.sortFn);
        }
        
        if (this.limitCount) {
            result = result.slice(0, this.limitCount);
        }
        
        return result;
    }
}

// Usage
interface Product {
    name: string;
    price: number;
    category: string;
}

const products: Product[] = [
    { name: "Laptop", price: 1000, category: "Electronics" },
    { name: "Book", price: 20, category: "Education" }
];

const results = new QueryBuilder&lt;Product&gt;()
    .where(p => p.price &lt; 500)
    .sort((a, b) => a.price - b.price)
    .take(10)
    .execute(products);</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use utility types to create variations of existing types. Leverage conditional types for complex type transformations. Always prefer composition over inheritance for better type inference and flexibility.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 05: React Fundamentals -->
        <div class="video-section" id="video-05">
            <div class="video-header">
                <span class="video-number">Video 05</span>
                <h2 class="video-title">React Fundamentals (with TypeScript)</h2>
            </div>
            
            <!-- Topic 1: Components, props, state -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Components, props, state</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>React Components</h3>
                        <p>Components are the building blocks of React applications. They are reusable pieces of UI that can be composed together.</p>
                        
                        <h4>Function Components</h4>
                        <div class="code-block">
<code>// Basic function component
function Greeting() {
    return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
}

// Arrow function component
const Greeting = () => {
    return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
};

// With TypeScript
interface GreetingProps {
    name: string;
}

const Greeting: React.FC&lt;GreetingProps&gt; = ({ name }) => {
    return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
};

// Or without React.FC (recommended)
const Greeting = ({ name }: GreetingProps) => {
    return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
};</code>
                        </div>
                        
                        <h4>Props</h4>
                        <p>Props (properties) are read-only data passed from parent to child components.</p>
                        
                        <div class="code-block">
<code>// Basic props
interface ButtonProps {
    label: string;
    onClick: () => void;
    disabled?: boolean;
    variant?: "primary" | "secondary";
}

const Button = ({ label, onClick, disabled = false, variant = "primary" }: ButtonProps) => {
    return (
        &lt;button 
            onClick={onClick} 
            disabled={disabled}
            className={`btn btn-${variant}`}
        &gt;
            {label}
        &lt;/button&gt;
    );
};

// Usage
&lt;Button 
    label="Click Me" 
    onClick={() => console.log("Clicked")}
    variant="primary"
/&gt;

// Children prop
interface CardProps {
    title: string;
    children: React.ReactNode;
}

const Card = ({ title, children }: CardProps) => {
    return (
        &lt;div className="card"&gt;
            &lt;h2&gt;{title}&lt;/h2&gt;
            {children}
        &lt;/div&gt;
    );
};

// Usage
&lt;Card title="User Profile"&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/Card&gt;

// Spreading props
interface InputProps extends React.InputHTMLAttributes&lt;HTMLInputElement&gt; {
    label: string;
}

const Input = ({ label, ...props }: InputProps) => {
    return (
        &lt;div className="input-group"&gt;
            &lt;label&gt;{label}&lt;/label&gt;
            &lt;input {...props} /&gt;
        &lt;/div&gt;
    );
};</code>
                        </div>
                        
                        <h4>State</h4>
                        <p>State is data that can change over time. In function components, we use the <code>useState</code> hook.</p>
                        
                        <div class="code-block">
<code>import { useState } from "react";

// Basic state
const Counter = () => {
    const [count, setCount] = useState&lt;number&gt;(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
            &lt;button onClick={() => setCount(count - 1)}&gt;Decrement&lt;/button&gt;
            &lt;button onClick={() => setCount(0)}&gt;Reset&lt;/button&gt;
        &lt;/div&gt;
    );
};

// State with object
interface User {
    name: string;
    email: string;
}

const UserForm = () => {
    const [user, setUser] = useState&lt;User&gt;({
        name: "",
        email: ""
    });
    
    const updateName = (name: string) => {
        setUser({ ...user, name });
    };
    
    const updateEmail = (email: string) => {
        setUser({ ...user, email });
    };
    
    // Or with function update
    const updateUser = (updates: Partial&lt;User&gt;) => {
        setUser(prev => ({ ...prev, ...updates }));
    };
    
    return (
        &lt;div&gt;
            &lt;input 
                value={user.name}
                onChange={(e) => updateName(e.target.value)}
            /&gt;
            &lt;input 
                value={user.email}
                onChange={(e) => updateEmail(e.target.value)}
            /&gt;
        &lt;/div&gt;
    );
};

// State with array
const TodoList = () => {
    const [todos, setTodos] = useState&lt;string[]&gt;([]);
    
    const addTodo = (todo: string) => {
        setTodos([...todos, todo]);
    };
    
    const removeTodo = (index: number) => {
        setTodos(todos.filter((_, i) => i !== index));
    };
    
    return (
        &lt;div&gt;
            {todos.map((todo, index) => (
                &lt;div key={index}&gt;
                    {todo}
                    &lt;button onClick={() => removeTodo(index)}&gt;Remove&lt;/button&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: User Profile Component</h4>
                            <div class="code-block">
<code>interface User {
    id: number;
    name: string;
    email: string;
    avatar?: string;
}

interface UserProfileProps {
    userId: number;
}

const UserProfile = ({ userId }: UserProfileProps) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [loading, setLoading] = useState&lt;boolean&gt;(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetchUser(userId);
    }, [userId]);
    
    const fetchUser = async (id: number) => {
        try {
            setLoading(true);
            const response = await fetch(`/api/users/${id}`);
            const data = await response.json();
            setUser(data);
        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
    
    return (
        &lt;div className="user-profile"&gt;
            {user.avatar && &lt;img src={user.avatar} alt={user.name} /&gt;}
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always use the function form of setState when the new state depends on the previous state: <code>setCount(prev => prev + 1)</code>. This ensures you're working with the latest state value.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Events, hooks, useEffect -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Events, hooks, useEffect</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Event Handling</h3>
                        <p>React events are SyntheticEvents that wrap native browser events for cross-browser compatibility.</p>
                        
                        <h4>Basic Event Handling</h4>
                        <div class="code-block">
<code>// Click event
const Button = () => {
    const handleClick = () => {
        console.log("Button clicked");
    };
    
    return &lt;button onClick={handleClick}&gt;Click Me&lt;/button&gt;;
};

// Inline handler
const Button = () => {
    return &lt;button onClick={() => console.log("Clicked")}&gt;Click Me&lt;/button&gt;;
};

// Event with parameters
const Button = ({ label }: { label: string }) => {
    const handleClick = (label: string) => {
        console.log(`${label} clicked`);
    };
    
    return &lt;button onClick={() => handleClick(label)}&gt;{label}&lt;/button&gt;;
};

// Typed event handlers
const Input = () => {
    const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        console.log(e.target.value);
    };
    
    const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) => {
        e.preventDefault();
        // Handle form submission
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input onChange={handleChange} /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};

// Common event types
// React.ChangeEvent&lt;HTMLInputElement&gt;
// React.MouseEvent&lt;HTMLButtonElement&gt;
// React.FormEvent&lt;HTMLFormElement&gt;
// React.KeyboardEvent&lt;HTMLInputElement&gt;</code>
                        </div>
                        
                        <h4>React Hooks</h4>
                        <p>Hooks are functions that let you "hook into" React features from function components.</p>
                        
                        <div class="code-block">
<code>// useState - already covered
import { useState } from "react";

// useEffect - side effects
import { useEffect } from "react";

const DataFetcher = ({ url }: { url: string }) => {
    const [data, setData] = useState&lt;any&gt;(null);
    
    useEffect(() => {
        // Runs after every render
        fetch(url)
            .then(res => res.json())
            .then(data => setData(data));
    });
    
    return &lt;div&gt;{data ? JSON.stringify(data) : "Loading..."}&lt;/div&gt;;
};

// useEffect with dependencies
useEffect(() => {
    // Runs only when url changes
    fetch(url)
        .then(res => res.json())
        .then(data => setData(data));
}, [url]);  // Dependency array

// useEffect with cleanup
useEffect(() => {
    const timer = setInterval(() => {
        console.log("Tick");
    }, 1000);
    
    // Cleanup function
    return () => {
        clearInterval(timer);
    };
}, []);  // Runs once on mount, cleanup on unmount

// useContext - access context
import { useContext, createContext } from "react";

interface ThemeContextType {
    theme: "light" | "dark";
    toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

const ThemeProvider = ({ children }: { children: React.ReactNode }) => {
    const [theme, setTheme] = useState&lt;"light" | "dark"&gt;("light");
    
    const toggleTheme = () => {
        setTheme(prev => prev === "light" ? "dark" : "light");
    };
    
    return (
        &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
};

const useTheme = () => {
    const context = useContext(ThemeContext);
    if (!context) {
        throw new Error("useTheme must be used within ThemeProvider");
    }
    return context;
};

// useRef - mutable reference
import { useRef } from "react";

const InputFocus = () => {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    const focusInput = () => {
        inputRef.current?.focus();
    };
    
    return (
        &lt;div&gt;
            &lt;input ref={inputRef} /&gt;
            &lt;button onClick={focusInput}&gt;Focus Input&lt;/button&gt;
        &lt;/div&gt;
    );
};

// useMemo - memoize expensive calculations
import { useMemo } from "react";

const ExpensiveComponent = ({ items }: { items: number[] }) => {
    const sum = useMemo(() => {
        return items.reduce((acc, item) => acc + item, 0);
    }, [items]);
    
    return &lt;div&gt;Sum: {sum}&lt;/div&gt;;
};

// useCallback - memoize functions
import { useCallback } from "react";

const Parent = () => {
    const [count, setCount] = useState(0);
    
    const handleClick = useCallback(() => {
        setCount(prev => prev + 1);
    }, []);  // Function doesn't change
    
    return &lt;Child onClick={handleClick} /&gt;;
};</code>
                        </div>
                        
                        <h4>useEffect Patterns</h4>
                        <div class="code-block">
<code>// Component mount (run once)
useEffect(() => {
    console.log("Component mounted");
    // Setup code
    
    return () => {
        console.log("Component unmounted");
        // Cleanup code
    };
}, []);  // Empty dependency array

// Run on every render (avoid unless necessary)
useEffect(() => {
    console.log("Component rendered");
});

// Run when dependencies change
useEffect(() => {
    fetchData(userId);
}, [userId]);

// Multiple effects
useEffect(() => {
    // Effect 1
}, [dependency1]);

useEffect(() => {
    // Effect 2
}, [dependency2]);

// Conditional effect
useEffect(() => {
    if (shouldFetch) {
        fetchData();
    }
}, [shouldFetch]);

// Async effect
useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
        const data = await api.getData();
        if (!cancelled) {
            setData(data);
        }
    };
    
    fetchData();
    
    return () => {
        cancelled = true;
    };
}, []);</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Custom Hook</h4>
                            <div class="code-block">
<code>// Custom hook for data fetching
interface UseFetchResult&lt;T&gt; {
    data: T | null;
    loading: boolean;
    error: Error | null;
    refetch: () => void;
}

function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [loading, setLoading] = useState&lt;boolean&gt;(true);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    const fetchData = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const json = await response.json();
            setData(json);
        } catch (err) {
            setError(err instanceof Error ? err : new Error("Unknown error"));
        } finally {
            setLoading(false);
        }
    }, [url]);
    
    useEffect(() => {
        fetchData();
    }, [fetchData]);
    
    return { data, loading, error, refetch: fetchData };
}

// Usage
interface User {
    id: number;
    name: string;
}

const UserProfile = ({ userId }: { userId: number }) => {
    const { data: user, loading, error, refetch } = useFetch&lt;User&gt;(`/api/users/${userId}`);
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    if (!user) return &lt;div&gt;No user found&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;button onClick={refetch}&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    );
};</code>
                            </div>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Always include all dependencies in the useEffect dependency array. Missing dependencies can lead to stale closures and bugs. Use ESLint's <code>exhaustive-deps</code> rule to catch missing dependencies.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Re-rendering logic -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Re-rendering logic</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Understanding React Re-renders</h3>
                        <p>React re-renders components when state or props change. Understanding when and why re-renders happen is crucial for performance.</p>
                        
                        <h4>When Components Re-render</h4>
                        <ul>
                            <li>State changes (via <code>useState</code> or <code>useReducer</code>)</li>
                            <li>Props change</li>
                            <li>Parent component re-renders</li>
                            <li>Context value changes</li>
                        </ul>
                        
                        <div class="code-block">
<code>// Parent re-render causes child re-render
const Parent = () => {
    const [count, setCount] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Count: {count}&lt;/button&gt;
            &lt;Child /&gt;  {/* Re-renders when Parent re-renders */}
        &lt;/div&gt;
    );
};

const Child = () => {
    console.log("Child rendered");
    return &lt;div&gt;Child&lt;/div&gt;;
};

// Preventing unnecessary re-renders with React.memo
const Child = React.memo(() => {
    console.log("Child rendered");
    return &lt;div&gt;Child&lt;/div&gt;;
});

// Memo with custom comparison
const Child = React.memo(
    ({ name }: { name: string }) => {
        return &lt;div&gt;{name}&lt;/div&gt;;
    },
    (prevProps, nextProps) => {
        // Return true if props are equal (skip re-render)
        return prevProps.name === nextProps.name;
    }
);</code>
                        </div>
                        
                        <h4>Optimizing Re-renders</h4>
                        <div class="code-block">
<code>// useMemo - memoize expensive calculations
const ExpensiveList = ({ items }: { items: number[] }) => {
    const sortedItems = useMemo(() => {
        console.log("Sorting items");
        return [...items].sort((a, b) => a - b);
    }, [items]);  // Only recalculate when items change
    
    return (
        &lt;ul&gt;
            {sortedItems.map(item => &lt;li key={item}&gt;{item}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
};

// useCallback - memoize functions
const Parent = () => {
    const [count, setCount] = useState(0);
    const [name, setName] = useState("");
    
    // Without useCallback - new function on every render
    const handleClick = () => {
        console.log("Clicked");
    };
    
    // With useCallback - same function reference
    const handleClick = useCallback(() => {
        console.log("Clicked");
    }, []);  // Empty deps = function never changes
    
    // With dependencies
    const handleClick = useCallback(() => {
        console.log(`Clicked: ${name}`);
    }, [name]);  // New function when name changes
    
    return (
        &lt;div&gt;
            &lt;input value={name} onChange={(e) => setName(e.target.value)} /&gt;
            &lt;Child onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
};

const Child = React.memo(({ onClick }: { onClick: () => void }) => {
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});

// useRef - values that don't trigger re-renders
const Component = () => {
    const [count, setCount] = useState(0);
    const renderCount = useRef(0);
    
    renderCount.current += 1;  // Doesn't cause re-render
    
    return (
        &lt;div&gt;
            &lt;p&gt;Rendered {renderCount.current} times&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Count: {count}&lt;/button&gt;
        &lt;/div&gt;
    );
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Optimized List Component</h4>
                            <div class="code-block">
<code>interface Item {
    id: number;
    name: string;
    price: number;
}

interface ItemListProps {
    items: Item[];
    onItemClick: (id: number) => void;
}

// Memoized item component
const ItemCard = React.memo(({ item, onClick }: { item: Item; onClick: (id: number) => void }) => {
    return (
        &lt;div onClick={() => onClick(item.id)}&gt;
            &lt;h3&gt;{item.name}&lt;/h3&gt;
            &lt;p&gt;${item.price}&lt;/p&gt;
        &lt;/div&gt;
    );
});

const ItemList = ({ items, onItemClick }: ItemListProps) => {
    // Memoize sorted items
    const sortedItems = useMemo(() => {
        return [...items].sort((a, b) => a.price - b.price);
    }, [items]);
    
    // Memoize click handler
    const handleClick = useCallback((id: number) => {
        onItemClick(id);
    }, [onItemClick]);
    
    return (
        &lt;div&gt;
            {sortedItems.map(item => (
                &lt;ItemCard 
                    key={item.id} 
                    item={item} 
                    onClick={handleClick}
                /&gt;
            ))}
        &lt;/div&gt;
    );
};</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Don't over-optimize. React is fast by default. Only use <code>React.memo</code>, <code>useMemo</code>, and <code>useCallback</code> when you've identified a performance problem. Premature optimization can make code harder to maintain.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Controlled/uncontrolled inputs -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Controlled/uncontrolled inputs</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Controlled vs Uncontrolled Components</h3>
                        <p>Controlled components have their value controlled by React state, while uncontrolled components use refs to access DOM values.</p>
                        
                        <h4>Controlled Inputs</h4>
                        <div class="code-block">
<code>// Controlled input - React controls the value
const ControlledInput = () => {
    const [value, setValue] = useState("");
    
    const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        setValue(e.target.value);
    };
    
    return (
        &lt;input 
            type="text"
            value={value}
            onChange={handleChange}
        /&gt;
    );
};

// Controlled form
interface FormData {
    name: string;
    email: string;
    age: number;
}

const ControlledForm = () => {
    const [formData, setFormData] = useState&lt;FormData&gt;({
        name: "",
        email: "",
        age: 0
    });
    
    const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: name === "age" ? parseInt(value) || 0 : value
        }));
    };
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        console.log(formData);
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input
                name="name"
                value={formData.name}
                onChange={handleChange}
                placeholder="Name"
            /&gt;
            &lt;input
                name="email"
                type="email"
                value={formData.email}
                onChange={handleChange}
                placeholder="Email"
            /&gt;
            &lt;input
                name="age"
                type="number"
                value={formData.age}
                onChange={handleChange}
                placeholder="Age"
            /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};</code>
                        </div>
                        
                        <h4>Uncontrolled Inputs</h4>
                        <div class="code-block">
<code>// Uncontrolled input - DOM controls the value
const UncontrolledInput = () => {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const value = inputRef.current?.value;
        console.log(value);
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input 
                type="text"
                ref={inputRef}
                defaultValue="Initial value"
            /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};

// Uncontrolled form with FormData
const UncontrolledForm = () => {
    const formRef = useRef&lt;HTMLFormElement&gt;(null);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        const formData = new FormData(formRef.current!);
        const data = {
            name: formData.get("name") as string,
            email: formData.get("email") as string,
            age: parseInt(formData.get("age") as string)
        };
        console.log(data);
    };
    
    return (
        &lt;form ref={formRef} onSubmit={handleSubmit}&gt;
            &lt;input name="name" defaultValue="" /&gt;
            &lt;input name="email" type="email" defaultValue="" /&gt;
            &lt;input name="age" type="number" defaultValue="0" /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};</code>
                        </div>
                        
                        <h4>When to Use Each</h4>
                        <table>
                            <tr>
                                <th>Aspect</th>
                                <th>Controlled</th>
                                <th>Uncontrolled</th>
                            </tr>
                            <tr>
                                <td>Value source</td>
                                <td>React state</td>
                                <td>DOM</td>
                            </tr>
                            <tr>
                                <td>Validation</td>
                                <td>Real-time</td>
                                <td>On submit</td>
                            </tr>
                            <tr>
                                <td>Performance</td>
                                <td>Re-renders on change</td>
                                <td>No re-renders</td>
                            </tr>
                            <tr>
                                <td>Use case</td>
                                <td>Forms with validation, dynamic UI</td>
                                <td>Simple forms, file inputs</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Form with Validation</h4>
                            <div class="code-block">
<code>interface FormErrors {
    name?: string;
    email?: string;
    age?: string;
}

const ValidatedForm = () => {
    const [formData, setFormData] = useState({
        name: "",
        email: "",
        age: ""
    });
    const [errors, setErrors] = useState&lt;FormErrors&gt;({});
    
    const validate = (name: string, value: string): string | undefined => {
        switch (name) {
            case "name":
                if (!value.trim()) return "Name is required";
                if (value.length &lt; 2) return "Name must be at least 2 characters";
                break;
            case "email":
                if (!value) return "Email is required";
                if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
                    return "Invalid email format";
                }
                break;
            case "age":
                const ageNum = parseInt(value);
                if (!value) return "Age is required";
                if (isNaN(ageNum) || ageNum &lt; 0 || ageNum &gt; 120) {
                    return "Age must be between 0 and 120";
                }
                break;
        }
    };
    
    const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        const { name, value } = e.target;
        setFormData(prev => ({ ...prev, [name]: value }));
        
        // Real-time validation
        const error = validate(name, value);
        setErrors(prev => ({ ...prev, [name]: error }));
    };
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        
        // Validate all fields
        const newErrors: FormErrors = {};
        Object.keys(formData).forEach(key => {
            const error = validate(key, formData[key as keyof typeof formData]);
            if (error) newErrors[key as keyof FormErrors] = error;
        });
        
        setErrors(newErrors);
        
        if (Object.keys(newErrors).length === 0) {
            console.log("Form is valid:", formData);
        }
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;div&gt;
                &lt;input
                    name="name"
                    value={formData.name}
                    onChange={handleChange}
                    placeholder="Name"
                /&gt;
                {errors.name && &lt;span className="error"&gt;{errors.name}&lt;/span&gt;}
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input
                    name="email"
                    type="email"
                    value={formData.email}
                    onChange={handleChange}
                    placeholder="Email"
                /&gt;
                {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
            &lt;/div&gt;
            &lt;div&gt;
                &lt;input
                    name="age"
                    type="number"
                    value={formData.age}
                    onChange={handleChange}
                    placeholder="Age"
                /&gt;
                {errors.age && &lt;span className="error"&gt;{errors.age}&lt;/span&gt;}
            &lt;/div&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
};</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Component architecture -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Component architecture</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Component Organization Patterns</h3>
                        <p>Good component architecture makes code maintainable, testable, and scalable.</p>
                        
                        <h4>Component Structure</h4>
                        <div class="code-block">
<code>// Component file structure
// components/UserCard/UserCard.tsx
// components/UserCard/UserCard.module.css
// components/UserCard/index.ts
// components/UserCard/UserCard.test.tsx

// UserCard.tsx
import styles from "./UserCard.module.css";

interface UserCardProps {
    user: User;
    onEdit?: (user: User) => void;
    onDelete?: (id: number) => void;
}

export const UserCard = ({ user, onEdit, onDelete }: UserCardProps) => {
    return (
        &lt;div className={styles.card}&gt;
            &lt;h3&gt;{user.name}&lt;/h3&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
            {onEdit && &lt;button onClick={() => onEdit(user)}&gt;Edit&lt;/button&gt;}
            {onDelete && &lt;button onClick={() => onDelete(user.id)}&gt;Delete&lt;/button&gt;}
        &lt;/div&gt;
    );
};

// index.ts
export { UserCard } from "./UserCard";
export type { UserCardProps } from "./UserCard";</code>
                        </div>
                        
                        <h4>Container/Presentational Pattern</h4>
                        <div class="code-block">
<code>// Presentational component (dumb component)
interface UserListProps {
    users: User[];
    onUserClick: (id: number) => void;
}

export const UserList = ({ users, onUserClick }: UserListProps) => {
    return (
        &lt;ul&gt;
            {users.map(user => (
                &lt;li key={user.id} onClick={() => onUserClick(user.id)}&gt;
                    {user.name}
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};

// Container component (smart component)
export const UserListContainer = () => {
    const [users, setUsers] = useState&lt;User[]&gt;([]);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        fetchUsers().then(data => {
            setUsers(data);
            setLoading(false);
        });
    }, []);
    
    const handleUserClick = (id: number) => {
        // Navigate or perform action
        console.log("User clicked:", id);
    };
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    
    return &lt;UserList users={users} onUserClick={handleUserClick} /&gt;;
};</code>
                        </div>
                        
                        <h4>Composition Pattern</h4>
                        <div class="code-block">
<code>// Using composition instead of props drilling
interface CardProps {
    children: React.ReactNode;
}

const Card = ({ children }: CardProps) => {
    return &lt;div className="card"&gt;{children}&lt;/div&gt;;
};

const CardHeader = ({ children }: CardProps) => {
    return &lt;div className="card-header"&gt;{children}&lt;/div&gt;;
};

const CardBody = ({ children }: CardProps) => {
    return &lt;div className="card-body"&gt;{children}&lt;/div&gt;;
};

const CardFooter = ({ children }: CardProps) => {
    return &lt;div className="card-footer"&gt;{children}&lt;/div&gt;;
};

// Usage
&lt;Card&gt;
    &lt;CardHeader&gt;
        &lt;h2&gt;Title&lt;/h2&gt;
    &lt;/CardHeader&gt;
    &lt;CardBody&gt;
        &lt;p&gt;Content&lt;/p&gt;
    &lt;/CardBody&gt;
    &lt;CardFooter&gt;
        &lt;button&gt;Action&lt;/button&gt;
    &lt;/CardFooter&gt;
&lt;/Card&gt;

// Compound components pattern
interface SelectProps {
    value: string;
    onChange: (value: string) => void;
    children: React.ReactNode;
}

const SelectContext = createContext&lt;{
    value: string;
    onChange: (value: string) => void;
} | null&gt;(null);

const Select = ({ value, onChange, children }: SelectProps) => {
    return (
        &lt;SelectContext.Provider value={{ value, onChange }}&gt;
            &lt;div className="select"&gt;{children}&lt;/div&gt;
        &lt;/SelectContext.Provider&gt;
    );
};

const SelectOption = ({ value: optionValue, children }: { value: string; children: React.ReactNode }) => {
    const context = useContext(SelectContext);
    if (!context) throw new Error("SelectOption must be inside Select");
    
    const isSelected = context.value === optionValue;
    
    return (
        &lt;div
            className={isSelected ? "selected" : ""}
            onClick={() => context.onChange(optionValue)}
        &gt;
            {children}
        &lt;/div&gt;
    );
};

// Usage
&lt;Select value={selected} onChange={setSelected}&gt;
    &lt;SelectOption value="option1"&gt;Option 1&lt;/SelectOption&gt;
    &lt;SelectOption value="option2"&gt;Option 2&lt;/SelectOption&gt;
&lt;/Select&gt;</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Feature-Based Organization</h4>
                            <div class="code-block">
<code>// Feature-based folder structure
// features/users/
//   components/
//     UserCard.tsx
//     UserList.tsx
//     UserForm.tsx
//   hooks/
//     useUser.ts
//     useUsers.ts
//   services/
//     userService.ts
//   types/
//     user.ts
//   index.ts

// features/users/hooks/useUser.ts
export const useUser = (id: number) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        userService.getUser(id).then(setUser).finally(() => setLoading(false));
    }, [id]);
    
    return { user, loading };
};

// features/users/components/UserCard.tsx
export const UserCard = ({ userId }: { userId: number }) => {
    const { user, loading } = useUser(userId);
    
    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
    
    return (
        &lt;div className="user-card"&gt;
            &lt;h3&gt;{user.name}&lt;/h3&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Simple React project -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Simple React project</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Building a Todo Application</h3>
                        <p>A complete Todo app demonstrates React fundamentals in practice.</p>
                        
                        <h4>Project Setup</h4>
                        <div class="code-block">
<code>// Create React app with TypeScript
npx create-react-app todo-app --template typescript

// Project structure
src/
  components/
    TodoList.tsx
    TodoItem.tsx
    TodoForm.tsx
    TodoFilter.tsx
  hooks/
    useTodos.ts
  types/
    todo.ts
  utils/
    storage.ts
  App.tsx
  index.tsx</code>
                        </div>
                        
                        <h4>Complete Implementation</h4>
                        <div class="code-block">
<code>// types/todo.ts
export interface Todo {
    id: number;
    text: string;
    completed: boolean;
    createdAt: Date;
}

export type TodoFilter = "all" | "active" | "completed";

// hooks/useTodos.ts
import { useState, useEffect } from "react";
import { Todo, TodoFilter } from "../types/todo";

export const useTodos = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [filter, setFilter] = useState&lt;TodoFilter&gt;("all");
    
    useEffect(() => {
        const stored = localStorage.getItem("todos");
        if (stored) {
            setTodos(JSON.parse(stored));
        }
    }, []);
    
    useEffect(() => {
        localStorage.setItem("todos", JSON.stringify(todos));
    }, [todos]);
    
    const addTodo = (text: string) => {
        const newTodo: Todo = {
            id: Date.now(),
            text,
            completed: false,
            createdAt: new Date()
        };
        setTodos(prev => [...prev, newTodo]);
    };
    
    const toggleTodo = (id: number) => {
        setTodos(prev =>
            prev.map(todo =>
                todo.id === id ? { ...todo, completed: !todo.completed } : todo
            )
        );
    };
    
    const deleteTodo = (id: number) => {
        setTodos(prev => prev.filter(todo => todo.id !== id));
    };
    
    const filteredTodos = todos.filter(todo => {
        if (filter === "active") return !todo.completed;
        if (filter === "completed") return todo.completed;
        return true;
    });
    
    return {
        todos: filteredTodos,
        filter,
        setFilter,
        addTodo,
        toggleTodo,
        deleteTodo,
        stats: {
            total: todos.length,
            active: todos.filter(t => !t.completed).length,
            completed: todos.filter(t => t.completed).length
        }
    };
};

// components/TodoForm.tsx
import { useState, FormEvent } from "react";

interface TodoFormProps {
    onAdd: (text: string) => void;
}

export const TodoForm = ({ onAdd }: TodoFormProps) => {
    const [text, setText] = useState("");
    
    const handleSubmit = (e: FormEvent) => {
        e.preventDefault();
        if (text.trim()) {
            onAdd(text.trim());
            setText("");
        }
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input
                type="text"
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Add a new todo..."
            /&gt;
            &lt;button type="submit"&gt;Add&lt;/button&gt;
        &lt;/form&gt;
    );
};

// components/TodoItem.tsx
import { Todo } from "../types/todo";

interface TodoItemProps {
    todo: Todo;
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

export const TodoItem = ({ todo, onToggle, onDelete }: TodoItemProps) => {
    return (
        &lt;div className={`todo-item ${todo.completed ? "completed" : ""}`}&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
    );
};

// components/TodoList.tsx
import { TodoItem } from "./TodoItem";
import { Todo } from "../types/todo";

interface TodoListProps {
    todos: Todo[];
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

export const TodoList = ({ todos, onToggle, onDelete }: TodoListProps) => {
    if (todos.length === 0) {
        return &lt;div&gt;No todos yet. Add one above!&lt;/div&gt;;
    }
    
    return (
        &lt;ul className="todo-list"&gt;
            {todos.map(todo => (
                &lt;TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={onToggle}
                    onDelete={onDelete}
                /&gt;
            ))}
        &lt;/ul&gt;
    );
};

// components/TodoFilter.tsx
import { TodoFilter } from "../types/todo";

interface TodoFilterProps {
    currentFilter: TodoFilter;
    onFilterChange: (filter: TodoFilter) => void;
    stats: {
        total: number;
        active: number;
        completed: number;
    };
}

export const TodoFilter = ({ currentFilter, onFilterChange, stats }: TodoFilterProps) => {
    return (
        &lt;div className="todo-filter"&gt;
            &lt;button
                className={currentFilter === "all" ? "active" : ""}
                onClick={() => onFilterChange("all")}
            &gt;
                All ({stats.total})
            &lt;/button&gt;
            &lt;button
                className={currentFilter === "active" ? "active" : ""}
                onClick={() => onFilterChange("active")}
            &gt;
                Active ({stats.active})
            &lt;/button&gt;
            &lt;button
                className={currentFilter === "completed" ? "active" : ""}
                onClick={() => onFilterChange("completed")}
            &gt;
                Completed ({stats.completed})
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

// App.tsx
import { TodoForm } from "./components/TodoForm";
import { TodoList } from "./components/TodoList";
import { TodoFilter } from "./components/TodoFilter";
import { useTodos } from "./hooks/useTodos";

function App() {
    const {
        todos,
        filter,
        setFilter,
        addTodo,
        toggleTodo,
        deleteTodo,
        stats
    } = useTodos();
    
    return (
        &lt;div className="app"&gt;
            &lt;h1&gt;Todo App&lt;/h1&gt;
            &lt;TodoForm onAdd={addTodo} /&gt;
            &lt;TodoFilter
                currentFilter={filter}
                onFilterChange={setFilter}
                stats={stats}
            /&gt;
            &lt;TodoList
                todos={todos}
                onToggle={toggleTodo}
                onDelete={deleteTodo}
            /&gt;
        &lt;/div&gt;
    );
}

export default App;</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Start with simple components and gradually add complexity. Use custom hooks to extract logic from components. Keep components small and focused on a single responsibility.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 06: Next.js 14 App Router Basics -->
        <div class="video-section" id="video-06">
            <div class="video-header">
                <span class="video-number">Video 06</span>
                <h2 class="video-title">Next.js 14 App Router Basics</h2>
            </div>
            
            <!-- Topic 1: App Router concepts -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>App Router concepts</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Next.js App Router</h3>
                        <p>The App Router is Next.js 13+ routing system built on React Server Components, providing a new way to build applications with improved performance and developer experience.</p>
                        
                        <h4>Key Concepts</h4>
                        <ul>
                            <li><strong>Server Components:</strong> Components that render on the server by default</li>
                            <li><strong>File-based Routing:</strong> Routes defined by folder structure</li>
                            <li><strong>Layouts:</strong> Shared UI that persists across routes</li>
                            <li><strong>Loading States:</strong> Built-in loading UI</li>
                            <li><strong>Error Handling:</strong> Error boundaries for routes</li>
                            <li><strong>Streaming:</strong> Progressive rendering of UI</li>
                        </ul>
                        
                        <h4>Project Structure</h4>
                        <div class="code-block">
<code>app/
  layout.tsx          // Root layout
  page.tsx            // Home page (/)
  loading.tsx         // Loading UI
  error.tsx           // Error UI
  not-found.tsx       // 404 page
  about/
    page.tsx          // /about page
    layout.tsx        // Layout for /about
  blog/
    page.tsx          // /blog page
    [slug]/
      page.tsx        // /blog/[slug] dynamic route
  api/
    users/
      route.ts        // API route /api/users</code>
                        </div>
                        
                        <h4>Special Files</h4>
                        <table>
                            <tr>
                                <th>File</th>
                                <th>Purpose</th>
                                <th>Required</th>
                            </tr>
                            <tr>
                                <td>layout.tsx</td>
                                <td>Shared UI for segment and children</td>
                                <td>Root: Yes</td>
                            </tr>
                            <tr>
                                <td>page.tsx</td>
                                <td>Unique UI for route</td>
                                <td>Yes (for routes)</td>
                            </tr>
                            <tr>
                                <td>loading.tsx</td>
                                <td>Loading UI while page loads</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>error.tsx</td>
                                <td>Error UI for route</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>not-found.tsx</td>
                                <td>404 UI</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>route.ts</td>
                                <td>API route handler</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>template.tsx</td>
                                <td>Re-rendered layout variant</td>
                                <td>No</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Basic App Router Setup</h4>
                            <div class="code-block">
<code>// app/layout.tsx (Root Layout)
import type { Metadata } from 'next';

export const metadata: Metadata = {
    title: 'My App',
    description: 'My Next.js application',
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        &lt;html lang="en"&gt;
            &lt;body&gt;
                &lt;header&gt;Navigation&lt;/header&gt;
                {children}
                &lt;footer&gt;Footer&lt;/footer&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    );
}

// app/page.tsx (Home Page)
export default function HomePage() {
    return (
        &lt;main&gt;
            &lt;h1&gt;Welcome to Next.js&lt;/h1&gt;
            &lt;p&gt;This is the home page&lt;/p&gt;
        &lt;/main&gt;
    );
}

// app/about/page.tsx
export default function AboutPage() {
    return (
        &lt;div&gt;
            &lt;h1&gt;About Us&lt;/h1&gt;
            &lt;p&gt;Learn more about our company&lt;/p&gt;
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                        
                        <div class="note-info">
                            <h4>‚ÑπÔ∏è Info</h4>
                            <p>The App Router uses React Server Components by default, which means components render on the server. This improves performance by reducing JavaScript sent to the client and enabling direct database access in components.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Server Components vs Client Components -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Server Components vs Client Components</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Server vs Client Components</h3>
                        <p>Understanding when to use Server Components vs Client Components is crucial for optimal performance.</p>
                        
                        <h4>Server Components (Default)</h4>
                        <div class="code-block">
<code>// Server Component (default)
// app/components/UserProfile.tsx
async function UserProfile({ userId }: { userId: number }) {
    // Direct database access
    const user = await db.user.findUnique({
        where: { id: userId }
    });
    
    // Can use server-only APIs
    const data = await fetch('https://api.example.com/data', {
        headers: {
            'Authorization': process.env.API_KEY
        }
    });
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
}

// Benefits:
// - No JavaScript sent to client
// - Direct database/API access
// - Access to server-only APIs
// - Better security (secrets stay on server)
// - Faster initial page load</code>
                        </div>
                        
                        <h4>Client Components</h4>
                        <div class="code-block">
<code>// Client Component (use "use client" directive)
// app/components/Counter.tsx
'use client';

import { useState } from 'react';

export function Counter() {
    const [count, setCount] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}

// When to use Client Components:
// - Interactive components (onClick, onChange, etc.)
// - Browser APIs (localStorage, window, etc.)
// - React hooks (useState, useEffect, etc.)
// - Event listeners
// - Third-party libraries that require client-side JavaScript</code>
                        </div>
                        
                        <h4>Comparison</h4>
                        <table>
                            <tr>
                                <th>Feature</th>
                                <th>Server Component</th>
                                <th>Client Component</th>
                            </tr>
                            <tr>
                                <td>Rendering</td>
                                <td>Server only</td>
                                <td>Client (browser)</td>
                            </tr>
                            <tr>
                                <td>JavaScript bundle</td>
                                <td>Not included</td>
                                <td>Included</td>
                            </tr>
                            <tr>
                                <td>Interactivity</td>
                                <td>No</td>
                                <td>Yes</td>
                            </tr>
                            <tr>
                                <td>Hooks</td>
                                <td>No</td>
                                <td>Yes</td>
                            </tr>
                            <tr>
                                <td>Browser APIs</td>
                                <td>No</td>
                                <td>Yes</td>
                            </tr>
                            <tr>
                                <td>Database access</td>
                                <td>Yes</td>
                                <td>No</td>
                            </tr>
                            <tr>
                                <td>Server APIs</td>
                                <td>Yes</td>
                                <td>No</td>
                            </tr>
                        </table>
                        
                        <h4>Mixing Server and Client Components</h4>
                        <div class="code-block">
<code>// Server Component can import Client Component
// app/page.tsx (Server Component)
import { Counter } from './components/Counter';

export default function HomePage() {
    // Server Component logic
    const data = await fetchData();
    
    return (
        &lt;div&gt;
            &lt;h1&gt;Server Component&lt;/h1&gt;
            &lt;p&gt;Data: {data}&lt;/p&gt;
            {/* Client Component */}
            &lt;Counter /&gt;
        &lt;/div&gt;
    );
}

// Client Component CANNOT import Server Component
// ‚ùå This won't work:
'use client';
import { ServerComponent } from './ServerComponent';  // Error!

// ‚úÖ But you can pass Server Components as children
'use client';
export function ClientWrapper({ children }: { children: React.ReactNode }) {
    const [state, setState] = useState(0);
    return &lt;div&gt;{children}&lt;/div&gt;;
}

// Usage
&lt;ClientWrapper&gt;
    &lt;ServerComponent /&gt;  {/* OK as children */}
&lt;/ClientWrapper&gt;</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Hybrid Component Pattern</h4>
                            <div class="code-block">
<code>// Server Component - fetches data
// app/components/ProductList.tsx
async function ProductList() {
    const products = await db.product.findMany();
    
    return (
        &lt;div&gt;
            {products.map(product => (
                &lt;ProductCard key={product.id} product={product} /&gt;
            ))}
        &lt;/div&gt;
    );
}

// Client Component - handles interaction
// app/components/ProductCard.tsx
'use client';

import { useState } from 'react';

interface Product {
    id: number;
    name: string;
    price: number;
}

export function ProductCard({ product }: { product: Product }) {
    const [quantity, setQuantity] = useState(1);
    
    return (
        &lt;div className="product-card"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
            &lt;div&gt;
                &lt;button onClick={() => setQuantity(q => q - 1)}&gt;-&lt;/button&gt;
                &lt;span&gt;{quantity}&lt;/span&gt;
                &lt;button onClick={() => setQuantity(q => q + 1)}&gt;+&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use Server Components by default. Only add "use client" when you need interactivity, hooks, or browser APIs. Keep the client boundary as low as possible in the component tree to minimize JavaScript sent to the client.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: File-based routing -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>File-based routing</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>File-Based Routing System</h3>
                        <p>Next.js App Router uses the file system to define routes. Each folder represents a route segment.</p>
                        
                        <h4>Route Segments</h4>
                        <div class="code-block">
<code>// Route structure
app/
  page.tsx                    ‚Üí /
  about/
    page.tsx                  ‚Üí /about
  products/
    page.tsx                  ‚Üí /products
    [id]/
      page.tsx                ‚Üí /products/[id]
  blog/
    page.tsx                  ‚Üí /blog
    [slug]/
      page.tsx                ‚Üí /blog/[slug]
  shop/
    [[...slug]]/
      page.tsx                ‚Üí /shop/* (catch-all)
  docs/
    [...slug]/
      page.tsx                ‚Üí /docs/* (optional catch-all)

// Route Groups (don't affect URL)
app/
  (marketing)/
    about/
      page.tsx                ‚Üí /about
    contact/
      page.tsx                ‚Üí /contact
  (dashboard)/
    settings/
      page.tsx                ‚Üí /settings
    profile/
      page.tsx                ‚Üí /profile</code>
                        </div>
                        
                        <h4>Dynamic Routes</h4>
                        <div class="code-block">
<code>// Single dynamic segment
// app/products/[id]/page.tsx
interface PageProps {
    params: {
        id: string;
    };
}

export default async function ProductPage({ params }: PageProps) {
    const product = await db.product.findUnique({
        where: { id: params.id }
    });
    
    return &lt;div&gt;{product.name}&lt;/div&gt;;
}

// Multiple dynamic segments
// app/shop/[category]/[product]/page.tsx
interface PageProps {
    params: {
        category: string;
        product: string;
    };
}

export default function ProductPage({ params }: PageProps) {
    return (
        &lt;div&gt;
            &lt;h1&gt;{params.category}&lt;/h1&gt;
            &lt;h2&gt;{params.product}&lt;/h2&gt;
        &lt;/div&gt;
    );
}

// Catch-all routes
// app/docs/[...slug]/page.tsx
interface PageProps {
    params: {
        slug: string[];
    };
}

export default function DocsPage({ params }: PageProps) {
    // /docs/a ‚Üí slug = ['a']
    // /docs/a/b ‚Üí slug = ['a', 'b']
    // /docs/a/b/c ‚Üí slug = ['a', 'b', 'c']
    
    return &lt;div&gt;Docs: {params.slug.join('/')}&lt;/div&gt;;
}

// Optional catch-all
// app/shop/[[...slug]]/page.tsx
// /shop ‚Üí slug = undefined
// /shop/electronics ‚Üí slug = ['electronics']
// /shop/electronics/phones ‚Üí slug = ['electronics', 'phones']</code>
                        </div>
                        
                        <h4>Route Handlers</h4>
                        <div class="code-block">
<code>// API Routes
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
    const users = await db.user.findMany();
    return NextResponse.json(users);
}

export async function POST(request: NextRequest) {
    const body = await request.json();
    const user = await db.user.create({ data: body });
    return NextResponse.json(user, { status: 201 });
}

// Dynamic route handlers
// app/api/users/[id]/route.ts
export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const user = await db.user.findUnique({
        where: { id: params.id }
    });
    
    if (!user) {
        return NextResponse.json(
            { error: 'User not found' },
            { status: 404 }
        );
    }
    
    return NextResponse.json(user);
}

export async function PUT(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const body = await request.json();
    const user = await db.user.update({
        where: { id: params.id },
        data: body
    });
    return NextResponse.json(user);
}

export async function DELETE(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    await db.user.delete({
        where: { id: params.id }
    });
    return NextResponse.json({ success: true });
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Blog with Categories</h4>
                            <div class="code-block">
<code>// app/blog/page.tsx - List all posts
export default async function BlogPage() {
    const posts = await db.post.findMany({
        orderBy: { createdAt: 'desc' }
    });
    
    return (
        &lt;div&gt;
            &lt;h1&gt;Blog&lt;/h1&gt;
            {posts.map(post => (
                &lt;Link key={post.id} href={`/blog/${post.slug}`}&gt;
                    {post.title}
                &lt;/Link&gt;
            ))}
        &lt;/div&gt;
    );
}

// app/blog/[slug]/page.tsx - Individual post
interface PageProps {
    params: { slug: string };
}

export default async function PostPage({ params }: PageProps) {
    const post = await db.post.findUnique({
        where: { slug: params.slug }
    });
    
    if (!post) {
        notFound();
    }
    
    return (
        &lt;article&gt;
            &lt;h1&gt;{post.title}&lt;/h1&gt;
            &lt;div dangerouslySetInnerHTML={{ __html: post.content }} /&gt;
        &lt;/article&gt;
    );
}

// app/blog/category/[category]/page.tsx - Posts by category
export default async function CategoryPage({ params }: PageProps) {
    const posts = await db.post.findMany({
        where: { category: params.category }
    });
    
    return (
        &lt;div&gt;
            &lt;h1&gt;{params.category} Posts&lt;/h1&gt;
            {posts.map(post => (
                &lt;PostCard key={post.id} post={post} /&gt;
            ))}
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Layout, metadata, dynamic routes -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Layout, metadata, dynamic routes</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Layouts</h3>
                        <p>Layouts are shared UI that wrap pages and persist across navigation.</p>
                        
                        <h4>Root Layout</h4>
                        <div class="code-block">
<code>// app/layout.tsx (Required)
import type { Metadata } from 'next';
import './globals.css';

export const metadata: Metadata = {
    title: 'My App',
    description: 'My Next.js application',
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        &lt;html lang="en"&gt;
            &lt;body&gt;
                {children}
            &lt;/body&gt;
        &lt;/html&gt;
    );
}

// Nested Layout
// app/dashboard/layout.tsx
export default function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        &lt;div className="dashboard"&gt;
            &lt;aside&gt;
                &lt;nav&gt;
                    &lt;Link href="/dashboard"&gt;Overview&lt;/Link&gt;
                    &lt;Link href="/dashboard/settings"&gt;Settings&lt;/Link&gt;
                &lt;/nav&gt;
            &lt;/aside&gt;
            &lt;main&gt;{children}&lt;/main&gt;
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>Metadata API</h4>
                        <div class="code-block">
<code>// Static metadata
// app/page.tsx
import type { Metadata } from 'next';

export const metadata: Metadata = {
    title: 'Home Page',
    description: 'Welcome to our website',
    keywords: ['next.js', 'react', 'web development'],
};

// Dynamic metadata
// app/products/[id]/page.tsx
export async function generateMetadata(
    { params }: { params: { id: string } }
): Promise&lt;Metadata&gt; {
    const product = await db.product.findUnique({
        where: { id: params.id }
    });
    
    return {
        title: product?.name || 'Product',
        description: product?.description || '',
        openGraph: {
            title: product?.name,
            description: product?.description,
            images: [product?.image || ''],
        },
    };
}

// Metadata with template
// app/layout.tsx
export const metadata: Metadata = {
    title: {
        template: '%s | My App',
        default: 'My App',
    },
};

// app/about/page.tsx
export const metadata: Metadata = {
    title: 'About',  // Results in "About | My App"
};</code>
                        </div>
                        
                        <h4>Dynamic Routes with generateStaticParams</h4>
                        <div class="code-block">
<code>// Static generation for dynamic routes
// app/products/[id]/page.tsx
export async function generateStaticParams() {
    const products = await db.product.findMany();
    
    return products.map((product) => ({
        id: product.id,
    }));
}

// This generates static pages at build time:
// /products/1
// /products/2
// /products/3
// etc.

// With multiple params
// app/shop/[category]/[product]/page.tsx
export async function generateStaticParams() {
    const products = await db.product.findMany();
    
    return products.map((product) => ({
        category: product.category,
        product: product.slug,
    }));
}

// Dynamic segments
// app/blog/[slug]/page.tsx
export async function generateStaticParams() {
    // Generate first 10 posts statically
    const posts = await db.post.findMany({ take: 10 });
    
    return posts.map((post) => ({
        slug: post.slug,
    }));
}

// Remaining posts will be generated on-demand</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Layout with Metadata</h4>
                            <div class="code-block">
<code>// app/layout.tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
    title: {
        template: '%s | My App',
        default: 'My App',
    },
    description: 'A Next.js application',
    metadataBase: new URL('https://example.com'),
    openGraph: {
        type: 'website',
        locale: 'en_US',
        url: 'https://example.com',
        siteName: 'My App',
    },
    twitter: {
        card: 'summary_large_image',
    },
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        &lt;html lang="en" className={inter.className}&gt;
            &lt;body&gt;
                &lt;header&gt;
                    &lt;nav&gt;
                        &lt;Link href="/"&gt;Home&lt;/Link&gt;
                        &lt;Link href="/about"&gt;About&lt;/Link&gt;
                    &lt;/nav&gt;
                &lt;/header&gt;
                {children}
                &lt;footer&gt;Footer&lt;/footer&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: SSR/SSG basics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>SSR/SSG basics</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Rendering Strategies</h3>
                        <p>Next.js App Router provides multiple rendering strategies for optimal performance.</p>
                        
                        <h4>Server-Side Rendering (SSR)</h4>
                        <div class="code-block">
<code>// By default, pages are Server Components (SSR)
// app/products/page.tsx
export default async function ProductsPage() {
    // This runs on the server for each request
    const products = await db.product.findMany();
    
    return (
        &lt;div&gt;
            {products.map(product => (
                &lt;ProductCard key={product.id} product={product} /&gt;
            ))}
        &lt;/div&gt;
    );
}

// Force dynamic rendering
export const dynamic = 'force-dynamic';

// Or use dynamic functions
export default async function Page() {
    // Using cookies() makes route dynamic
    const cookies = await import('next/headers').then(m => m.cookies());
    const theme = cookies.get('theme');
    
    return &lt;div&gt;Theme: {theme?.value}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>Static Site Generation (SSG)</h4>
                        <div class="code-block">
<code>// Static generation at build time
// app/about/page.tsx
export default function AboutPage() {
    // This page is statically generated at build time
    return &lt;div&gt;About Us&lt;/div&gt;;
}

// With generateStaticParams
// app/products/[id]/page.tsx
export async function generateStaticParams() {
    const products = await db.product.findMany();
    return products.map(p => ({ id: p.id }));
}

export default async function ProductPage({ params }: { params: { id: string } }) {
    const product = await db.product.findUnique({
        where: { id: params.id }
    });
    
    return &lt;div&gt;{product.name}&lt;/div&gt;;
}

// Force static generation
export const dynamic = 'force-static';

// Revalidate static pages (ISR)
export const revalidate = 3600; // Revalidate every hour

export default async function Page() {
    const data = await fetch('https://api.example.com/data', {
        next: { revalidate: 3600 } // Cache for 1 hour
    });
    
    return &lt;div&gt;{/* ... */}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>Incremental Static Regeneration (ISR)</h4>
                        <div class="code-block">
<code>// Revalidate at intervals
// app/blog/page.tsx
export const revalidate = 60; // Revalidate every 60 seconds

export default async function BlogPage() {
    const posts = await db.post.findMany();
    
    return (
        &lt;div&gt;
            {posts.map(post => (
                &lt;PostCard key={post.id} post={post} /&gt;
            ))}
        &lt;/div&gt;
    );
}

// On-demand revalidation
// app/api/revalidate/route.ts
import { revalidatePath } from 'next/cache';

export async function POST(request: Request) {
    const { path } = await request.json();
    revalidatePath(path);
    return Response.json({ revalidated: true });
}

// Usage: POST /api/revalidate with { "path": "/blog" }</code>
                        </div>
                        
                        <h4>Rendering Comparison</h4>
                        <table>
                            <tr>
                                <th>Strategy</th>
                                <th>When Rendered</th>
                                <th>Use Case</th>
                            </tr>
                            <tr>
                                <td>SSR</td>
                                <td>Every request</td>
                                <td>Dynamic content, user-specific data</td>
                            </tr>
                            <tr>
                                <td>SSG</td>
                                <td>Build time</td>
                                <td>Static content, blog posts</td>
                            </tr>
                            <tr>
                                <td>ISR</td>
                                <td>Build time + revalidation</td>
                                <td>Content that updates periodically</td>
                            </tr>
                        </table>
                        
                        <div class="example-box">
                            <h4>Example: Hybrid Rendering</h4>
                            <div class="code-block">
<code>// Static blog list with ISR
// app/blog/page.tsx
export const revalidate = 3600; // 1 hour

export default async function BlogPage() {
    const posts = await db.post.findMany({
        orderBy: { createdAt: 'desc' }
    });
    
    return (
        &lt;div&gt;
            {posts.map(post => (
                &lt;Link key={post.id} href={`/blog/${post.slug}`}&gt;
                    {post.title}
                &lt;/Link&gt;
            ))}
        &lt;/div&gt;
    );
}

// Dynamic individual post (SSR)
// app/blog/[slug]/page.tsx
export const dynamic = 'force-dynamic';

export default async function PostPage({ params }: { params: { slug: string } }) {
    const post = await db.post.findUnique({
        where: { slug: params.slug },
        include: { comments: true } // Always get latest comments
    });
    
    return (
        &lt;article&gt;
            &lt;h1&gt;{post.title}&lt;/h1&gt;
            &lt;div&gt;{post.content}&lt;/div&gt;
            &lt;CommentsSection comments={post.comments} /&gt;
        &lt;/article&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: API routes -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>API routes</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>API Routes in App Router</h3>
                        <p>API routes are defined using <code>route.ts</code> files and export HTTP method handlers.</p>
                        
                        <h4>Basic API Route</h4>
                        <div class="code-block">
<code>// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
    const users = await db.user.findMany();
    return NextResponse.json(users);
}

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        const user = await db.user.create({ data: body });
        return NextResponse.json(user, { status: 201 });
    } catch (error) {
        return NextResponse.json(
            { error: 'Failed to create user' },
            { status: 500 }
        );
    }
}

// Usage
// GET /api/users
// POST /api/users</code>
                        </div>
                        
                        <h4>Dynamic API Routes</h4>
                        <div class="code-block">
<code>// app/api/users/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const user = await db.user.findUnique({
        where: { id: params.id }
    });
    
    if (!user) {
        return NextResponse.json(
            { error: 'User not found' },
            { status: 404 }
        );
    }
    
    return NextResponse.json(user);
}

export async function PUT(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const body = await request.json();
    const user = await db.user.update({
        where: { id: params.id },
        data: body
    });
    return NextResponse.json(user);
}

export async function DELETE(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    await db.user.delete({
        where: { id: params.id }
    });
    return NextResponse.json({ success: true });
}</code>
                        </div>
                        
                        <h4>Request Handling</h4>
                        <div class="code-block">
<code>// Reading request data
export async function POST(request: NextRequest) {
    // JSON body
    const body = await request.json();
    
    // Form data
    const formData = await request.formData();
    const name = formData.get('name');
    
    // Query parameters
    const searchParams = request.nextUrl.searchParams;
    const page = searchParams.get('page');
    
    // Headers
    const authHeader = request.headers.get('authorization');
    
    // Cookies
    const token = request.cookies.get('token');
    
    return NextResponse.json({ success: true });
}

// Response helpers
export async function GET() {
    // JSON response
    return NextResponse.json({ data: 'value' });
    
    // Custom status
    return NextResponse.json({ error: 'Not found' }, { status: 404 });
    
    // Custom headers
    return NextResponse.json({ data: 'value' }, {
        headers: {
            'Custom-Header': 'value'
        }
    });
    
    // Redirect
    return NextResponse.redirect(new URL('/login', request.url));
    
    // Stream response
    const stream = new ReadableStream({
        // ... stream implementation
    });
    return new Response(stream);
}</code>
                        </div>
                        
                        <h4>Route Segment Config</h4>
                        <div class="code-block">
<code>// app/api/data/route.ts
export const dynamic = 'force-dynamic'; // or 'force-static'
export const revalidate = 3600; // For static routes
export const runtime = 'nodejs'; // or 'edge'
export const preferredRegion = 'us-east-1';

export async function GET() {
    return NextResponse.json({ data: 'value' });
}

// Edge Runtime
export const runtime = 'edge';

export async function GET(request: Request) {
    // Edge runtime has limited APIs
    return Response.json({ data: 'value' });
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete REST API</h4>
                            <div class="code-block">
<code>// app/api/posts/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '10');
    
    const posts = await db.post.findMany({
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' }
    });
    
    const total = await db.post.count();
    
    return NextResponse.json({
        posts,
        pagination: {
            page,
            limit,
            total,
            pages: Math.ceil(total / limit)
        }
    });
}

export async function POST(request: NextRequest) {
    try {
        const body = await request.json();
        
        // Validation
        if (!body.title || !body.content) {
            return NextResponse.json(
                { error: 'Title and content are required' },
                { status: 400 }
            );
        }
        
        const post = await db.post.create({
            data: {
                title: body.title,
                content: body.content,
                authorId: body.authorId
            }
        });
        
        return NextResponse.json(post, { status: 201 });
    } catch (error) {
        return NextResponse.json(
            { error: 'Failed to create post' },
            { status: 500 }
        );
    }
}

// app/api/posts/[id]/route.ts
export async function GET(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const post = await db.post.findUnique({
        where: { id: params.id },
        include: { author: true, comments: true }
    });
    
    if (!post) {
        return NextResponse.json(
            { error: 'Post not found' },
            { status: 404 }
        );
    }
    
    return NextResponse.json(post);
}

export async function PUT(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    const body = await request.json();
    
    const post = await db.post.update({
        where: { id: params.id },
        data: body
    });
    
    return NextResponse.json(post);
}

export async function DELETE(
    request: NextRequest,
    { params }: { params: { id: string } }
) {
    await db.post.delete({
        where: { id: params.id }
    });
    
    return NextResponse.json({ success: true });
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>API routes in the App Router are Server Components by default, meaning they run on the server. Use them for database operations, authentication, and server-side logic. Keep them simple and focused on a single responsibility.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 07: Advanced Next.js -->
        <div class="video-section" id="video-07">
            <div class="video-header">
                <span class="video-number">Video 07</span>
                <h2 class="video-title">Advanced Next.js (Performance + Server Actions)</h2>
            </div>
            
            <!-- Topic 1: Server Actions deep dive -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Server Actions deep dive</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Server Actions</h3>
                        <p>Server Actions are async functions that execute on the server. They can be called directly from Server Components, Client Components, or form actions.</p>
                        
                        <h4>Basic Server Action</h4>
                        <div class="code-block">
<code>// app/actions.ts (or in any Server Component file)
'use server';

export async function createUser(formData: FormData) {
    const name = formData.get('name') as string;
    const email = formData.get('email') as string;
    
    // Server-side validation
    if (!name || !email) {
        return { error: 'Name and email are required' };
    }
    
    // Database operation
    const user = await db.user.create({
        data: { name, email }
    });
    
    return { success: true, user };
}

// Usage in Server Component
// app/users/page.tsx
import { createUser } from './actions';

export default function UsersPage() {
    return (
        &lt;form action={createUser}&gt;
            &lt;input name="name" /&gt;
            &lt;input name="email" type="email" /&gt;
            &lt;button type="submit"&gt;Create User&lt;/button&gt;
        &lt;/form&gt;
    );
}

// Usage in Client Component
'use client';
import { createUser } from './actions';

export function UserForm() {
    const [pending, setPending] = useState(false);
    
    const handleSubmit = async (formData: FormData) => {
        setPending(true);
        const result = await createUser(formData);
        setPending(false);
        // Handle result
    };
    
    return (
        &lt;form action={handleSubmit}&gt;
            &lt;input name="name" /&gt;
            &lt;input name="email" type="email" /&gt;
            &lt;button type="submit" disabled={pending}&gt;
                {pending ? 'Creating...' : 'Create User'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code>
                        </div>
                        
                        <h4>Server Actions with TypeScript</h4>
                        <div class="code-block">
<code>// Typed Server Action
'use server';

interface CreateUserInput {
    name: string;
    email: string;
    age?: number;
}

interface ActionResult&lt;T&gt; {
    success: boolean;
    data?: T;
    error?: string;
}

export async function createUser(
    input: CreateUserInput
): Promise&lt;ActionResult&lt;User&gt;&gt; {
    try {
        // Validation
        if (!input.name || !input.email) {
            return {
                success: false,
                error: 'Name and email are required'
            };
        }
        
        // Check if user exists
        const existing = await db.user.findUnique({
            where: { email: input.email }
        });
        
        if (existing) {
            return {
                success: false,
                error: 'User with this email already exists'
            };
        }
        
        // Create user
        const user = await db.user.create({
            data: {
                name: input.name,
                email: input.email,
                age: input.age
            }
        });
        
        return {
            success: true,
            data: user
        };
    } catch (error) {
        return {
            success: false,
            error: 'Failed to create user'
        };
    }
}

// Usage
const result = await createUser({
    name: 'John',
    email: 'john@example.com',
    age: 30
});

if (result.success) {
    console.log('User created:', result.data);
} else {
    console.error('Error:', result.error);
}</code>
                        </div>
                        
                        <h4>Revalidation with Server Actions</h4>
                        <div class="code-block">
<code>'use server';

import { revalidatePath, revalidateTag } from 'next/cache';

export async function updatePost(id: string, data: PostData) {
    await db.post.update({
        where: { id },
        data
    });
    
    // Revalidate specific path
    revalidatePath('/posts');
    revalidatePath(`/posts/${id}`);
    
    // Or revalidate by tag
    revalidateTag('posts');
}

// Using cache tags
export async function getPosts() {
    const posts = await db.post.findMany({
        next: { tags: ['posts'] } // Tag the cache
    });
    return posts;
}</code>
                        </div>
                        
                        <h4>Progressive Enhancement</h4>
                        <div class="code-block">
<code>// Server Action works without JavaScript
'use server';

export async function submitForm(formData: FormData) {
    const name = formData.get('name') as string;
    // Process form...
    redirect('/success');
}

// Form works with or without JavaScript
export default function FormPage() {
    return (
        &lt;form action={submitForm}&gt;
            &lt;input name="name" required /&gt;
            &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;/form&gt;
    );
}

// Enhanced with JavaScript
'use client';
import { useActionState } from 'react';
import { submitForm } from './actions';

export function EnhancedForm() {
    const [state, formAction, isPending] = useActionState(submitForm, null);
    
    return (
        &lt;form action={formAction}&gt;
            &lt;input name="name" required /&gt;
            {state?.error && &lt;p className="error"&gt;{state.error}&lt;/p&gt;}
            &lt;button type="submit" disabled={isPending}&gt;
                {isPending ? 'Submitting...' : 'Submit'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete CRUD with Server Actions</h4>
                            <div class="code-block">
<code>// app/actions/posts.ts
'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

export async function createPost(formData: FormData) {
    const title = formData.get('title') as string;
    const content = formData.get('content') as string;
    
    if (!title || !content) {
        return { error: 'Title and content required' };
    }
    
    const post = await db.post.create({
        data: { title, content }
    });
    
    revalidatePath('/posts');
    redirect(`/posts/${post.id}`);
}

export async function updatePost(id: string, formData: FormData) {
    const title = formData.get('title') as string;
    const content = formData.get('content') as string;
    
    await db.post.update({
        where: { id },
        data: { title, content }
    });
    
    revalidatePath('/posts');
    revalidatePath(`/posts/${id}`);
}

export async function deletePost(id: string) {
    await db.post.delete({
        where: { id }
    });
    
    revalidatePath('/posts');
    redirect('/posts');
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Server Actions are secure by default - they run on the server and don't expose server code to the client. Always validate input on the server, even if you validate on the client. Use <code>revalidatePath</code> or <code>revalidateTag</code> to update cached data after mutations.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Streaming + Suspense -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Streaming + Suspense</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Streaming and Suspense</h3>
                        <p>Streaming allows you to progressively render UI as data becomes available, improving perceived performance.</p>
                        
                        <h4>React Suspense</h4>
                        <div class="code-block">
<code>// Basic Suspense
import { Suspense } from 'react';

export default function Page() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
                &lt;UserProfile /&gt;
            &lt;/Suspense&gt;
        &lt;/div&gt;
    );
}

// Multiple Suspense boundaries
export default function Dashboard() {
    return (
        &lt;div&gt;
            &lt;Suspense fallback={&lt;Skeleton /&gt;}&gt;
                &lt;UserStats /&gt;
            &lt;/Suspense&gt;
            &lt;Suspense fallback={&lt;Skeleton /&gt;}&gt;
                &lt;RecentActivity /&gt;
            &lt;/Suspense&gt;
            &lt;Suspense fallback={&lt;Skeleton /&gt;}&gt;
                &lt;Notifications /&gt;
            &lt;/Suspense&gt;
        &lt;/div&gt;
    );
}

// Async Server Component
async function UserProfile() {
    // This will suspend until data is ready
    const user = await fetchUser();
    return &lt;div&gt;{user.name}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>Loading States</h4>
                        <div class="code-block">
<code>// app/dashboard/loading.tsx
export default function Loading() {
    return (
        &lt;div className="loading"&gt;
            &lt;div className="skeleton"&gt;Loading dashboard...&lt;/div&gt;
        &lt;/div&gt;
    );
}

// app/dashboard/users/loading.tsx
export default function UsersLoading() {
    return (
        &lt;div&gt;
            {[1, 2, 3].map(i => (
                &lt;div key={i} className="skeleton-card"&gt;
                    &lt;div className="skeleton-avatar"&gt;&lt;/div&gt;
                    &lt;div className="skeleton-text"&gt;&lt;/div&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}

// Custom loading component
function Skeleton() {
    return (
        &lt;div className="animate-pulse"&gt;
            &lt;div className="h-4 bg-gray-200 rounded w-3/4"&gt;&lt;/div&gt;
            &lt;div className="h-4 bg-gray-200 rounded w-1/2 mt-2"&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>Streaming with Suspense</h4>
                        <div class="code-block">
<code>// Streaming multiple data sources
export default async function Dashboard() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            
            {/* Fast data - shows immediately */}
            &lt;QuickStats /&gt;
            
            {/* Slow data - streams in */}
            &lt;Suspense fallback={&lt;StatsSkeleton /&gt;}&gt;
                &lt;UserStats /&gt;
            &lt;/Suspense&gt;
            
            &lt;Suspense fallback={&lt;ActivitySkeleton /&gt;}&gt;
                &lt;RecentActivity /&gt;
            &lt;/Suspense&gt;
        &lt;/div&gt;
    );
}

// Parallel data fetching
async function UserStats() {
    const stats = await db.userStats.findMany();
    return &lt;StatsList stats={stats} /&gt;;
}

async function RecentActivity() {
    const activities = await db.activity.findMany({ take: 10 });
    return &lt;ActivityList activities={activities} /&gt;;
}

// These fetch in parallel and stream independently</code>
                        </div>
                        
                        <h4>Error Boundaries</h4>
                        <div class="code-block">
<code>// app/dashboard/error.tsx
'use client';

export default function Error({
    error,
    reset,
}: {
    error: Error & { digest?: string };
    reset: () => void;
}) {
    return (
        &lt;div className="error-boundary"&gt;
            &lt;h2&gt;Something went wrong!&lt;/h2&gt;
            &lt;p&gt;{error.message}&lt;/p&gt;
            &lt;button onClick={reset}&gt;Try again&lt;/button&gt;
        &lt;/div&gt;
    );
}

// Error in Suspense boundary
export default function Page() {
    return (
        &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
            &lt;ErrorBoundary&gt;
                &lt;UserProfile /&gt;
            &lt;/ErrorBoundary&gt;
        &lt;/Suspense&gt;
    );
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Streaming Dashboard</h4>
                            <div class="code-block">
<code>// app/dashboard/page.tsx
import { Suspense } from 'react';

export default function DashboardPage() {
    return (
        &lt;div className="dashboard"&gt;
            &lt;header&gt;
                &lt;h1&gt;Dashboard&lt;/h1&gt;
            &lt;/header&gt;
            
            &lt;div className="grid"&gt;
                {/* Critical - no suspense */}
                &lt;WelcomeMessage /&gt;
                
                {/* Can stream */}
                &lt;Suspense fallback={&lt;CardSkeleton /&gt;}&gt;
                    &lt;RevenueChart /&gt;
                &lt;/Suspense&gt;
                
                &lt;Suspense fallback={&lt;CardSkeleton /&gt;}&gt;
                    &lt;UserGrowth /&gt;
                &lt;/Suspense&gt;
                
                &lt;Suspense fallback={&lt;ListSkeleton /&gt;}&gt;
                    &lt;RecentOrders /&gt;
                &lt;/Suspense&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

async function RevenueChart() {
    // Simulate slow query
    await new Promise(resolve => setTimeout(resolve, 2000));
    const data = await db.revenue.findMany();
    return &lt;Chart data={data} /&gt;;
}

async function UserGrowth() {
    const growth = await db.userGrowth.findMany();
    return &lt;GrowthChart data={growth} /&gt;;
}

async function RecentOrders() {
    const orders = await db.order.findMany({ take: 10 });
    return &lt;OrderList orders={orders} /&gt;;
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Caching strategies -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Caching strategies</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Next.js Caching</h3>
                        <p>Next.js provides multiple caching layers to optimize performance and reduce server load.</p>
                        
                        <h4>Request Memoization</h4>
                        <div class="code-block">
<code>// Same request in same render = cached
async function getUsers() {
    const res = await fetch('https://api.example.com/users');
    return res.json();
}

export default async function Page() {
    const users1 = await getUsers(); // Request 1
    const users2 = await getUsers(); // Uses cached result
    // Both return same data, only one network request
}

// Cache duration
async function getData() {
    const res = await fetch('https://api.example.com/data', {
        next: { revalidate: 3600 } // Cache for 1 hour
    });
    return res.json();
}

// Force dynamic (no cache)
async function getData() {
    const res = await fetch('https://api.example.com/data', {
        cache: 'no-store' // Always fetch fresh
    });
    return res.json();
}</code>
                        </div>
                        
                        <h4>Data Cache</h4>
                        <div class="code-block">
<code>// fetch() caching
// Default: cached indefinitely
const data = await fetch('https://api.example.com/data');

// Revalidate after time
const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 } // Revalidate every hour
});

// Force revalidation
const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 0 } // Always revalidate
});

// No cache
const data = await fetch('https://api.example.com/data', {
    cache: 'no-store'
});

// Only cache if exists
const data = await fetch('https://api.example.com/data', {
    next: { revalidate: 3600 },
    cache: 'force-cache' // Use cache if available
});</code>
                        </div>
                        
                        <h4>Full Route Cache</h4>
                        <div class="code-block">
<code>// Static routes are cached by default
export default function AboutPage() {
    // This page is statically generated and cached
    return &lt;div&gt;About&lt;/div&gt;;
}

// Opt out of caching
export const dynamic = 'force-dynamic';

export default function DynamicPage() {
    // This page is rendered on every request
    return &lt;div&gt;Dynamic content&lt;/div&gt;;
}

// Segment config
export const revalidate = 3600; // Revalidate every hour
export const dynamic = 'force-static'; // Force static generation</code>
                        </div>
                        
                        <h4>Router Cache</h4>
                        <div class="code-block">
<code>// Client-side navigation cache
// Next.js caches route segments in memory
// - Static routes: cached indefinitely
// - Dynamic routes: cached for 30 seconds
// - Server-rendered: cached for 5 minutes

// Opt out
import { unstable_noStore as noStore } from 'next/cache';

export default async function Page() {
    noStore(); // Don't cache this route
    const data = await fetchData();
    return &lt;div&gt;{data}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>Cache Tags</h4>
                        <div class="code-block">
<code>// Tag-based revalidation
async function getPosts() {
    const posts = await fetch('https://api.example.com/posts', {
        next: { tags: ['posts'] }
    });
    return posts.json();
}

// Revalidate by tag
'use server';
import { revalidateTag } from 'next/cache';

export async function updatePost(id: string, data: PostData) {
    await db.post.update({ where: { id }, data });
    revalidateTag('posts'); // Revalidate all posts
}

// Multiple tags
async function getPost(id: string) {
    const post = await fetch(`https://api.example.com/posts/${id}`, {
        next: { tags: ['posts', `post-${id}`] }
    });
    return post.json();
}

// Revalidate specific post
revalidateTag(`post-${id}`);</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Optimized Caching Strategy</h4>
                            <div class="code-block">
<code>// app/posts/page.tsx
export const revalidate = 3600; // ISR: revalidate every hour

export default async function PostsPage() {
    // Cached for 1 hour, tagged for revalidation
    const posts = await fetch('https://api.example.com/posts', {
        next: {
            revalidate: 3600,
            tags: ['posts']
        }
    }).then(res => res.json());
    
    return (
        &lt;div&gt;
            {posts.map(post => (
                &lt;PostCard key={post.id} post={post} /&gt;
            ))}
        &lt;/div&gt;
    );
}

// app/posts/[id]/page.tsx
export async function generateStaticParams() {
    const posts = await fetch('https://api.example.com/posts').then(res => res.json());
    return posts.map((post: Post) => ({ id: post.id }));
}

export default async function PostPage({ params }: { params: { id: string } }) {
    // Individual post cached with tag
    const post = await fetch(`https://api.example.com/posts/${params.id}`, {
        next: {
            revalidate: 3600,
            tags: ['posts', `post-${params.id}`]
        }
    }).then(res => res.json());
    
    return &lt;article&gt;{post.content}&lt;/article&gt;;
}

// app/actions/posts.ts
'use server';
import { revalidateTag, revalidatePath } from 'next/cache';

export async function createPost(data: PostData) {
    const post = await db.post.create({ data });
    
    // Revalidate posts list
    revalidateTag('posts');
    revalidatePath('/posts');
    
    return post;
}

export async function updatePost(id: string, data: PostData) {
    await db.post.update({ where: { id }, data });
    
    // Revalidate specific post and list
    revalidateTag(`post-${id}`);
    revalidateTag('posts');
    revalidatePath(`/posts/${id}`);
    revalidatePath('/posts');
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use cache tags for granular revalidation. Cache static content aggressively, but use shorter revalidation times for dynamic content. Always revalidate cache after mutations to keep data fresh.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Image optimization -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Image optimization</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Next.js Image Component</h3>
                        <p>The <code>next/image</code> component automatically optimizes images for performance.</p>
                        
                        <h4>Basic Image Usage</h4>
                        <div class="code-block">
<code>import Image from 'next/image';

// Local image
import profilePic from './profile.jpg';

export default function Profile() {
    return (
        &lt;Image
            src={profilePic}
            alt="Profile picture"
            width={500}
            height={500}
        /&gt;
    );
}

// Remote image
export default function ProductCard({ product }: { product: Product }) {
    return (
        &lt;Image
            src={product.imageUrl}
            alt={product.name}
            width={300}
            height={300}
        /&gt;
    );
}

// With next.config.js
// next.config.js
module.exports = {
    images: {
        remotePatterns: [
            {
                protocol: 'https',
                hostname: 'example.com',
                pathname: '/images/**',
            },
        ],
    },
};</code>
                        </div>
                        
                        <h4>Image Optimization Features</h4>
                        <table>
                            <tr>
                                <th>Feature</th>
                                <th>Description</th>
                                <th>Benefit</th>
                            </tr>
                            <tr>
                                <td>Automatic Format</td>
                                <td>WebP/AVIF when supported</td>
                                <td>Smaller file sizes</td>
                            </tr>
                            <tr>
                                <td>Lazy Loading</td>
                                <td>Loads when in viewport</td>
                                <td>Faster initial load</td>
                            </tr>
                            <tr>
                                <td>Responsive Images</td>
                                <td>Multiple sizes generated</td>
                                <td>Right size for device</td>
                            </tr>
                            <tr>
                                <td>Blur Placeholder</td>
                                <td>Shows while loading</td>
                                <td>Better UX</td>
                            </tr>
                        </table>
                        
                        <h4>Advanced Image Options</h4>
                        <div class="code-block">
<code>import Image from 'next/image';

// Responsive image
&lt;Image
    src="/hero.jpg"
    alt="Hero"
    width={1200}
    height={600}
    sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
    style={{ width: '100%', height: 'auto' }}
/&gt;

// Priority loading (above fold)
&lt;Image
    src="/hero.jpg"
    alt="Hero"
    width={1200}
    height={600}
    priority
/&gt;

// Placeholder
&lt;Image
    src="/image.jpg"
    alt="Description"
    width={500}
    height={500}
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
/&gt;

// Quality control
&lt;Image
    src="/image.jpg"
    alt="Description"
    width={500}
    height={500}
    quality={90} // 1-100, default 75
/&gt;

// Fill container
&lt;div style={{ position: 'relative', width: '100%', height: '400px' }}&gt;
    &lt;Image
        src="/image.jpg"
        alt="Description"
        fill
        style={{ objectFit: 'cover' }}
    /&gt;
&lt;/div&gt;

// Loading states
&lt;Image
    src="/image.jpg"
    alt="Description"
    width={500}
    height={500}
    loading="lazy" // or "eager"
    onLoad={() => console.log('Loaded')}
    onError={() => console.log('Error')}
/&gt;</code>
                        </div>
                        
                        <h4>Image Optimization Configuration</h4>
                        <div class="code-block">
<code>// next.config.js
module.exports = {
    images: {
        // Remote image domains
        remotePatterns: [
            {
                protocol: 'https',
                hostname: '**.example.com',
            },
        ],
        
        // Image formats
        formats: ['image/avif', 'image/webp'],
        
        // Device sizes
        deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
        
        // Image sizes
        imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
        
        // Minimum cache TTL
        minimumCacheTTL: 60,
        
        // Disable optimization (not recommended)
        unoptimized: false,
    },
};

// Using external image service
module.exports = {
    images: {
        loader: 'custom',
        loaderFile: './lib/imageLoader.js',
    },
};

// lib/imageLoader.js
export default function imageLoader({ src, width, quality }) {
    return `https://example.com/api/image?src=${src}&w=${width}&q=${quality || 75}`;
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Optimized Image Gallery</h4>
                            <div class="code-block">
<code>// app/gallery/page.tsx
import Image from 'next/image';

interface GalleryImage {
    id: string;
    src: string;
    alt: string;
    width: number;
    height: number;
}

export default function Gallery({ images }: { images: GalleryImage[] }) {
    return (
        &lt;div className="grid grid-cols-3 gap-4"&gt;
            {images.map((image, index) => (
                &lt;div key={image.id} className="relative aspect-square"&gt;
                    &lt;Image
                        src={image.src}
                        alt={image.alt}
                        fill
                        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                        className="object-cover rounded-lg"
                        loading={index &lt; 6 ? "eager" : "lazy"}
                        placeholder="blur"
                        blurDataURL={image.blurDataURL}
                    /&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always use the Next.js Image component instead of regular &lt;img&gt; tags. Set <code>priority</code> for above-the-fold images. Use <code>fill</code> with responsive containers. Provide proper <code>sizes</code> attribute for responsive images.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Dynamic fetching -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Dynamic fetching</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Dynamic Data Fetching</h3>
                        <p>Next.js provides multiple ways to fetch data dynamically based on runtime conditions.</p>
                        
                        <h4>Dynamic Rendering</h4>
                        <div class="code-block">
<code>// Force dynamic rendering
export const dynamic = 'force-dynamic';

export default async function Page() {
    // This page is rendered on every request
    const data = await fetchData();
    return &lt;div&gt;{data}&lt;/div&gt;;
}

// Using dynamic functions
import { cookies } from 'next/headers';

export default async function Page() {
    // Using cookies() makes route dynamic
    const cookieStore = await cookies();
    const theme = cookieStore.get('theme');
    
    return &lt;div&gt;Theme: {theme?.value}&lt;/div&gt;;
}

// Other dynamic functions:
// - cookies()
// - headers()
// - searchParams (in page props)
// - params (dynamic segments)</code>
                        </div>
                        
                        <h4>Conditional Fetching</h4>
                        <div class="code-block">
<code>// Fetch based on conditions
export default async function Page({
    searchParams,
}: {
    searchParams: { filter?: string };
}) {
    let data;
    
    if (searchParams.filter) {
        // Dynamic fetch
        data = await fetch(`/api/data?filter=${searchParams.filter}`, {
            cache: 'no-store'
        }).then(res => res.json());
    } else {
        // Cached fetch
        data = await fetch('/api/data', {
            next: { revalidate: 3600 }
        }).then(res => res.json());
    }
    
    return &lt;div&gt;{/* Render data */}&lt;/div&gt;;
}

// User-specific data
import { auth } from '@/lib/auth';

export default async function Dashboard() {
    const session = await auth();
    
    if (!session) {
        redirect('/login');
    }
    
    // Fetch user-specific data
    const userData = await db.user.findUnique({
        where: { id: session.user.id }
    });
    
    return &lt;div&gt;Welcome, {userData.name}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>Parallel Data Fetching</h4>
                        <div class="code-block">
<code>// Fetch multiple data sources in parallel
export default async function Dashboard() {
    // These fetch in parallel
    const [users, posts, stats] = await Promise.all([
        db.user.findMany(),
        db.post.findMany(),
        db.stats.findMany()
    ]);
    
    return (
        &lt;div&gt;
            &lt;UserList users={users} /&gt;
            &lt;PostList posts={posts} /&gt;
            &lt;StatsList stats={stats} /&gt;
        &lt;/div&gt;
    );
}

// With Suspense for streaming
export default function Dashboard() {
    return (
        &lt;div&gt;
            &lt;Suspense fallback={&lt;UsersSkeleton /&gt;}&gt;
                &lt;Users /&gt;
            &lt;/Suspense&gt;
            &lt;Suspense fallback={&lt;PostsSkeleton /&gt;}&gt;
                &lt;Posts /&gt;
            &lt;/Suspense&gt;
        &lt;/div&gt;
    );
}

async function Users() {
    const users = await db.user.findMany();
    return &lt;UserList users={users} /&gt;;
}

async function Posts() {
    const posts = await db.post.findMany();
    return &lt;PostList posts={posts} /&gt;;
}</code>
                        </div>
                        
                        <h4>Sequential Data Fetching</h4>
                        <div class="code-block">
<code>// When data depends on previous fetch
export default async function UserPosts({ userId }: { userId: string }) {
    // First fetch
    const user = await db.user.findUnique({
        where: { id: userId }
    });
    
    if (!user) {
        notFound();
    }
    
    // Second fetch depends on first
    const posts = await db.post.findMany({
        where: { authorId: user.id }
    });
    
    return (
        &lt;div&gt;
            &lt;h1&gt;{user.name}'s Posts&lt;/h1&gt;
            &lt;PostList posts={posts} /&gt;
        &lt;/div&gt;
    );
}

// With error handling
export default async function Page() {
    try {
        const data = await fetchData();
        return &lt;div&gt;{data}&lt;/div&gt;;
    } catch (error) {
        // Handle error or redirect
        redirect('/error');
    }
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Search with Dynamic Fetching</h4>
                            <div class="code-block">
<code>// app/search/page.tsx
export default async function SearchPage({
    searchParams,
}: {
    searchParams: { q?: string; category?: string };
}) {
    // Dynamic based on search params
    const query = searchParams.q || '';
    const category = searchParams.category;
    
    let results;
    
    if (query) {
        // Dynamic fetch - no cache
        results = await db.product.findMany({
            where: {
                name: { contains: query },
                ...(category && { category })
            }
        });
    } else {
        // Static fetch - cached
        results = await db.product.findMany({
            take: 20,
            orderBy: { createdAt: 'desc' }
        });
    }
    
    return (
        &lt;div&gt;
            &lt;SearchForm /&gt;
            &lt;ProductGrid products={results} /&gt;
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Building a real dashboard app -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Building a real dashboard app</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Complete Dashboard Application</h3>
                        <p>Building a production-ready dashboard demonstrates all Next.js advanced features.</p>
                        
                        <h4>Project Structure</h4>
                        <div class="code-block">
<code>app/
  dashboard/
    layout.tsx          // Dashboard layout with sidebar
    page.tsx            // Dashboard overview
    loading.tsx         // Loading state
    error.tsx           // Error boundary
    analytics/
      page.tsx          // Analytics page
    settings/
      page.tsx          // Settings page
    users/
      page.tsx          // Users list
      [id]/
        page.tsx        // User detail
  api/
    dashboard/
      stats/
        route.ts        // API for stats
  components/
    dashboard/
      Sidebar.tsx
      StatsCard.tsx
      Chart.tsx
  lib/
    db.ts              // Database client
    auth.ts            // Authentication</code>
                        </div>
                        
                        <h4>Dashboard Layout</h4>
                        <div class="code-block">
<code>// app/dashboard/layout.tsx
import { Sidebar } from '@/components/dashboard/Sidebar';
import { auth } from '@/lib/auth';

export default async function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const session = await auth();
    
    if (!session) {
        redirect('/login');
    }
    
    return (
        &lt;div className="dashboard-layout"&gt;
            &lt;Sidebar user={session.user} /&gt;
            &lt;main className="dashboard-main"&gt;
                {children}
            &lt;/main&gt;
        &lt;/div&gt;
    );
}

// app/dashboard/loading.tsx
export default function DashboardLoading() {
    return (
        &lt;div className="dashboard-loading"&gt;
            &lt;div className="skeleton-header"&gt;&lt;/div&gt;
            &lt;div className="skeleton-grid"&gt;
                {[1, 2, 3, 4].map(i => (
                    &lt;div key={i} className="skeleton-card"&gt;&lt;/div&gt;
                ))}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>Dashboard Overview Page</h4>
                        <div class="code-block">
<code>// app/dashboard/page.tsx
import { Suspense } from 'react';
import { StatsCard } from '@/components/dashboard/StatsCard';
import { RevenueChart } from '@/components/dashboard/RevenueChart';
import { RecentActivity } from '@/components/dashboard/RecentActivity';

export default async function DashboardPage() {
    return (
        &lt;div className="dashboard"&gt;
            &lt;h1&gt;Dashboard Overview&lt;/h1&gt;
            
            {/* Stats - can stream */}
            &lt;Suspense fallback={&lt;StatsSkeleton /&gt;}&gt;
                &lt;StatsGrid /&gt;
            &lt;/Suspense&gt;
            
            &lt;div className="dashboard-grid"&gt;
                &lt;Suspense fallback={&lt;ChartSkeleton /&gt;}&gt;
                    &lt;RevenueChart /&gt;
                &lt;/Suspense&gt;
                
                &lt;Suspense fallback={&lt;ActivitySkeleton /&gt;}&gt;
                    &lt;RecentActivity /&gt;
                &lt;/Suspense&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// Components with data fetching
async function StatsGrid() {
    const stats = await db.stats.findMany();
    
    return (
        &lt;div className="stats-grid"&gt;
            {stats.map(stat => (
                &lt;StatsCard key={stat.id} stat={stat} /&gt;
            ))}
        &lt;/div&gt;
    );
}

async function RevenueChart() {
    const revenue = await db.revenue.findMany({
        orderBy: { date: 'asc' }
    });
    
    return &lt;Chart data={revenue} /&gt;;
}

async function RecentActivity() {
    const activities = await db.activity.findMany({
        take: 10,
        orderBy: { createdAt: 'desc' }
    });
    
    return &lt;ActivityList activities={activities} /&gt;;
}</code>
                        </div>
                        
                        <h4>Server Actions for Dashboard</h4>
                        <div class="code-block">
<code>// app/actions/dashboard.ts
'use server';

import { revalidatePath, revalidateTag } from 'next/cache';
import { auth } from '@/lib/auth';

export async function updateSettings(formData: FormData) {
    const session = await auth();
    if (!session) {
        return { error: 'Unauthorized' };
    }
    
    const theme = formData.get('theme') as string;
    const notifications = formData.get('notifications') === 'on';
    
    await db.user.update({
        where: { id: session.user.id },
        data: { theme, notifications }
    });
    
    revalidatePath('/dashboard/settings');
    return { success: true };
}

export async function deleteUser(userId: string) {
    const session = await auth();
    if (!session || session.user.role !== 'admin') {
        return { error: 'Unauthorized' };
    }
    
    await db.user.delete({
        where: { id: userId }
    });
    
    revalidateTag('users');
    revalidatePath('/dashboard/users');
    return { success: true };
}</code>
                        </div>
                        
                        <h4>API Routes for Dashboard</h4>
                        <div class="code-block">
<code>// app/api/dashboard/stats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';

export async function GET(request: NextRequest) {
    const session = await auth();
    
    if (!session) {
        return NextResponse.json(
            { error: 'Unauthorized' },
            { status: 401 }
        );
    }
    
    // Get stats based on user role
    const stats = await db.stats.findMany({
        where: session.user.role === 'admin' 
            ? {} 
            : { userId: session.user.id }
    });
    
    return NextResponse.json(stats, {
        headers: {
            'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300'
        }
    });
}

// Real-time data endpoint
export const dynamic = 'force-dynamic';
export const revalidate = 0;

export async function GET() {
    const liveStats = await getLiveStats();
    return NextResponse.json(liveStats);
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Dashboard Features</h4>
                            <div class="code-block">
<code>// Features implemented:
// 1. Authentication & Authorization
// 2. Server Components for data fetching
// 3. Client Components for interactivity
// 4. Server Actions for mutations
// 5. Streaming with Suspense
// 6. Optimized images
// 7. Caching strategies
// 8. Error boundaries
// 9. Loading states
// 10. Responsive design

// app/dashboard/page.tsx (Complete)
import { Suspense } from 'react';
import Image from 'next/image';
import { StatsCard } from '@/components/dashboard/StatsCard';
import { RevenueChart } from '@/components/dashboard/RevenueChart';
import { RecentActivity } from '@/components/dashboard/RecentActivity';
import { QuickActions } from '@/components/dashboard/QuickActions';

export default async function DashboardPage() {
    return (
        &lt;div className="dashboard"&gt;
            &lt;header&gt;
                &lt;h1&gt;Dashboard&lt;/h1&gt;
                &lt;QuickActions /&gt;
            &lt;/header&gt;
            
            &lt;Suspense fallback={&lt;StatsSkeleton /&gt;}&gt;
                &lt;StatsGrid /&gt;
            &lt;/Suspense&gt;
            
            &lt;div className="dashboard-content"&gt;
                &lt;Suspense fallback={&lt;ChartSkeleton /&gt;}&gt;
                    &lt;RevenueChart /&gt;
                &lt;/Suspense&gt;
                
                &lt;Suspense fallback={&lt;ActivitySkeleton /&gt;}&gt;
                    &lt;RecentActivity /&gt;
                &lt;/Suspense&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>For dashboard applications, use Server Components for data fetching, Client Components for interactive elements, and Server Actions for mutations. Implement proper loading states, error boundaries, and caching strategies for optimal performance and user experience.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 08: Tailwind CSS Advanced + UI System Design -->
        <div class="video-section" id="video-08">
            <div class="video-header">
                <span class="video-number">Video 08</span>
                <h2 class="video-title">Tailwind CSS Advance + UI System Design</h2>
            </div>
            
            <!-- Topic 1: Design system architecture -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Design system architecture</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Design System Fundamentals</h3>
                        <p>A design system is a collection of reusable components, guided by clear standards, that can be assembled to build applications.</p>
                        
                        <h4>Design System Layers</h4>
                        <table>
                            <tr>
                                <th>Layer</th>
                                <th>Purpose</th>
                                <th>Examples</th>
                            </tr>
                            <tr>
                                <td>Tokens</td>
                                <td>Design values (colors, spacing, typography)</td>
                                <td>Colors, spacing scale, font sizes</td>
                            </tr>
                            <tr>
                                <td>Components</td>
                                <td>Reusable UI elements</td>
                                <td>Button, Input, Card, Modal</td>
                            </tr>
                            <tr>
                                <td>Patterns</td>
                                <td>Component combinations</td>
                                <td>Form layouts, Navigation, Dashboards</td>
                            </tr>
                            <tr>
                                <td>Pages</td>
                                <td>Complete page layouts</td>
                                <td>Homepage, Dashboard, Settings</td>
                            </tr>
                        </table>
                        
                        <h4>Design Tokens in Tailwind</h4>
                        <div class="code-block">
<code>// tailwind.config.js
module.exports = {
    theme: {
        extend: {
            // Color tokens
            colors: {
                primary: {
                    50: '#eff6ff',
                    100: '#dbeafe',
                    200: '#bfdbfe',
                    300: '#93c5fd',
                    400: '#60a5fa',
                    500: '#3b82f6', // Base
                    600: '#2563eb',
                    700: '#1d4ed8',
                    800: '#1e40af',
                    900: '#1e3a8a',
                },
                semantic: {
                    success: '#10b981',
                    warning: '#f59e0b',
                    error: '#ef4444',
                    info: '#3b82f6',
                }
            },
            
            // Spacing tokens
            spacing: {
                'xs': '0.5rem',
                'sm': '1rem',
                'md': '1.5rem',
                'lg': '2rem',
                'xl': '3rem',
                '2xl': '4rem',
            },
            
            // Typography tokens
            fontSize: {
                'xs': ['0.75rem', { lineHeight: '1rem' }],
                'sm': ['0.875rem', { lineHeight: '1.25rem' }],
                'base': ['1rem', { lineHeight: '1.5rem' }],
                'lg': ['1.125rem', { lineHeight: '1.75rem' }],
                'xl': ['1.25rem', { lineHeight: '1.75rem' }],
                '2xl': ['1.5rem', { lineHeight: '2rem' }],
                '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
                '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
            },
            
            // Border radius tokens
            borderRadius: {
                'none': '0',
                'sm': '0.125rem',
                'base': '0.25rem',
                'md': '0.375rem',
                'lg': '0.5rem',
                'xl': '0.75rem',
                'full': '9999px',
            },
        }
    }
}</code>
                        </div>
                        
                        <h4>Component Architecture</h4>
                        <div class="code-block">
<code>// Component structure
components/
  ui/                    // Base components
    Button.tsx
    Input.tsx
    Card.tsx
  layout/                // Layout components
    Container.tsx
    Grid.tsx
    Stack.tsx
  forms/                 // Form components
    FormField.tsx
    FormSelect.tsx
  feedback/              // Feedback components
    Alert.tsx
    Toast.tsx
    Spinner.tsx
  navigation/            // Navigation components
    Navbar.tsx
    Sidebar.tsx
    Breadcrumbs.tsx

// Base component example
// components/ui/Button.tsx
interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
    variant?: 'primary' | 'secondary' | 'danger';
    size?: 'sm' | 'md' | 'lg';
    isLoading?: boolean;
}

export const Button = ({
    variant = 'primary',
    size = 'md',
    isLoading = false,
    children,
    className,
    disabled,
    ...props
}: ButtonProps) => {
    const baseStyles = 'font-medium rounded-lg transition-colors focus:outline-none focus:ring-2';
    
    const variants = {
        primary: 'bg-primary-500 text-white hover:bg-primary-600 focus:ring-primary-500',
        secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',
        danger: 'bg-error text-white hover:bg-red-600 focus:ring-error',
    };
    
    const sizes = {
        sm: 'px-3 py-1.5 text-sm',
        md: 'px-4 py-2 text-base',
        lg: 'px-6 py-3 text-lg',
    };
    
    return (
        &lt;button
            className={`${baseStyles} ${variants[variant]} ${sizes[size]} ${className || ''}`}
            disabled={disabled || isLoading}
            {...props}
        &gt;
            {isLoading ? (
                &lt;&gt;
                    &lt;svg className="animate-spin -ml-1 mr-2 h-4 w-4"&gt;...&lt;/svg&gt;
                    Loading...
                &lt;/&gt;
            ) : (
                children
            )}
        &lt;/button&gt;
    );
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Design System Structure</h4>
                            <div class="code-block">
<code>// Design system organization
design-system/
  tokens/
    colors.ts
    spacing.ts
    typography.ts
    shadows.ts
  components/
    primitives/        // Basic building blocks
      Box.tsx
      Flex.tsx
      Stack.tsx
    composite/         // Complex components
      Card.tsx
      Modal.tsx
      Dropdown.tsx
  utilities/
    cn.ts             // className utility
    variants.ts       // Variant system

// tokens/colors.ts
export const colors = {
    primary: {
        50: '#eff6ff',
        500: '#3b82f6',
        900: '#1e3a8a',
    },
    // ... more colors
};

// tailwind.config.js uses these tokens
const colors = require('./design-system/tokens/colors');

module.exports = {
    theme: {
        extend: {
            colors: colors
        }
    }
};</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Start with design tokens (colors, spacing, typography) before building components. This ensures consistency across your design system. Use semantic naming (primary, secondary) rather than visual naming (blue, red) for better maintainability.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Component library patterns -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Component library patterns</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Component Patterns</h3>
                        <p>Common patterns for building reusable, maintainable component libraries.</p>
                        
                        <h4>Compound Components</h4>
                        <div class="code-block">
<code>// Compound component pattern
// components/ui/Card.tsx
import { createContext, useContext } from 'react';

interface CardContextType {
    variant?: 'default' | 'outlined' | 'elevated';
}

const CardContext = createContext&lt;CardContextType&gt;({});

const useCardContext = () => {
    const context = useContext(CardContext);
    if (!context) {
        throw new Error('Card components must be used within Card');
    }
    return context;
};

interface CardProps {
    variant?: 'default' | 'outlined' | 'elevated';
    children: React.ReactNode;
    className?: string;
}

export const Card = ({ variant = 'default', children, className }: CardProps) => {
    const baseStyles = 'rounded-lg';
    const variants = {
        default: 'bg-white border border-gray-200',
        outlined: 'border-2 border-gray-300',
        elevated: 'bg-white shadow-lg',
    };
    
    return (
        &lt;CardContext.Provider value={{ variant }}&gt;
            &lt;div className={`${baseStyles} ${variants[variant]} ${className || ''}`}&gt;
                {children}
            &lt;/div&gt;
        &lt;/CardContext.Provider&gt;
    );
};

Card.Header = ({ children, className }: { children: React.ReactNode; className?: string }) => {
    return &lt;div className={`p-4 border-b border-gray-200 ${className || ''}`}&gt;{children}&lt;/div&gt;;
};

Card.Body = ({ children, className }: { children: React.ReactNode; className?: string }) => {
    return &lt;div className={`p-4 ${className || ''}`}&gt;{children}&lt;/div&gt;;
};

Card.Footer = ({ children, className }: { children: React.ReactNode; className?: string }) => {
    return &lt;div className={`p-4 border-t border-gray-200 ${className || ''}`}&gt;{children}&lt;/div&gt;;
};

// Usage
&lt;Card variant="elevated"&gt;
    &lt;Card.Header&gt;
        &lt;h3&gt;Card Title&lt;/h3&gt;
    &lt;/Card.Header&gt;
    &lt;Card.Body&gt;
        &lt;p&gt;Card content&lt;/p&gt;
    &lt;/Card.Body&gt;
    &lt;Card.Footer&gt;
        &lt;Button&gt;Action&lt;/Button&gt;
    &lt;/Card.Footer&gt;
&lt;/Card&gt;</code>
                        </div>
                        
                        <h4>Render Props Pattern</h4>
                        <div class="code-block">
<code>// Render props for flexible components
interface ToggleProps {
    children: (props: {
        isOn: boolean;
        toggle: () => void;
        setIsOn: (value: boolean) => void;
    }) => React.ReactNode;
    defaultOn?: boolean;
}

export const Toggle = ({ children, defaultOn = false }: ToggleProps) => {
    const [isOn, setIsOn] = useState(defaultOn);
    
    const toggle = () => setIsOn(prev => !prev);
    
    return &lt;&gt;{children({ isOn, toggle, setIsOn })}&lt;/&gt;;
};

// Usage
&lt;Toggle&gt;
    {({ isOn, toggle }) => (
        &lt;div&gt;
            &lt;button onClick={toggle}&gt;
                {isOn ? 'ON' : 'OFF'}
            &lt;/button&gt;
        &lt;/div&gt;
    )}
&lt;/Toggle&gt;</code>
                        </div>
                        
                        <h4>Polymorphic Components</h4>
                        <div class="code-block">
<code>// Component that can render as different elements
type PolymorphicProps&lt;T extends React.ElementType&gt; = {
    as?: T;
    children: React.ReactNode;
} & React.ComponentPropsWithoutRef&lt;T&gt;;

export function Box&lt;T extends React.ElementType = 'div'&gt;({
    as,
    children,
    className,
    ...props
}: PolymorphicProps&lt;T&gt;) {
    const Component = as || 'div';
    
    return (
        &lt;Component className={className} {...props}&gt;
            {children}
        &lt;/Component&gt;
    );
}

// Usage
&lt;Box as="section" className="p-4"&gt;Content&lt;/Box&gt;
&lt;Box as="article" className="p-4"&gt;Article&lt;/Box&gt;
&lt;Box as="button" onClick={handleClick}&gt;Button&lt;/Box&gt;</code>
                        </div>
                        
                        <h4>Variant System with class-variance-authority</h4>
                        <div class="code-block">
<code>// Using class-variance-authority for variants
import { cva, type VariantProps } from 'class-variance-authority';

const buttonVariants = cva(
    // Base styles
    'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none',
    {
        variants: {
            variant: {
                default: 'bg-primary-500 text-white hover:bg-primary-600',
                destructive: 'bg-error text-white hover:bg-red-600',
                outline: 'border border-gray-300 bg-transparent hover:bg-gray-100',
                ghost: 'hover:bg-gray-100',
                link: 'text-primary-500 underline-offset-4 hover:underline',
            },
            size: {
                default: 'h-10 py-2 px-4',
                sm: 'h-9 px-3 rounded-md',
                lg: 'h-11 px-8 rounded-md',
                icon: 'h-10 w-10',
            },
        },
        defaultVariants: {
            variant: 'default',
            size: 'default',
        },
    }
);

interface ButtonProps
    extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt;,
        VariantProps&lt;typeof buttonVariants&gt; {
    asChild?: boolean;
}

export const Button = ({ className, variant, size, ...props }: ButtonProps) => {
    return (
        &lt;button
            className={buttonVariants({ variant, size, className })}
            {...props}
        /&gt;
    );
};</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Input Component</h4>
                            <div class="code-block">
<code>// components/ui/Input.tsx
import { forwardRef } from 'react';
import { cva, type VariantProps } from 'class-variance-authority';

const inputVariants = cva(
    'w-full rounded-md border transition-colors focus:outline-none focus:ring-2',
    {
        variants: {
            variant: {
                default: 'border-gray-300 focus:border-primary-500 focus:ring-primary-500',
                error: 'border-error focus:border-error focus:ring-error',
                success: 'border-success focus:border-success focus:ring-success',
            },
            size: {
                sm: 'px-3 py-1.5 text-sm',
                md: 'px-4 py-2 text-base',
                lg: 'px-5 py-3 text-lg',
            },
        },
        defaultVariants: {
            variant: 'default',
            size: 'md',
        },
    }
);

interface InputProps
    extends React.InputHTMLAttributes&lt;HTMLInputElement&gt;,
        VariantProps&lt;typeof inputVariants&gt; {
    label?: string;
    error?: string;
    helperText?: string;
}

export const Input = forwardRef&lt;HTMLInputElement, InputProps&gt;(
    ({ className, variant, size, label, error, helperText, ...props }, ref) => {
        return (
            &lt;div className="w-full"&gt;
                {label && (
                    &lt;label className="block text-sm font-medium text-gray-700 mb-1"&gt;
                        {label}
                    &lt;/label&gt;
                )}
                &lt;input
                    ref={ref}
                    className={inputVariants({
                        variant: error ? 'error' : variant,
                        size,
                        className,
                    })}
                    {...props}
                /&gt;
                {error && (
                    &lt;p className="mt-1 text-sm text-error"&gt;{error}&lt;/p&gt;
                )}
                {helperText && !error && (
                    &lt;p className="mt-1 text-sm text-gray-500"&gt;{helperText}&lt;/p&gt;
                )}
            &lt;/div&gt;
        );
    }
);

Input.displayName = 'Input';</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Custom themes + dark mode -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Custom themes + dark mode</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Theme Configuration</h3>
                        <p>Creating custom themes and implementing dark mode in Tailwind CSS.</p>
                        
                        <h4>Custom Theme Setup</h4>
                        <div class="code-block">
<code>// tailwind.config.js
module.exports = {
    darkMode: 'class', // or 'media'
    theme: {
        extend: {
            colors: {
                // Custom color palette
                brand: {
                    light: '#3b82f6',
                    DEFAULT: '#2563eb',
                    dark: '#1e40af',
                },
            },
            fontFamily: {
                sans: ['Inter', 'system-ui', 'sans-serif'],
                mono: ['Fira Code', 'monospace'],
            },
        },
    },
};

// Using custom theme
&lt;div className="bg-brand text-white"&gt;
    Brand colored div
&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Dark Mode Implementation</h4>
                        <div class="code-block">
<code>// tailwind.config.js
module.exports = {
    darkMode: 'class', // Enable class-based dark mode
    // ...
};

// Toggle dark mode
'use client';
import { useEffect, useState } from 'react';

export function ThemeToggle() {
    const [darkMode, setDarkMode] = useState(false);
    
    useEffect(() => {
        // Check system preference
        const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setDarkMode(isDark);
        if (isDark) {
            document.documentElement.classList.add('dark');
        }
    }, []);
    
    const toggleTheme = () => {
        const newMode = !darkMode;
        setDarkMode(newMode);
        if (newMode) {
            document.documentElement.classList.add('dark');
            localStorage.setItem('theme', 'dark');
        } else {
            document.documentElement.classList.remove('dark');
            localStorage.setItem('theme', 'light');
        }
    };
    
    return (
        &lt;button onClick={toggleTheme}&gt;
            {darkMode ? '‚òÄÔ∏è' : 'üåô'}
        &lt;/button&gt;
    );
}

// Custom hook for theme
export function useTheme() {
    const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');
    
    useEffect(() => {
        const stored = localStorage.getItem('theme') as 'light' | 'dark' | null;
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const initialTheme = stored || (prefersDark ? 'dark' : 'light');
        
        setTheme(initialTheme);
        if (initialTheme === 'dark') {
            document.documentElement.classList.add('dark');
        }
    }, []);
    
    const toggleTheme = () => {
        const newTheme = theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
        
        if (newTheme === 'dark') {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    };
    
    return { theme, toggleTheme };
}</code>
                        </div>
                        
                        <h4>Dark Mode Colors</h4>
                        <div class="code-block">
<code>// tailwind.config.js
module.exports = {
    darkMode: 'class',
    theme: {
        extend: {
            colors: {
                background: {
                    DEFAULT: '#ffffff',
                    dark: '#0f172a',
                },
                foreground: {
                    DEFAULT: '#0f172a',
                    dark: '#f8fafc',
                },
                card: {
                    DEFAULT: '#ffffff',
                    dark: '#1e293b',
                },
                border: {
                    DEFAULT: '#e2e8f0',
                    dark: '#334155',
                },
            },
        },
    },
};

// Usage with dark mode
&lt;div className="bg-background dark:bg-background-dark text-foreground dark:text-foreground-dark"&gt;
    Content that adapts to theme
&lt;/div&gt;

// Component with dark mode
export function Card({ children }: { children: React.ReactNode }) {
    return (
        &lt;div className="bg-card dark:bg-card-dark border border-border dark:border-border-dark rounded-lg p-4"&gt;
            {children}
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>Theme Provider</h4>
                        <div class="code-block">
<code>// components/ThemeProvider.tsx
'use client';

import { createContext, useContext, useEffect, useState } from 'react';

type Theme = 'light' | 'dark' | 'system';

interface ThemeContextType {
    theme: Theme;
    setTheme: (theme: Theme) => void;
    resolvedTheme: 'light' | 'dark';
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

export function ThemeProvider({ children }: { children: React.ReactNode }) {
    const [theme, setTheme] = useState&lt;Theme&gt;('system');
    const [resolvedTheme, setResolvedTheme] = useState&lt;'light' | 'dark'&gt;('light');
    
    useEffect(() => {
        const stored = localStorage.getItem('theme') as Theme | null;
        if (stored) {
            setTheme(stored);
        }
    }, []);
    
    useEffect(() => {
        const root = document.documentElement;
        
        if (theme === 'system') {
            const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches
                ? 'dark'
                : 'light';
            setResolvedTheme(systemTheme);
            root.classList.toggle('dark', systemTheme === 'dark');
        } else {
            setResolvedTheme(theme);
            root.classList.toggle('dark', theme === 'dark');
        }
    }, [theme]);
    
    useEffect(() => {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        const handleChange = () => {
            if (theme === 'system') {
                setResolvedTheme(mediaQuery.matches ? 'dark' : 'light');
                document.documentElement.classList.toggle('dark', mediaQuery.matches);
            }
        };
        
        mediaQuery.addEventListener('change', handleChange);
        return () => mediaQuery.removeEventListener('change', handleChange);
    }, [theme]);
    
    return (
        &lt;ThemeContext.Provider value={{ theme, setTheme, resolvedTheme }}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
}

export function useTheme() {
    const context = useContext(ThemeContext);
    if (!context) {
        throw new Error('useTheme must be used within ThemeProvider');
    }
    return context;
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Theme-Aware Component</h4>
                            <div class="code-block">
<code>// components/ui/ThemedCard.tsx
export function ThemedCard({ children }: { children: React.ReactNode }) {
    return (
        &lt;div className="
            bg-white dark:bg-gray-800
            text-gray-900 dark:text-gray-100
            border border-gray-200 dark:border-gray-700
            rounded-lg p-6
            shadow-sm dark:shadow-gray-900/50
            transition-colors duration-200
        "&gt;
            {children}
        &lt;/div&gt;
    );
}

// Usage
&lt;ThemedCard&gt;
    &lt;h2&gt;Card Title&lt;/h2&gt;
    &lt;p&gt;Card content that adapts to theme&lt;/p&gt;
&lt;/ThemedCard&gt;</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Tailwind animations / transitions -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Tailwind animations / transitions</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Animations and Transitions</h3>
                        <p>Creating smooth animations and transitions with Tailwind CSS.</p>
                        
                        <h4>Built-in Animations</h4>
                        <div class="code-block">
<code>// Built-in utility classes
&lt;div className="animate-spin"&gt;Spinning&lt;/div&gt;
&lt;div className="animate-pulse"&gt;Pulsing&lt;/div&gt;
&lt;div className="animate-bounce"&gt;Bouncing&lt;/div&gt;
&lt;div className="animate-ping"&gt;Pinging&lt;/div&gt;

// Transitions
&lt;button className="
    bg-blue-500 
    hover:bg-blue-600 
    transition-colors 
    duration-200
"&gt;
    Hover me
&lt;/button&gt;

// Multiple transitions
&lt;div className="
    transition-all 
    duration-300 
    ease-in-out
    hover:scale-105 
    hover:shadow-lg
"&gt;
    Hover effect
&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Custom Animations</h4>
                        <div class="code-block">
<code>// tailwind.config.js
module.exports = {
    theme: {
        extend: {
            keyframes: {
                fadeIn: {
                    '0%': { opacity: '0', transform: 'translateY(10px)' },
                    '100%': { opacity: '1', transform: 'translateY(0)' },
                },
                slideIn: {
                    '0%': { transform: 'translateX(-100%)' },
                    '100%': { transform: 'translateX(0)' },
                },
                shimmer: {
                    '0%': { backgroundPosition: '-1000px 0' },
                    '100%': { backgroundPosition: '1000px 0' },
                },
            },
            animation: {
                fadeIn: 'fadeIn 0.5s ease-in-out',
                slideIn: 'slideIn 0.3s ease-out',
                shimmer: 'shimmer 2s infinite linear',
            },
        },
    },
};

// Usage
&lt;div className="animate-fadeIn"&gt;Fades in&lt;/div&gt;
&lt;div className="animate-slideIn"&gt;Slides in&lt;/div&gt;
&lt;div className="animate-shimmer"&gt;Shimmer effect&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Transition Utilities</h4>
                        <div class="code-block">
<code>// Transition properties
&lt;div className="transition-colors"&gt;Color transitions&lt;/div&gt;
&lt;div className="transition-opacity"&gt;Opacity transitions&lt;/div&gt;
&lt;div className="transition-transform"&gt;Transform transitions&lt;/div&gt;
&lt;div className="transition-all"&gt;All properties&lt;/div&gt;

// Duration
&lt;div className="transition-all duration-75"&gt;75ms&lt;/div&gt;
&lt;div className="transition-all duration-100"&gt;100ms&lt;/div&gt;
&lt;div className="transition-all duration-150"&gt;150ms&lt;/div&gt;
&lt;div className="transition-all duration-200"&gt;200ms&lt;/div&gt;
&lt;div className="transition-all duration-300"&gt;300ms&lt;/div&gt;
&lt;div className="transition-all duration-500"&gt;500ms&lt;/div&gt;
&lt;div className="transition-all duration-700"&gt;700ms&lt;/div&gt;
&lt;div className="transition-all duration-1000"&gt;1000ms&lt;/div&gt;

// Timing functions
&lt;div className="transition-all ease-linear"&gt;Linear&lt;/div&gt;
&lt;div className="transition-all ease-in"&gt;Ease in&lt;/div&gt;
&lt;div className="transition-all ease-out"&gt;Ease out&lt;/div&gt;
&lt;div className="transition-all ease-in-out"&gt;Ease in-out&lt;/div&gt;

// Delay
&lt;div className="transition-all delay-75"&gt;75ms delay&lt;/div&gt;
&lt;div className="transition-all delay-150"&gt;150ms delay&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Transform Utilities</h4>
                        <div class="code-block">
<code>// Scale
&lt;div className="hover:scale-105"&gt;Grows on hover&lt;/div&gt;
&lt;div className="hover:scale-110"&gt;Grows more&lt;/div&gt;
&lt;div className="active:scale-95"&gt;Shrinks on click&lt;/div&gt;

// Rotate
&lt;div className="hover:rotate-12"&gt;Rotates on hover&lt;/div&gt;
&lt;div className="animate-spin"&gt;Continuous rotation&lt;/div&gt;

// Translate
&lt;div className="hover:translate-x-2"&gt;Moves right&lt;/div&gt;
&lt;div className="hover:-translate-y-2"&gt;Moves up&lt;/div&gt;

// Combined
&lt;button className="
    transition-all 
    duration-300 
    hover:scale-105 
    hover:rotate-1 
    hover:shadow-lg
    active:scale-95
"&gt;
    Interactive button
&lt;/button&gt;</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Animated Card</h4>
                            <div class="code-block">
<code>// Animated card component
export function AnimatedCard({ children }: { children: React.ReactNode }) {
    return (
        &lt;div className="
            group
            bg-white 
            rounded-lg 
            p-6 
            shadow-md
            transition-all 
            duration-300 
            ease-in-out
            hover:scale-105 
            hover:shadow-xl
            hover:-translate-y-1
            cursor-pointer
        "&gt;
            &lt;div className="
                opacity-0 
                group-hover:opacity-100 
                transition-opacity 
                duration-300
            "&gt;
                {children}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// Staggered animation
export function AnimatedList({ items }: { items: string[] }) {
    return (
        &lt;div&gt;
            {items.map((item, index) => (
                &lt;div
                    key={item}
                    className="
                        animate-fadeIn
                        opacity-0
                    "
                    style={{
                        animationDelay: `${index * 100}ms`,
                        animationFillMode: 'forwards'
                    }}
                &gt;
                    {item}
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Reusable UI kit creation -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Reusable UI kit creation</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Building a UI Kit</h3>
                        <p>Creating a comprehensive, reusable UI component library.</p>
                        
                        <h4>UI Kit Structure</h4>
                        <div class="code-block">
<code>ui-kit/
  src/
    components/
      Button/
        Button.tsx
        Button.test.tsx
        Button.stories.tsx
        index.ts
      Input/
        Input.tsx
        Input.test.tsx
        index.ts
      Card/
        Card.tsx
        CardHeader.tsx
        CardBody.tsx
        CardFooter.tsx
        index.ts
    hooks/
      useTheme.ts
      useMediaQuery.ts
    utils/
      cn.ts
      variants.ts
    index.ts          // Main export
  package.json
  tsconfig.json
  tailwind.config.js

// Main export file
// src/index.ts
export { Button } from './components/Button';
export { Input } from './components/Input';
export { Card, CardHeader, CardBody, CardFooter } from './components/Card';
export { useTheme } from './hooks/useTheme';
export { cn } from './utils/cn';</code>
                        </div>
                        
                        <h4>Utility Functions</h4>
                        <div class="code-block">
<code>// utils/cn.ts - className utility
import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

// Usage
&lt;div className={cn(
    'base-class',
    condition && 'conditional-class',
    className
)}&gt;
    Content
&lt;/div&gt;

// utils/variants.ts
import { cva, type VariantProps } from 'class-variance-authority';

export const createVariants = &lt;T extends Record&lt;string, any&gt;&gt;(
    base: string,
    variants: T
) => {
    return cva(base, { variants });
};

// Example
const buttonVariants = createVariants('btn', {
    variant: {
        primary: 'bg-blue-500',
        secondary: 'bg-gray-500',
    },
    size: {
        sm: 'text-sm',
        md: 'text-base',
        lg: 'text-lg',
    },
});</code>
                        </div>
                        
                        <h4>Complete Component Examples</h4>
                        <div class="code-block">
<code>// components/Alert.tsx
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '../utils/cn';

const alertVariants = cva(
    'rounded-lg border p-4',
    {
        variants: {
            variant: {
                default: 'bg-white border-gray-200',
                success: 'bg-green-50 border-green-200 text-green-800',
                error: 'bg-red-50 border-red-200 text-red-800',
                warning: 'bg-yellow-50 border-yellow-200 text-yellow-800',
                info: 'bg-blue-50 border-blue-200 text-blue-800',
            },
        },
        defaultVariants: {
            variant: 'default',
        },
    }
);

interface AlertProps
    extends React.HTMLAttributes&lt;HTMLDivElement&gt;,
        VariantProps&lt;typeof alertVariants&gt; {
    title?: string;
    icon?: React.ReactNode;
}

export const Alert = ({ className, variant, title, icon, children, ...props }: AlertProps) => {
    return (
        &lt;div className={cn(alertVariants({ variant }), className)} {...props}&gt;
            &lt;div className="flex items-start"&gt;
                {icon && &lt;div className="mr-3"&gt;{icon}&lt;/div&gt;}
                &lt;div className="flex-1"&gt;
                    {title && &lt;h4 className="font-semibold mb-1"&gt;{title}&lt;/h4&gt;}
                    &lt;div&gt;{children}&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

// components/Badge.tsx
const badgeVariants = cva(
    'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium',
    {
        variants: {
            variant: {
                default: 'bg-gray-100 text-gray-800',
                primary: 'bg-primary-100 text-primary-800',
                success: 'bg-green-100 text-green-800',
                error: 'bg-red-100 text-red-800',
            },
        },
        defaultVariants: {
            variant: 'default',
        },
    }
);

export const Badge = ({ className, variant, children, ...props }: BadgeProps) => {
    return (
        &lt;span className={cn(badgeVariants({ variant }), className)} {...props}&gt;
            {children}
        &lt;/span&gt;
    );
};

// components/Modal.tsx
'use client';

import { createContext, useContext, useState } from 'react';

interface ModalContextType {
    isOpen: boolean;
    open: () => void;
    close: () => void;
}

const ModalContext = createContext&lt;ModalContextType | undefined&gt;(undefined);

export function Modal({ children }: { children: React.ReactNode }) {
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        &lt;ModalContext.Provider value={{ isOpen, open: () => setIsOpen(true), close: () => setIsOpen(false) }}&gt;
            {children}
        &lt;/ModalContext.Provider&gt;
    );
}

Modal.Trigger = ({ children }: { children: React.ReactNode }) => {
    const { open } = useModal();
    return &lt;button onClick={open}&gt;{children}&lt;/button&gt;;
};

Modal.Content = ({ children }: { children: React.ReactNode }) => {
    const { isOpen, close } = useModal();
    
    if (!isOpen) return null;
    
    return (
        &lt;div className="fixed inset-0 z-50 flex items-center justify-center"&gt;
            &lt;div className="fixed inset-0 bg-black/50" onClick={close} /&gt;
            &lt;div className="relative bg-white rounded-lg p-6 max-w-md w-full"&gt;
                {children}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

function useModal() {
    const context = useContext(ModalContext);
    if (!context) throw new Error('Modal components must be used within Modal');
    return context;
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete UI Kit Package</h4>
                            <div class="code-block">
<code>// package.json
{
  "name": "@yourcompany/ui-kit",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "scripts": {
    "build": "tsc && tailwindcss -i ./src/styles.css -o ./dist/styles.css",
    "dev": "tailwindcss -i ./src/styles.css -o ./dist/styles.css --watch"
  },
  "dependencies": {
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "peerDependencies": {
    "react": "^18.0.0",
    "tailwindcss": "^3.0.0"
  }
}

// Usage in project
import { Button, Input, Card, Alert } from '@yourcompany/ui-kit';
import '@yourcompany/ui-kit/dist/styles.css';

export default function Page() {
    return (
        &lt;Card&gt;
            &lt;Alert variant="success" title="Success"&gt;
                Operation completed!
            &lt;/Alert&gt;
            &lt;Input label="Name" /&gt;
            &lt;Button variant="primary"&gt;Submit&lt;/Button&gt;
        &lt;/Card&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Dashboard design best practices -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Dashboard design best practices</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Dashboard Design Principles</h3>
                        <p>Best practices for creating effective, user-friendly dashboards.</p>
                        
                        <h4>Layout Principles</h4>
                        <div class="code-block">
<code>// Grid system for dashboards
export function DashboardLayout({ children }: { children: React.ReactNode }) {
    return (
        &lt;div className="min-h-screen bg-gray-50 dark:bg-gray-900"&gt;
            &lt;Sidebar /&gt;
            &lt;main className="ml-64 p-6"&gt;
                &lt;div className="max-w-7xl mx-auto"&gt;
                    &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6"&gt;
                        {/* Stats cards */}
                    &lt;/div&gt;
                    &lt;div className="grid grid-cols-1 lg:grid-cols-3 gap-6"&gt;
                        &lt;div className="lg:col-span-2"&gt;
                            {/* Main content */}
                        &lt;/div&gt;
                        &lt;div className="lg:col-span-1"&gt;
                            {/* Sidebar content */}
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/main&gt;
        &lt;/div&gt;
    );
}

// Responsive grid
&lt;div className="
    grid 
    grid-cols-1 
    sm:grid-cols-2 
    md:grid-cols-3 
    lg:grid-cols-4 
    gap-4
"&gt;
    {items.map(item => &lt;Card key={item.id} item={item} /&gt;)}
&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Information Hierarchy</h4>
                        <div class="code-block">
<code>// Visual hierarchy with typography
export function DashboardHeader({ title, subtitle }: { title: string; subtitle?: string }) {
    return (
        &lt;div className="mb-6"&gt;
            &lt;h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-2"&gt;
                {title}
            &lt;/h1&gt;
            {subtitle && (
                &lt;p className="text-gray-600 dark:text-gray-400"&gt;
                    {subtitle}
                &lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

// Card hierarchy
export function StatsCard({ title, value, change, trend }: StatsCardProps) {
    return (
        &lt;Card className="p-6"&gt;
            &lt;div className="flex items-center justify-between mb-2"&gt;
                &lt;h3 className="text-sm font-medium text-gray-600 dark:text-gray-400"&gt;
                    {title}
                &lt;/h3&gt;
                {trend && &lt;TrendIcon trend={trend} /&gt;}
            &lt;/div&gt;
            &lt;div className="flex items-baseline"&gt;
                &lt;span className="text-2xl font-bold text-gray-900 dark:text-white"&gt;
                    {value}
                &lt;/span&gt;
                {change && (
                    &lt;span className={`ml-2 text-sm ${change > 0 ? 'text-green-600' : 'text-red-600'}`}&gt;
                        {change > 0 ? '+' : ''}{change}%
                    &lt;/span&gt;
                )}
            &lt;/div&gt;
        &lt;/Card&gt;
    );
}</code>
                        </div>
                        
                        <h4>Color Usage</h4>
                        <div class="code-block">
<code>// Semantic colors for dashboard
const colorMap = {
    success: {
        bg: 'bg-green-50 dark:bg-green-900/20',
        text: 'text-green-800 dark:text-green-200',
        border: 'border-green-200 dark:border-green-800',
    },
    warning: {
        bg: 'bg-yellow-50 dark:bg-yellow-900/20',
        text: 'text-yellow-800 dark:text-yellow-200',
        border: 'border-yellow-200 dark:border-yellow-800',
    },
    error: {
        bg: 'bg-red-50 dark:bg-red-900/20',
        text: 'text-red-800 dark:text-red-200',
        border: 'border-red-200 dark:border-red-800',
    },
    info: {
        bg: 'bg-blue-50 dark:bg-blue-900/20',
        text: 'text-blue-800 dark:text-blue-200',
        border: 'border-blue-200 dark:border-blue-800',
    },
};

// Usage
&lt;div className={`${colorMap.success.bg} ${colorMap.success.text} border ${colorMap.success.border} rounded-lg p-4`}&gt;
    Success message
&lt;/div&gt;</code>
                        </div>
                        
                        <h4>Spacing and Whitespace</h4>
                        <div class="code-block">
<code>// Consistent spacing scale
const spacing = {
    xs: '0.5rem',   // 8px
    sm: '1rem',     // 16px
    md: '1.5rem',   // 24px
    lg: '2rem',     // 32px
    xl: '3rem',     // 48px
};

// Card spacing
&lt;Card className="p-6"&gt;  {/* md spacing */}
    &lt;h3 className="mb-4"&gt;Title&lt;/h3&gt;  {/* lg spacing */}
    &lt;p className="mb-2"&gt;Content&lt;/p&gt;  {/* sm spacing */}
&lt;/Card&gt;

// Section spacing
&lt;section className="mb-8"&gt;  {/* xl spacing between sections */}
    &lt;h2 className="mb-4"&gt;Section Title&lt;/h2&gt;  {/* lg spacing */}
    &lt;div className="space-y-4"&gt;  {/* Consistent vertical spacing */}
        {items.map(item => &lt;Item key={item.id} item={item} /&gt;)}
    &lt;/div&gt;
&lt;/section&gt;</code>
                        </div>
                        
                        <h4>Loading and Empty States</h4>
                        <div class="code-block">
<code>// Skeleton loading
export function CardSkeleton() {
    return (
        &lt;div className="animate-pulse"&gt;
            &lt;div className="h-4 bg-gray-200 rounded w-3/4 mb-4"&gt;&lt;/div&gt;
            &lt;div className="h-8 bg-gray-200 rounded w-1/2"&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
}

// Empty state
export function EmptyState({ 
    title, 
    description, 
    action 
}: { 
    title: string; 
    description?: string; 
    action?: React.ReactNode;
}) {
    return (
        &lt;div className="text-center py-12"&gt;
            &lt;div className="text-gray-400 text-6xl mb-4"&gt;üì≠&lt;/div&gt;
            &lt;h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-2"&gt;
                {title}
            &lt;/h3&gt;
            {description && (
                &lt;p className="text-gray-600 dark:text-gray-400 mb-4"&gt;
                    {description}
                &lt;/p&gt;
            )}
            {action}
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Dashboard Layout</h4>
                            <div class="code-block">
<code>// Complete dashboard implementation
export default function Dashboard() {
    return (
        &lt;div className="min-h-screen bg-gray-50 dark:bg-gray-900"&gt;
            &lt;Sidebar /&gt;
            &lt;main className="ml-64 p-6"&gt;
                &lt;div className="max-w-7xl mx-auto space-y-6"&gt;
                    {/* Header */}
                    &lt;div className="flex items-center justify-between"&gt;
                        &lt;div&gt;
                            &lt;h1 className="text-3xl font-bold text-gray-900 dark:text-white"&gt;
                                Dashboard
                            &lt;/h1&gt;
                            &lt;p className="text-gray-600 dark:text-gray-400 mt-1"&gt;
                                Welcome back! Here's what's happening.
                            &lt;/p&gt;
                        &lt;/div&gt;
                        &lt;Button&gt;New Action&lt;/Button&gt;
                    &lt;/div&gt;
                    
                    {/* Stats Grid */}
                    &lt;div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6"&gt;
                        &lt;StatsCard 
                            title="Total Users"
                            value="12,345"
                            change={12.5}
                            trend="up"
                        /&gt;
                        &lt;StatsCard 
                            title="Revenue"
                            value="$45,678"
                            change={8.2}
                            trend="up"
                        /&gt;
                        &lt;StatsCard 
                            title="Orders"
                            value="1,234"
                            change={-3.1}
                            trend="down"
                        /&gt;
                        &lt;StatsCard 
                            title="Conversion"
                            value="3.2%"
                            change={0.5}
                            trend="up"
                        /&gt;
                    &lt;/div&gt;
                    
                    {/* Main Content Grid */}
                    &lt;div className="grid grid-cols-1 lg:grid-cols-3 gap-6"&gt;
                        &lt;div className="lg:col-span-2"&gt;
                            &lt;Card&gt;
                                &lt;Card.Header&gt;
                                    &lt;h2&gt;Revenue Chart&lt;/h2&gt;
                                &lt;/Card.Header&gt;
                                &lt;Card.Body&gt;
                                    &lt;RevenueChart /&gt;
                                &lt;/Card.Body&gt;
                            &lt;/Card&gt;
                        &lt;/div&gt;
                        &lt;div className="lg:col-span-1"&gt;
                            &lt;Card&gt;
                                &lt;Card.Header&gt;
                                    &lt;h2&gt;Recent Activity&lt;/h2&gt;
                                &lt;/Card.Header&gt;
                                &lt;Card.Body&gt;
                                    &lt;ActivityList /&gt;
                                &lt;/Card.Body&gt;
                            &lt;/Card&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/main&gt;
        &lt;/div&gt;
    );
}</code>
                            </div>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Keep dashboards scannable with clear visual hierarchy. Use consistent spacing, meaningful colors, and proper typography. Always provide loading and empty states. Make dashboards responsive and accessible. Test with real data to ensure information density is appropriate.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Video 09: Authentication UI + Frontend Security Essentials -->
        <div class="video-section" id="video-09">
            <div class="video-header">
                <span class="video-number">Video 09</span>
                <h2 class="video-title">Authentication UI + Frontend Security Essentials</h2>
            </div>
            
            <!-- Topic 1: Login forms, validations -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Login forms, validations</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Login Form Implementation</h3>
                        <p>Creating secure, user-friendly login forms with proper validation.</p>
                        
                        <h4>Basic Login Form</h4>
                        <div class="code-block">
<code>// components/auth/LoginForm.tsx
'use client';

import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

// Validation schema
const loginSchema = z.object({
    email: z.string().email('Invalid email address').min(1, 'Email is required'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
});

type LoginFormData = z.infer&lt;typeof loginSchema&gt;;

export function LoginForm() {
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    const {
        register,
        handleSubmit,
        formState: { errors },
    } = useForm&lt;LoginFormData&gt;({
        resolver: zodResolver(loginSchema),
    });
    
    const onSubmit = async (data: LoginFormData) => {
        setIsLoading(true);
        setError(null);
        
        try {
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data),
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || 'Login failed');
            }
            
            const result = await response.json();
            // Handle successful login (store token, redirect, etc.)
            localStorage.setItem('token', result.token);
            window.location.href = '/dashboard';
        } catch (err) {
            setError(err instanceof Error ? err.message : 'An error occurred');
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        &lt;form onSubmit={handleSubmit(onSubmit)} className="space-y-4"&gt;
            {error && (
                &lt;div className="bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded"&gt;
                    {error}
                &lt;/div&gt;
            )}
            
            &lt;div&gt;
                &lt;label htmlFor="email" className="block text-sm font-medium mb-1"&gt;
                    Email
                &lt;/label&gt;
                &lt;input
                    id="email"
                    type="email"
                    {...register('email')}
                    className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    disabled={isLoading}
                /&gt;
                {errors.email && (
                    &lt;p className="mt-1 text-sm text-red-600"&gt;{errors.email.message}&lt;/p&gt;
                )}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;label htmlFor="password" className="block text-sm font-medium mb-1"&gt;
                    Password
                &lt;/label&gt;
                &lt;input
                    id="password"
                    type="password"
                    {...register('password')}
                    className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                    disabled={isLoading}
                /&gt;
                {errors.password && (
                    &lt;p className="mt-1 text-sm text-red-600"&gt;{errors.password.message}&lt;/p&gt;
                )}
            &lt;/div&gt;
            
            &lt;button
                type="submit"
                disabled={isLoading}
                className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 disabled:opacity-50"
            &gt;
                {isLoading ? 'Logging in...' : 'Login'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code>
                        </div>
                        
                        <h4>Advanced Validation</h4>
                        <div class="code-block">
<code>// Enhanced validation schema
const loginSchema = z.object({
    email: z
        .string()
        .min(1, 'Email is required')
        .email('Invalid email address')
        .toLowerCase()
        .trim(),
    password: z
        .string()
        .min(8, 'Password must be at least 8 characters')
        .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
        .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
        .regex(/[0-9]/, 'Password must contain at least one number')
        .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),
    rememberMe: z.boolean().optional(),
});

// Real-time validation
export function LoginFormWithRealtimeValidation() {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [emailError, setEmailError] = useState&lt;string | null&gt;(null);
    const [passwordError, setPasswordError] = useState&lt;string | null&gt;(null);
    
    const validateEmail = (value: string) => {
        if (!value) {
            setEmailError('Email is required');
            return false;
        }
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
            setEmailError('Invalid email address');
            return false;
        }
        setEmailError(null);
        return true;
    };
    
    const validatePassword = (value: string) => {
        if (!value) {
            setPasswordError('Password is required');
            return false;
        }
        if (value.length &lt; 8) {
            setPasswordError('Password must be at least 8 characters');
            return false;
        }
        setPasswordError(null);
        return true;
    };
    
    return (
        &lt;form className="space-y-4"&gt;
            &lt;div&gt;
                &lt;input
                    type="email"
                    value={email}
                    onChange={(e) => {
                        setEmail(e.target.value);
                        validateEmail(e.target.value);
                    }}
                    onBlur={() => validateEmail(email)}
                    className={`w-full px-3 py-2 border rounded-md ${
                        emailError ? 'border-red-500' : 'border-gray-300'
                    }`}
                /&gt;
                {emailError && &lt;p className="mt-1 text-sm text-red-600"&gt;{emailError}&lt;/p&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="password"
                    value={password}
                    onChange={(e) => {
                        setPassword(e.target.value);
                        validatePassword(e.target.value);
                    }}
                    onBlur={() => validatePassword(password)}
                    className={`w-full px-3 py-2 border rounded-md ${
                        passwordError ? 'border-red-500' : 'border-gray-300'
                    }`}
                /&gt;
                {passwordError && &lt;p className="mt-1 text-sm text-red-600"&gt;{passwordError}&lt;/p&gt;}
            &lt;/div&gt;
        &lt;/form&gt;
    );
}</code>
                        </div>
                        
                        <h4>Password Strength Indicator</h4>
                        <div class="code-block">
<code>// Password strength checker
function getPasswordStrength(password: string): {
    strength: 'weak' | 'medium' | 'strong';
    score: number;
    feedback: string[];
} {
    let score = 0;
    const feedback: string[] = [];
    
    if (password.length &gt;= 8) score++;
    else feedback.push('Use at least 8 characters');
    
    if (/[a-z]/.test(password)) score++;
    else feedback.push('Add lowercase letters');
    
    if (/[A-Z]/.test(password)) score++;
    else feedback.push('Add uppercase letters');
    
    if (/[0-9]/.test(password)) score++;
    else feedback.push('Add numbers');
    
    if (/[^A-Za-z0-9]/.test(password)) score++;
    else feedback.push('Add special characters');
    
    if (password.length &gt;= 12) score++;
    
    const strength = score &lt;= 2 ? 'weak' : score &lt;= 4 ? 'medium' : 'strong';
    
    return { strength, score, feedback };
}

export function PasswordInputWithStrength() {
    const [password, setPassword] = useState('');
    const strength = getPasswordStrength(password);
    
    const strengthColors = {
        weak: 'bg-red-500',
        medium: 'bg-yellow-500',
        strong: 'bg-green-500',
    };
    
    return (
        &lt;div&gt;
            &lt;input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full px-3 py-2 border rounded-md"
            /&gt;
            {password && (
                &lt;div className="mt-2"&gt;
                    &lt;div className="flex gap-1 mb-1"&gt;
                        {[1, 2, 3, 4, 5].map((i) => (
                            &lt;div
                                key={i}
                                className={`h-1 flex-1 rounded ${
                                    i &lt;= strength.score
                                        ? strengthColors[strength.strength]
                                        : 'bg-gray-200'
                                }`}
                            /&gt;
                        ))}
                    &lt;/div&gt;
                    &lt;p className={`text-sm ${
                        strength.strength === 'weak'
                            ? 'text-red-600'
                            : strength.strength === 'medium'
                            ? 'text-yellow-600'
                            : 'text-green-600'
                    }`}&gt;
                        Password strength: {strength.strength}
                    &lt;/p&gt;
                    {strength.feedback.length &gt; 0 && (
                        &lt;ul className="text-xs text-gray-600 mt-1"&gt;
                            {strength.feedback.map((item, i) => (
                                &lt;li key={i}&gt;‚Ä¢ {item}&lt;/li&gt;
                            ))}
                        &lt;/ul&gt;
                    )}
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Login Form with All Features</h4>
                            <div class="code-block">
<code>// Complete login form with validation, loading states, and error handling
export function CompleteLoginForm() {
    const [showPassword, setShowPassword] = useState(false);
    const [isLoading, setIsLoading] = useState(false);
    
    const {
        register,
        handleSubmit,
        formState: { errors, isSubmitting },
        setError,
    } = useForm&lt;LoginFormData&gt;({
        resolver: zodResolver(loginSchema),
    });
    
    const onSubmit = async (data: LoginFormData) => {
        setIsLoading(true);
        try {
            // Simulate API call
            await new Promise((resolve) => setTimeout(resolve, 1000));
            
            // Handle success
            console.log('Login successful', data);
        } catch (error) {
            setError('root', {
                message: 'Invalid credentials. Please try again.',
            });
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        &lt;form onSubmit={handleSubmit(onSubmit)} className="space-y-6"&gt;
            &lt;div&gt;
                &lt;label className="block text-sm font-medium mb-2"&gt;Email&lt;/label&gt;
                &lt;input
                    {...register('email')}
                    type="email"
                    autoComplete="email"
                    className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                /&gt;
                {errors.email && (
                    &lt;p className="mt-1 text-sm text-red-600"&gt;{errors.email.message}&lt;/p&gt;
                )}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;label className="block text-sm font-medium mb-2"&gt;Password&lt;/label&gt;
                &lt;div className="relative"&gt;
                    &lt;input
                        {...register('password')}
                        type={showPassword ? 'text' : 'password'}
                        autoComplete="current-password"
                        className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                    /&gt;
                    &lt;button
                        type="button"
                        onClick={() => setShowPassword(!showPassword)}
                        className="absolute right-3 top-1/2 -translate-y-1/2"
                    &gt;
                        {showPassword ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è'}
                    &lt;/button&gt;
                &lt;/div&gt;
                {errors.password && (
                    &lt;p className="mt-1 text-sm text-red-600"&gt;{errors.password.message}&lt;/p&gt;
                )}
            &lt;/div&gt;
            
            &lt;div className="flex items-center justify-between"&gt;
                &lt;label className="flex items-center"&gt;
                    &lt;input
                        type="checkbox"
                        {...register('rememberMe')}
                        className="mr-2"
                    /&gt;
                    &lt;span className="text-sm"&gt;Remember me&lt;/span&gt;
                &lt;/label&gt;
                &lt;a href="/forgot-password" className="text-sm text-blue-600"&gt;
                    Forgot password?
                &lt;/a&gt;
            &lt;/div&gt;
            
            {errors.root && (
                &lt;div className="bg-red-50 border border-red-200 text-red-800 px-4 py-3 rounded"&gt;
                    {errors.root.message}
                &lt;/div&gt;
            )}
            
            &lt;button
                type="submit"
                disabled={isSubmitting || isLoading}
                className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 disabled:opacity-50"
            &gt;
                {isSubmitting || isLoading ? 'Logging in...' : 'Login'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Protected routes + UI states -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Protected routes + UI states</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Route Protection</h3>
                        <p>Implementing protected routes and managing authentication UI states.</p>
                        
                        <h4>Authentication Context</h4>
                        <div class="code-block">
<code>// contexts/AuthContext.tsx
'use client';

import { createContext, useContext, useState, useEffect } from 'react';

interface User {
    id: string;
    email: string;
    name: string;
    role: string;
}

interface AuthContextType {
    user: User | null;
    isLoading: boolean;
    isAuthenticated: boolean;
    login: (email: string, password: string) => Promise&lt;void&gt;;
    logout: () => void;
    checkAuth: () => Promise&lt;void&gt;;
}

const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    
    useEffect(() => {
        checkAuth();
    }, []);
    
    const checkAuth = async () => {
        try {
            const token = localStorage.getItem('token');
            if (!token) {
                setIsLoading(false);
                return;
            }
            
            const response = await fetch('/api/auth/me', {
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            
            if (response.ok) {
                const userData = await response.json();
                setUser(userData);
            } else {
                localStorage.removeItem('token');
            }
        } catch (error) {
            console.error('Auth check failed:', error);
            localStorage.removeItem('token');
        } finally {
            setIsLoading(false);
        }
    };
    
    const login = async (email: string, password: string) => {
        const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password }),
        });
        
        if (!response.ok) {
            throw new Error('Login failed');
        }
        
        const { token, user: userData } = await response.json();
        localStorage.setItem('token', token);
        setUser(userData);
    };
    
    const logout = () => {
        localStorage.removeItem('token');
        setUser(null);
    };
    
    return (
        &lt;AuthContext.Provider
            value={{
                user,
                isLoading,
                isAuthenticated: !!user,
                login,
                logout,
                checkAuth,
            }}
        &gt;
            {children}
        &lt;/AuthContext.Provider&gt;
    );
}

export function useAuth() {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within AuthProvider');
    }
    return context;
}</code>
                        </div>
                        
                        <h4>Protected Route Component</h4>
                        <div class="code-block">
<code>// components/auth/ProtectedRoute.tsx
'use client';

import { useAuth } from '@/contexts/AuthContext';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

interface ProtectedRouteProps {
    children: React.ReactNode;
    requiredRole?: string;
    fallback?: React.ReactNode;
}

export function ProtectedRoute({
    children,
    requiredRole,
    fallback,
}: ProtectedRouteProps) {
    const { user, isLoading, isAuthenticated } = useAuth();
    const router = useRouter();
    
    useEffect(() => {
        if (!isLoading && !isAuthenticated) {
            router.push('/login?redirect=' + encodeURIComponent(window.location.pathname));
        }
    }, [isLoading, isAuthenticated, router]);
    
    if (isLoading) {
        return fallback || (
            &lt;div className="flex items-center justify-center min-h-screen"&gt;
                &lt;div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"&gt;&lt;/div&gt;
            &lt;/div&gt;
        );
    }
    
    if (!isAuthenticated) {
        return null;
    }
    
    if (requiredRole && user?.role !== requiredRole) {
        return (
            &lt;div className="flex items-center justify-center min-h-screen"&gt;
                &lt;div className="text-center"&gt;
                    &lt;h1 className="text-2xl font-bold mb-2"&gt;Access Denied&lt;/h1&gt;
                    &lt;p className="text-gray-600"&gt;You don't have permission to access this page.&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
    
    return &lt;&gt;{children}&lt;/&gt;;
}

// Usage in Next.js App Router
export default function DashboardPage() {
    return (
        &lt;ProtectedRoute requiredRole="admin"&gt;
            &lt;div&gt;Dashboard content&lt;/div&gt;
        &lt;/ProtectedRoute&gt;
    );
}</code>
                        </div>
                        
                        <h4>Route Guard Hook</h4>
                        <div class="code-block">
<code>// hooks/useRequireAuth.ts
import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@/contexts/AuthContext';

export function useRequireAuth(requiredRole?: string) {
    const { user, isLoading, isAuthenticated } = useAuth();
    const router = useRouter();
    
    useEffect(() => {
        if (!isLoading) {
            if (!isAuthenticated) {
                router.push('/login');
                return;
            }
            
            if (requiredRole && user?.role !== requiredRole) {
                router.push('/unauthorized');
                return;
            }
        }
    }, [isLoading, isAuthenticated, user, requiredRole, router]);
    
    return { user, isLoading, isAuthenticated };
}

// Usage
export default function AdminPage() {
    const { user, isLoading } = useRequireAuth('admin');
    
    if (isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    return &lt;div&gt;Admin content for {user?.name}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>UI State Management</h4>
                        <div class="code-block">
<code>// Managing different UI states
export function AuthStateManager() {
    const { user, isLoading, isAuthenticated } = useAuth();
    
    // Loading state
    if (isLoading) {
        return (
            &lt;div className="flex items-center justify-center min-h-screen"&gt;
                &lt;div className="text-center"&gt;
                    &lt;div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"&gt;&lt;/div&gt;
                    &lt;p className="text-gray-600"&gt;Loading...&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
    
    // Unauthenticated state
    if (!isAuthenticated) {
        return (
            &lt;div className="flex items-center justify-center min-h-screen"&gt;
                &lt;div className="text-center"&gt;
                    &lt;h1 className="text-2xl font-bold mb-4"&gt;Please log in&lt;/h1&gt;
                    &lt;a href="/login" className="text-blue-600 hover:underline"&gt;
                        Go to login
                    &lt;/a&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        );
    }
    
    // Authenticated state
    return (
        &lt;div&gt;
            &lt;h1&gt;Welcome, {user?.name}!&lt;/h1&gt;
            {/* Authenticated content */}
        &lt;/div&gt;
    );
}

// Conditional rendering based on auth state
export function ConditionalContent() {
    const { isAuthenticated } = useAuth();
    
    return (
        &lt;div&gt;
            {isAuthenticated ? (
                &lt;AuthenticatedContent /&gt;
            ) : (
                &lt;UnauthenticatedContent /&gt;
            )}
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Route Protection Setup</h4>
                            <div class="code-block">
<code>// app/layout.tsx (Next.js App Router)
import { AuthProvider } from '@/contexts/AuthContext';

export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
        &lt;html&gt;
            &lt;body&gt;
                &lt;AuthProvider&gt;
                    {children}
                &lt;/AuthProvider&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    );
}

// app/dashboard/page.tsx
import { ProtectedRoute } from '@/components/auth/ProtectedRoute';

export default function DashboardPage() {
    return (
        &lt;ProtectedRoute&gt;
            &lt;div&gt;
                &lt;h1&gt;Dashboard&lt;/h1&gt;
                {/* Dashboard content */}
            &lt;/div&gt;
        &lt;/ProtectedRoute&gt;
    );
}

// app/admin/page.tsx
import { ProtectedRoute } from '@/components/auth/ProtectedRoute';

export default function AdminPage() {
    return (
        &lt;ProtectedRoute requiredRole="admin"&gt;
            &lt;div&gt;
                &lt;h1&gt;Admin Panel&lt;/h1&gt;
                {/* Admin content */}
            &lt;/div&gt;
        &lt;/ProtectedRoute&gt;
    );
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Role-based access (RBAC) on frontend -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Role-based access (RBAC) on frontend</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Frontend RBAC Implementation</h3>
                        <p>Implementing role-based access control on the frontend for UI visibility and permissions.</p>
                        
                        <h4>Role Definitions</h4>
                        <div class="code-block">
<code>// types/roles.ts
export type Role = 'admin' | 'editor' | 'viewer' | 'user';

export interface Permission {
    resource: string;
    actions: string[];
}

export const ROLE_PERMISSIONS: Record&lt;Role, Permission[]&gt; = {
    admin: [
        { resource: 'users', actions: ['create', 'read', 'update', 'delete'] },
        { resource: 'posts', actions: ['create', 'read', 'update', 'delete'] },
        { resource: 'settings', actions: ['read', 'update'] },
    ],
    editor: [
        { resource: 'posts', actions: ['create', 'read', 'update'] },
        { resource: 'comments', actions: ['create', 'read', 'update', 'delete'] },
    ],
    viewer: [
        { resource: 'posts', actions: ['read'] },
        { resource: 'comments', actions: ['read'] },
    ],
    user: [
        { resource: 'profile', actions: ['read', 'update'] },
        { resource: 'posts', actions: ['read'] },
    ],
};

export function hasPermission(
    userRole: Role,
    resource: string,
    action: string
): boolean {
    const permissions = ROLE_PERMISSIONS[userRole] || [];
    const resourcePermission = permissions.find((p) => p.resource === resource);
    return resourcePermission?.actions.includes(action) || false;
}</code>
                        </div>
                        
                        <h4>RBAC Hook</h4>
                        <div class="code-block">
<code>// hooks/useRBAC.ts
import { useAuth } from '@/contexts/AuthContext';
import { hasPermission, Role } from '@/types/roles';

export function useRBAC() {
    const { user } = useAuth();
    const userRole = (user?.role as Role) || 'user';
    
    const can = (resource: string, action: string) => {
        return hasPermission(userRole, resource, action);
    };
    
    const hasRole = (role: Role | Role[]) => {
        if (Array.isArray(role)) {
            return role.includes(userRole);
        }
        return userRole === role;
    };
    
    return {
        can,
        hasRole,
        role: userRole,
        isAdmin: userRole === 'admin',
        isEditor: userRole === 'editor',
    };
}

// Usage
export function PostActions() {
    const { can, hasRole } = useRBAC();
    
    return (
        &lt;div&gt;
            {can('posts', 'create') && (
                &lt;button&gt;Create Post&lt;/button&gt;
            )}
            {can('posts', 'update') && (
                &lt;button&gt;Edit Post&lt;/button&gt;
            )}
            {can('posts', 'delete') && (
                &lt;button&gt;Delete Post&lt;/button&gt;
            )}
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>RBAC Components</h4>
                        <div class="code-block">
<code>// components/rbac/Can.tsx
import { useRBAC } from '@/hooks/useRBAC';

interface CanProps {
    resource: string;
    action: string;
    children: React.ReactNode;
    fallback?: React.ReactNode;
}

export function Can({ resource, action, children, fallback = null }: CanProps) {
    const { can } = useRBAC();
    
    if (!can(resource, action)) {
        return &lt;&gt;{fallback}&lt;/&gt;;
    }
    
    return &lt;&gt;{children}&lt;/&gt;;
}

// components/rbac/HasRole.tsx
import { useRBAC } from '@/hooks/useRBAC';
import { Role } from '@/types/roles';

interface HasRoleProps {
    role: Role | Role[];
    children: React.ReactNode;
    fallback?: React.ReactNode;
}

export function HasRole({ role, children, fallback = null }: HasRoleProps) {
    const { hasRole } = useRBAC();
    
    if (!hasRole(role)) {
        return &lt;&gt;{fallback}&lt;/&gt;;
    }
    
    return &lt;&gt;{children}&lt;/&gt;;
}

// Usage
export function PostManagement() {
    return (
        &lt;div&gt;
            &lt;Can resource="posts" action="create"&gt;
                &lt;button&gt;Create Post&lt;/button&gt;
            &lt;/Can&gt;
            
            &lt;Can resource="posts" action="update"&gt;
                &lt;button&gt;Edit Post&lt;/button&gt;
            &lt;/Can&gt;
            
            &lt;HasRole role="admin"&gt;
                &lt;button&gt;Admin Only Action&lt;/button&gt;
            &lt;/HasRole&gt;
            
            &lt;HasRole role={['admin', 'editor']}&gt;
                &lt;button&gt;Admin or Editor Action&lt;/button&gt;
            &lt;/HasRole&gt;
        &lt;/div&gt;
    );
}</code>
                        </div>
                        
                        <h4>Menu Based on Roles</h4>
                        <div class="code-block">
<code>// components/Navigation.tsx
import { useRBAC } from '@/hooks/useRBAC';

interface MenuItem {
    label: string;
    href: string;
    requiredRole?: Role | Role[];
    requiredPermission?: { resource: string; action: string };
}

const menuItems: MenuItem[] = [
    { label: 'Home', href: '/' },
    { label: 'Posts', href: '/posts' },
    {
        label: 'Create Post',
        href: '/posts/create',
        requiredPermission: { resource: 'posts', action: 'create' },
    },
    {
        label: 'Admin Panel',
        href: '/admin',
        requiredRole: 'admin',
    },
    {
        label: 'Settings',
        href: '/settings',
        requiredRole: ['admin', 'editor'],
    },
];

export function Navigation() {
    const { can, hasRole } = useRBAC();
    
    const visibleItems = menuItems.filter((item) => {
        if (item.requiredRole) {
            return hasRole(item.requiredRole);
        }
        if (item.requiredPermission) {
            return can(
                item.requiredPermission.resource,
                item.requiredPermission.action
            );
        }
        return true;
    });
    
    return (
        &lt;nav&gt;
            {visibleItems.map((item) => (
                &lt;a key={item.href} href={item.href}&gt;
                    {item.label}
                &lt;/a&gt;
            ))}
        &lt;/nav&gt;
    );
}</code>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Frontend RBAC is for UI purposes only. Always validate permissions on the backend. Never trust client-side role checks for security. An attacker can easily modify frontend code to bypass these checks.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Securing tokens on frontend -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Securing tokens on frontend</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Token Security Best Practices</h3>
                        <p>Properly storing and managing authentication tokens on the frontend.</p>
                        
                        <h4>Token Storage Options</h4>
                        <div class="code-block">
<code>// Token storage comparison
// ‚ùå BAD: Storing in global variables
let token = '';

// ‚ùå BAD: Storing in localStorage (vulnerable to XSS)
localStorage.setItem('token', token);

// ‚úÖ BETTER: Using httpOnly cookies (handled by server)
// Set-Cookie: token=xxx; HttpOnly; Secure; SameSite=Strict

// ‚úÖ GOOD: Using sessionStorage (cleared on tab close)
sessionStorage.setItem('token', token);

// ‚úÖ BEST: Using httpOnly cookies + secure flags
// Server sets cookie with:
// - HttpOnly: Prevents JavaScript access
// - Secure: Only sent over HTTPS
// - SameSite: Prevents CSRF attacks

// Token storage utility
class TokenStorage {
    private static readonly TOKEN_KEY = 'auth_token';
    private static readonly REFRESH_TOKEN_KEY = 'refresh_token';
    
    // Store in memory (most secure, but lost on refresh)
    private static memoryToken: string | null = null;
    
    static setToken(token: string, useMemory = false) {
        if (useMemory) {
            this.memoryToken = token;
            return;
        }
        
        // Use sessionStorage for better security than localStorage
        sessionStorage.setItem(this.TOKEN_KEY, token);
    }
    
    static getToken(): string | null {
        // Check memory first
        if (this.memoryToken) {
            return this.memoryToken;
        }
        
        // Fallback to sessionStorage
        return sessionStorage.getItem(this.TOKEN_KEY);
    }
    
    static removeToken() {
        this.memoryToken = null;
        sessionStorage.removeItem(this.TOKEN_KEY);
        sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);
    }
    
    static hasToken(): boolean {
        return !!this.getToken();
    }
}</code>
                        </div>
                        
                        <h4>Secure Token Management</h4>
                        <div class="code-block">
<code>// Secure token manager
class SecureTokenManager {
    private token: string | null = null;
    private refreshToken: string | null = null;
    private tokenExpiry: number | null = null;
    
    setTokens(accessToken: string, refreshToken: string, expiresIn: number) {
        this.token = accessToken;
        this.refreshToken = refreshToken;
        this.tokenExpiry = Date.now() + expiresIn * 1000;
        
        // Store refresh token securely (httpOnly cookie preferred)
        // Access token kept in memory only
    }
    
    getToken(): string | null {
        if (!this.token || !this.tokenExpiry) {
            return null;
        }
        
        // Check if token is expired
        if (Date.now() &gt;= this.tokenExpiry) {
            this.refreshAccessToken();
            return null;
        }
        
        return this.token;
    }
    
    async refreshAccessToken(): Promise&lt;string | null&gt; {
        if (!this.refreshToken) {
            return null;
        }
        
        try {
            const response = await fetch('/api/auth/refresh', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ refreshToken: this.refreshToken }),
            });
            
            if (!response.ok) {
                this.clearTokens();
                return null;
            }
            
            const { accessToken, expiresIn } = await response.json();
            this.token = accessToken;
            this.tokenExpiry = Date.now() + expiresIn * 1000;
            
            return accessToken;
        } catch (error) {
            this.clearTokens();
            return null;
        }
    }
    
    clearTokens() {
        this.token = null;
        this.refreshToken = null;
        this.tokenExpiry = null;
    }
    
    isAuthenticated(): boolean {
        return !!this.getToken();
    }
}

export const tokenManager = new SecureTokenManager();</code>
                        </div>
                        
                        <h4>HTTP Client with Token</h4>
                        <div class="code-block">
<code>// Secure API client
class SecureAPIClient {
    private baseURL: string;
    
    constructor(baseURL: string) {
        this.baseURL = baseURL;
    }
    
    private async request(
        endpoint: string,
        options: RequestInit = {}
    ): Promise&lt;Response&gt; {
        const token = tokenManager.getToken();
        
        const headers: HeadersInit = {
            'Content-Type': 'application/json',
            ...options.headers,
        };
        
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        
        const response = await fetch(`${this.baseURL}${endpoint}`, {
            ...options,
            headers,
            credentials: 'include', // Include cookies
        });
        
        // Handle token refresh on 401
        if (response.status === 401) {
            const newToken = await tokenManager.refreshAccessToken();
            if (newToken) {
                // Retry request with new token
                headers['Authorization'] = `Bearer ${newToken}`;
                return fetch(`${this.baseURL}${endpoint}`, {
                    ...options,
                    headers,
                    credentials: 'include',
                });
            }
        }
        
        return response;
    }
    
    async get(endpoint: string) {
        return this.request(endpoint, { method: 'GET' });
    }
    
    async post(endpoint: string, data: any) {
        return this.request(endpoint, {
            method: 'POST',
            body: JSON.stringify(data),
        });
    }
    
    async put(endpoint: string, data: any) {
        return this.request(endpoint, {
            method: 'PUT',
            body: JSON.stringify(data),
        });
    }
    
    async delete(endpoint: string) {
        return this.request(endpoint, { method: 'DELETE' });
    }
}

export const apiClient = new SecureAPIClient('/api');</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Never store sensitive tokens in localStorage. Use httpOnly cookies for refresh tokens and keep access tokens in memory. Implement automatic token refresh before expiration. Always use HTTPS in production.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Persisting sessions -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Persisting sessions</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Session Persistence</h3>
                        <p>Implementing secure session persistence across page refreshes and browser sessions.</p>
                        
                        <h4>Session Management</h4>
                        <div class="code-block">
<code>// Session manager
class SessionManager {
    private static readonly SESSION_KEY = 'user_session';
    private static readonly SESSION_EXPIRY = 7 * 24 * 60 * 60 * 1000; // 7 days
    
    static saveSession(user: User, rememberMe = false) {
        const sessionData = {
            user,
            expiresAt: rememberMe
                ? Date.now() + this.SESSION_EXPIRY
                : Date.now() + 24 * 60 * 60 * 1000, // 1 day
        };
        
        if (rememberMe) {
            // Use localStorage for "remember me"
            localStorage.setItem(this.SESSION_KEY, JSON.stringify(sessionData));
        } else {
            // Use sessionStorage for temporary sessions
            sessionStorage.setItem(this.SESSION_KEY, JSON.stringify(sessionData));
        }
    }
    
    static getSession(): { user: User; expiresAt: number } | null {
        // Check sessionStorage first
        let sessionData = sessionStorage.getItem(this.SESSION_KEY);
        
        // Fallback to localStorage
        if (!sessionData) {
            sessionData = localStorage.getItem(this.SESSION_KEY);
        }
        
        if (!sessionData) {
            return null;
        }
        
        try {
            const parsed = JSON.parse(sessionData);
            
            // Check if session expired
            if (Date.now() &gt; parsed.expiresAt) {
                this.clearSession();
                return null;
            }
            
            return parsed;
        } catch {
            this.clearSession();
            return null;
        }
    }
    
    static clearSession() {
        sessionStorage.removeItem(this.SESSION_KEY);
        localStorage.removeItem(this.SESSION_KEY);
    }
    
    static isSessionValid(): boolean {
        return !!this.getSession();
    }
}

// Usage in AuthContext
export function AuthProvider({ children }: { children: React.ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    
    useEffect(() => {
        // Restore session on mount
        const session = SessionManager.getSession();
        if (session) {
            setUser(session.user);
        }
        setIsLoading(false);
    }, []);
    
    const login = async (email: string, password: string, rememberMe = false) => {
        const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password }),
        });
        
        if (!response.ok) {
            throw new Error('Login failed');
        }
        
        const { user: userData, token } = await response.json();
        
        // Save session
        SessionManager.saveSession(userData, rememberMe);
        setUser(userData);
        
        // Store token securely
        tokenManager.setTokens(token.accessToken, token.refreshToken, token.expiresIn);
    };
    
    const logout = () => {
        SessionManager.clearSession();
        tokenManager.clearTokens();
        setUser(null);
    };
    
    return (
        &lt;AuthContext.Provider value={{ user, isLoading, login, logout }}&gt;
            {children}
        &lt;/AuthContext.Provider&gt;
    );
}</code>
                        </div>
                        
                        <h4>Auto-refresh Session</h4>
                        <div class="code-block">
<code>// Auto-refresh session before expiry
export function useSessionRefresh() {
    const { user } = useAuth();
    const refreshInterval = 5 * 60 * 1000; // 5 minutes
    
    useEffect(() => {
        if (!user) return;
        
        const interval = setInterval(async () => {
            try {
                // Refresh token
                const newToken = await tokenManager.refreshAccessToken();
                if (!newToken) {
                    // Token refresh failed, logout user
                    SessionManager.clearSession();
                    window.location.href = '/login';
                }
            } catch (error) {
                console.error('Session refresh failed:', error);
                SessionManager.clearSession();
                window.location.href = '/login';
            }
        }, refreshInterval);
        
        return () => clearInterval(interval);
    }, [user]);
}

// Usage in app
export function App() {
    useSessionRefresh();
    // ... rest of app
}</code>
                        </div>
                        
                        <h4>Session Activity Tracking</h4>
                        <div class="code-block">
<code>// Track user activity to extend session
class ActivityTracker {
    private lastActivity: number = Date.now();
    private readonly INACTIVITY_TIMEOUT = 30 * 60 * 1000; // 30 minutes
    
    constructor() {
        this.setupListeners();
        this.startInactivityCheck();
    }
    
    private setupListeners() {
        const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];
        events.forEach((event) => {
            document.addEventListener(event, () => {
                this.lastActivity = Date.now();
            });
        });
    }
    
    private startInactivityCheck() {
        setInterval(() => {
            const timeSinceActivity = Date.now() - this.lastActivity;
            
            if (timeSinceActivity &gt; this.INACTIVITY_TIMEOUT) {
                // User inactive, show warning or logout
                this.handleInactivity();
            }
        }, 60000); // Check every minute
    }
    
    private handleInactivity() {
        // Show warning modal
        const shouldLogout = confirm(
            'You have been inactive. Do you want to stay logged in?'
        );
        
        if (!shouldLogout) {
            SessionManager.clearSession();
            window.location.href = '/login';
        } else {
            this.lastActivity = Date.now();
        }
    }
}

export const activityTracker = new ActivityTracker();</code>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Preventing common UI security mistakes -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Preventing common UI security mistakes</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Common Security Mistakes</h3>
                        <p>Identifying and preventing common frontend security vulnerabilities.</p>
                        
                        <h4>XSS Prevention</h4>
                        <div class="code-block">
<code>// ‚ùå BAD: Directly rendering user input
function BadComponent({ userInput }: { userInput: string }) {
    return &lt;div dangerouslySetInnerHTML={{ __html: userInput }} /&gt;;
}

// ‚úÖ GOOD: Sanitize and escape
import DOMPurify from 'dompurify';

function SafeComponent({ userInput }: { userInput: string }) {
    const sanitized = DOMPurify.sanitize(userInput);
    return &lt;div dangerouslySetInnerHTML={{ __html: sanitized }} /&gt;;
}

// ‚úÖ BETTER: Use React's built-in escaping
function BetterComponent({ userInput }: { userInput: string }) {
    return &lt;div&gt;{userInput}&lt;/div&gt;; // React automatically escapes
}

// ‚úÖ BEST: Validate and sanitize on input
function BestComponent({ userInput }: { userInput: string }) {
    // Validate input
    if (!/^[a-zA-Z0-9\s]+$/.test(userInput)) {
        return &lt;div&gt;Invalid input&lt;/div&gt;;
    }
    
    return &lt;div&gt;{userInput}&lt;/div&gt;;
}</code>
                        </div>
                        
                        <h4>CSRF Protection</h4>
                        <div class="code-block">
<code>// CSRF token implementation
class CSRFProtection {
    private static readonly CSRF_TOKEN_KEY = 'csrf_token';
    
    static async getToken(): Promise&lt;string&gt; {
        // Get token from server
        const response = await fetch('/api/csrf-token', {
            credentials: 'include',
        });
        const { token } = await response.json();
        
        // Store in memory (not localStorage)
        sessionStorage.setItem(this.CSRF_TOKEN_KEY, token);
        return token;
    }
    
    static getStoredToken(): string | null {
        return sessionStorage.getItem(this.CSRF_TOKEN_KEY);
    }
    
    static async makeRequest(url: string, options: RequestInit = {}) {
        const token = this.getStoredToken() || await this.getToken();
        
        const headers = {
            ...options.headers,
            'X-CSRF-Token': token,
        };
        
        return fetch(url, {
            ...options,
            headers,
            credentials: 'include',
        });
    }
}

// Usage
await CSRFProtection.makeRequest('/api/user/update', {
    method: 'POST',
    body: JSON.stringify({ name: 'New Name' }),
});</code>
                        </div>
                        
                        <h4>Secure Headers</h4>
                        <div class="code-block">
<code>// Content Security Policy
// Add to HTML head or meta tags
&lt;meta
    httpEquiv="Content-Security-Policy"
    content="
        default-src 'self';
        script-src 'self' 'unsafe-inline' 'unsafe-eval';
        style-src 'self' 'unsafe-inline';
        img-src 'self' data: https:;
        font-src 'self' data:;
        connect-src 'self' https://api.example.com;
    "
/&gt;

// Security headers in Next.js
// next.config.js
module.exports = {
    async headers() {
        return [
            {
                source: '/:path*',
                headers: [
                    {
                        key: 'X-Content-Type-Options',
                        value: 'nosniff',
                    },
                    {
                        key: 'X-Frame-Options',
                        value: 'DENY',
                    },
                    {
                        key: 'X-XSS-Protection',
                        value: '1; mode=block',
                    },
                    {
                        key: 'Referrer-Policy',
                        value: 'strict-origin-when-cross-origin',
                    },
                ],
            },
        ];
    },
};</code>
                        </div>
                        
                        <h4>Input Validation</h4>
                        <div class="code-block">
<code>// Client-side validation (always validate on server too!)
const validationRules = {
    email: {
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        message: 'Invalid email format',
    },
    password: {
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumber: true,
        requireSpecial: true,
    },
    url: {
        pattern: /^https?:\/\/.+/,
        message: 'Must be a valid URL starting with http:// or https://',
    },
};

function validateInput(value: string, type: keyof typeof validationRules): string | null {
    const rule = validationRules[type];
    
    if (type === 'email') {
        if (!rule.pattern.test(value)) {
            return rule.message;
        }
    }
    
    if (type === 'password') {
        if (value.length &lt; rule.minLength) {
            return `Password must be at least ${rule.minLength} characters`;
        }
        if (rule.requireUppercase && !/[A-Z]/.test(value)) {
            return 'Password must contain an uppercase letter';
        }
        // ... more checks
    }
    
    return null;
}

// Sanitize input
function sanitizeInput(input: string): string {
    // Remove potentially dangerous characters
    return input
        .replace(/&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi, '')
        .replace(/&lt;iframe\b[^&lt;]*(?:(?!&lt;\/iframe&gt;)&lt;[^&lt;]*)*&lt;\/iframe&gt;/gi, '')
        .trim();
}</code>
                        </div>
                        
                        <h4>Error Message Security</h4>
                        <div class="code-block">
<code>// ‚ùå BAD: Exposing sensitive information
catch (error) {
    setError(`Database error: ${error.message}`);
    // Could expose database structure, credentials, etc.
}

// ‚úÖ GOOD: Generic error messages
catch (error) {
    console.error('Login error:', error); // Log full error server-side
    setError('Invalid email or password'); // Generic message to user
}

// Error message mapping
const ERROR_MESSAGES: Record&lt;string, string&gt; = {
    'INVALID_CREDENTIALS': 'Invalid email or password',
    'ACCOUNT_LOCKED': 'Account temporarily locked. Please try again later.',
    'EMAIL_NOT_VERIFIED': 'Please verify your email address',
    'RATE_LIMIT_EXCEEDED': 'Too many attempts. Please try again later.',
};

function getErrorMessage(errorCode: string): string {
    return ERROR_MESSAGES[errorCode] || 'An error occurred. Please try again.';
}</code>
                        </div>
                        
                        <div class="note-warning">
                            <h4>‚ö†Ô∏è Warning</h4>
                            <p>Never trust client-side validation alone. Always validate and sanitize on the server. Client-side validation is for UX only. Never expose sensitive information in error messages. Always use HTTPS in production. Implement rate limiting to prevent brute force attacks.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Additional videos will follow the same structure -->
        <div class="video-section" style="text-align: center; padding: 40px; color: #64748b;">
            <p><strong>Note:</strong> Videos 10-22 will follow the same format with detailed content for each topic.</p>
        </div>
    </div>
    
    <script src="notes-theme.js"></script>
    <script src="notes-script.js"></script>
</body>
</html>

