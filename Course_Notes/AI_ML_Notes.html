<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI & Machine Learning - Complete Notes</title>
    <link rel="stylesheet" href="notes-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Back to Website Button -->
    <div class="back-button-container">
        <a href="#" id="back-to-website" class="back-button">
            <i class="fas fa-arrow-left"></i> Back to Website
        </a>
    </div>
    
    <div class="container">
        <header>
            <h1>AI & Machine Learning - Complete Notes</h1>
            <p class="subtitle">20 Videos - Comprehensive Study Guide with Examples and Explanations</p>
        </header>
        
        <div class="toc no-print">
            <h2>Table of Contents</h2>
            <ul id="toc-list">
                <!-- TOC will be generated by JavaScript -->
            </ul>
        </div>
        
        <!-- Video 01: Python Fundamentals for AI/ML -->
        <div class="video-section" id="video-01">
            <div class="video-header">
                <span class="video-number">Video 01</span>
                <h2 class="video-title">Python Fundamentals for AI/ML</h2>
            </div>
            
            <!-- Topic 1: Python basics: variables, data types -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Python basics: variables, data types</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Variables and Assignment</h3>
                        <p>In Python, variables are created by assignment. Python is dynamically typed, meaning you don't need to declare variable types explicitly.</p>
                        
                        <div class="code-block">
<code># Variable assignment
name = "Code Infinity"
age = 2026
price = 99.99
is_active = True

# Multiple assignment
x, y, z = 1, 2, 3
a = b = c = 0

# Variable naming conventions
# ‚úÖ Good: snake_case for variables
user_name = "John"
total_count = 100

# ‚ùå Bad: Avoid reserved keywords
# class = "Python"  # Error: 'class' is a keyword

# Type checking
print(type(name))      # &lt;class 'str'&gt;
print(type(age))       # &lt;class 'int'&gt;
print(type(price))     # &lt;class 'float'&gt;
print(type(is_active)) # &lt;class 'bool'&gt;</code>
                        </div>
                        
                        <h3>Data Types</h3>
                        <p>Python has several built-in data types essential for AI/ML work:</p>
                        
                        <table>
                            <tr>
                                <th>Type</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                            <tr>
                                <td>int</td>
                                <td>Integer numbers</td>
                                <td>42, -10, 0</td>
                            </tr>
                            <tr>
                                <td>float</td>
                                <td>Floating-point numbers</td>
                                <td>3.14, -0.5, 1.0</td>
                            </tr>
                            <tr>
                                <td>str</td>
                                <td>String (text)</td>
                                <td>"Hello", 'World'</td>
                            </tr>
                            <tr>
                                <td>bool</td>
                                <td>Boolean (True/False)</td>
                                <td>True, False</td>
                            </tr>
                            <tr>
                                <td>list</td>
                                <td>Ordered, mutable collection</td>
                                <td>[1, 2, 3], ['a', 'b']</td>
                            </tr>
                            <tr>
                                <td>tuple</td>
                                <td>Ordered, immutable collection</td>
                                <td>(1, 2, 3), ('x', 'y')</td>
                            </tr>
                            <tr>
                                <td>dict</td>
                                <td>Key-value pairs</td>
                                <td>{'name': 'John', 'age': 30}</td>
                            </tr>
                            <tr>
                                <td>set</td>
                                <td>Unordered, unique elements</td>
                                <td>{1, 2, 3}, {'a', 'b'}</td>
                            </tr>
                        </table>
                        
                        <h4>Numeric Types</h4>
                        <div class="code-block">
<code># Integers
x = 10
y = -5
z = 0

# Operations
result = x + y  # 5
result = x * y  # -50
result = x ** 2  # 100 (exponentiation)
result = x // 3  # 3 (floor division)
result = x % 3   # 1 (modulo)

# Floats
pi = 3.14159
e = 2.71828
result = pi + e  # 5.85987

# Type conversion
int_value = int(3.7)      # 3 (truncates)
float_value = float(5)   # 5.0
complex_num = 3 + 4j     # Complex number

# Scientific notation (useful for ML)
large_num = 1e6          # 1000000.0
small_num = 1e-6         # 0.000001</code>
                        </div>
                        
                        <h4>Strings</h4>
                        <div class="code-block">
<code># String creation
single_quotes = 'Hello'
double_quotes = "World"
triple_quotes = """Multi-line
string"""

# String operations
name = "Python"
greeting = "Hello, " + name  # Concatenation
repeated = name * 3          # "PythonPythonPython"

# String methods (important for data preprocessing)
text = "  Machine Learning  "
text.strip()           # "Machine Learning" (remove whitespace)
text.lower()           # "  machine learning  "
text.upper()           # "  MACHINE LEARNING  "
text.replace(" ", "_") # "__Machine_Learning__"

# String formatting (modern approach)
name = "Alice"
age = 30
message = f"Name: {name}, Age: {age}"  # f-string
message = "Name: {}, Age: {}".format(name, age)  # .format()
message = "Name: %s, Age: %d" % (name, age)  # Old style

# String slicing
text = "Machine Learning"
text[0:7]      # "Machine"
text[8:]       # "Learning"
text[-8:]      # "Learning" (negative indexing)
text[::-1]     # "gninraeL enihcaM" (reverse)</code>
                        </div>
                        
                        <h4>Lists (Essential for ML)</h4>
                        <div class="code-block">
<code># List creation
numbers = [1, 2, 3, 4, 5]
mixed = [1, "hello", 3.14, True]
empty = []

# List operations
numbers.append(6)           # [1, 2, 3, 4, 5, 6]
numbers.insert(0, 0)        # [0, 1, 2, 3, 4, 5, 6]
numbers.remove(3)          # [0, 1, 2, 4, 5, 6]
popped = numbers.pop()      # Returns 6, list becomes [0, 1, 2, 4, 5]

# List slicing (similar to NumPy arrays)
data = [10, 20, 30, 40, 50]
data[1:4]      # [20, 30, 40]
data[:3]      # [10, 20, 30]
data[2:]      # [30, 40, 50]
data[::-1]    # [50, 40, 30, 20, 10] (reverse)

# List comprehension (very important for ML)
squares = [x**2 for x in range(10)]  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
evens = [x for x in range(20) if x % 2 == 0]  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# Nested list comprehension
matrix = [[i*j for j in range(3)] for i in range(3)]
# [[0, 0, 0], [0, 1, 2], [0, 2, 4]]</code>
                        </div>
                        
                        <h4>Dictionaries (Key-Value Pairs)</h4>
                        <div class="code-block">
<code># Dictionary creation
student = {
    "name": "Alice",
    "age": 25,
    "grades": [85, 90, 88]
}

# Accessing values
name = student["name"]           # "Alice"
age = student.get("age", 0)      # 25 (with default)
age = student.get("height", 0)  # 0 (key doesn't exist)

# Modifying dictionaries
student["age"] = 26
student["major"] = "Computer Science"  # Add new key
student.update({"age": 27, "city": "NYC"})  # Update multiple

# Dictionary methods
keys = student.keys()      # dict_keys(['name', 'age', 'grades', 'major', 'city'])
values = student.values()  # dict_values(['Alice', 27, [85, 90, 88], 'CS', 'NYC'])
items = student.items()    # dict_items([('name', 'Alice'), ...])

# Dictionary comprehension
squares_dict = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Useful for ML: Feature dictionaries
features = {
    "temperature": 72.5,
    "humidity": 0.65,
    "pressure": 1013.25
}</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Data Type Operations for ML</h4>
                            <div class="code-block">
<code># Example: Processing dataset information
dataset_info = {
    "name": "Iris Dataset",
    "samples": 150,
    "features": ["sepal_length", "sepal_width", "petal_length", "petal_width"],
    "target": "species",
    "classes": ["setosa", "versicolor", "virginica"]
}

# Extract information
num_samples = dataset_info["samples"]
feature_names = dataset_info["features"]
num_features = len(feature_names)

# Create feature dictionary
sample_data = {
    feature: 0.0 for feature in feature_names
}
# {'sepal_length': 0.0, 'sepal_width': 0.0, 'petal_length': 0.0, 'petal_width': 0.0}

# Type checking for data validation
def validate_data(data):
    if not isinstance(data, dict):
        raise TypeError("Data must be a dictionary")
    if not all(isinstance(v, (int, float)) for v in data.values()):
        raise ValueError("All values must be numeric")
    return True

validate_data(sample_data)  # True</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Control flow and functions -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Control flow and functions</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Control Flow</h3>
                        <p>Control flow statements allow you to control the execution order of your code.</p>
                        
                        <h4>Conditional Statements</h4>
                        <div class="code-block">
<code># If-else statements
score = 85

if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
else:
    grade = "F"

# Ternary operator (conditional expression)
status = "Pass" if score >= 70 else "Fail"

# Multiple conditions
age = 25
if 18 <= age <= 65:
    category = "Working age"

# Logical operators
x = 10
y = 20
if x > 5 and y < 30:
    result = "Both conditions true"

if x > 15 or y < 30:
    result = "At least one condition true"

if not x > 15:
    result = "x is not greater than 15"</code>
                        </div>
                        
                        <h4>Loops</h4>
                        <div class="code-block">
<code># For loop
for i in range(5):
    print(i)  # 0, 1, 2, 3, 4

# For loop with list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# For loop with index
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# While loop
count = 0
while count < 5:
    print(count)
    count += 1

# Loop control
for i in range(10):
    if i == 3:
        continue  # Skip iteration
    if i == 7:
        break     # Exit loop
    print(i)  # 0, 1, 2, 4, 5, 6

# Nested loops (useful for matrices in ML)
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
for row in matrix:
    for element in row:
        print(element, end=" ")
    print()  # New line after each row</code>
                        </div>
                        
                        <h4>Functions</h4>
                        <div class="code-block">
<code># Basic function
def greet(name):
    return f"Hello, {name}!"

result = greet("Alice")  # "Hello, Alice!"

# Function with default parameters
def calculate_area(length, width=1):
    return length * width

area1 = calculate_area(5, 3)  # 15
area2 = calculate_area(5)      # 5 (width defaults to 1)

# Function with keyword arguments
def create_user(name, age, email, active=True):
    return {
        "name": name,
        "age": age,
        "email": email,
        "active": active
    }

user = create_user("John", 30, "john@example.com", active=False)
user = create_user(age=30, name="John", email="john@example.com")  # Order doesn't matter

# Function with variable arguments
def sum_numbers(*args):
    return sum(args)

total = sum_numbers(1, 2, 3, 4, 5)  # 15

# Function with keyword arguments
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25, city="NYC")

# Lambda functions (anonymous functions)
square = lambda x: x ** 2
result = square(5)  # 25

# Lambda with map (useful for data transformation)
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9, 16, 25]

# Lambda with filter
evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]</code>
                        </div>
                        
                        <h4>Functions for ML</h4>
                        <div class="code-block">
<code># Function to normalize data (important for ML)
def normalize(data, min_val=None, max_val=None):
    """Normalize data to range [0, 1]"""
    if min_val is None:
        min_val = min(data)
    if max_val is None:
        max_val = max(data)
    
    range_val = max_val - min_val
    if range_val == 0:
        return [0.0] * len(data)
    
    return [(x - min_val) / range_val for x in data]

# Example usage
scores = [65, 75, 85, 95, 100]
normalized = normalize(scores)  # [0.0, 0.2857, 0.5714, 0.8571, 1.0]

# Function to calculate mean (average)
def mean(data):
    """Calculate the mean of a dataset"""
    if len(data) == 0:
        return 0
    return sum(data) / len(data)

# Function to calculate standard deviation
def std_dev(data):
    """Calculate standard deviation"""
    if len(data) == 0:
        return 0
    mean_val = mean(data)
    variance = sum((x - mean_val) ** 2 for x in data) / len(data)
    return variance ** 0.5

# Example usage
data = [10, 20, 30, 40, 50]
print(f"Mean: {mean(data)}")        # 30.0
print(f"Std Dev: {std_dev(data)}")  # 14.14

# Function with type hints (Python 3.5+)
from typing import List, Tuple

def process_features(features: List[float], labels: List[int]) -> Tuple[List[float], int]:
    """Process features and return normalized features and count"""
    normalized = normalize(features)
    count = len(labels)
    return normalized, count</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete ML Helper Function</h4>
                            <div class="code-block">
<code>def prepare_dataset(raw_data: List[dict]) -> Tuple[List[List[float]], List[int]]:
    """
    Prepare dataset for machine learning
    
    Args:
        raw_data: List of dictionaries with feature data
        
    Returns:
        Tuple of (features, labels) where features is a 2D list
    """
    features = []
    labels = []
    
    for sample in raw_data:
        # Extract features (assuming 'x1', 'x2', 'x3' are feature keys)
        feature_vector = [
            sample.get('x1', 0.0),
            sample.get('x2', 0.0),
            sample.get('x3', 0.0)
        ]
        features.append(feature_vector)
        
        # Extract label
        labels.append(sample.get('label', 0))
    
    return features, labels

# Usage
raw_data = [
    {'x1': 1.0, 'x2': 2.0, 'x3': 3.0, 'label': 0},
    {'x1': 4.0, 'x2': 5.0, 'x3': 6.0, 'label': 1},
    {'x1': 7.0, 'x2': 8.0, 'x3': 9.0, 'label': 0}
]

features, labels = prepare_dataset(raw_data)
# features: [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
# labels: [0, 1, 0]</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Object-oriented programming -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Object-oriented programming</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Classes and Objects</h3>
                        <p>Object-oriented programming (OOP) is essential for organizing ML code and creating reusable components.</p>
                        
                        <h4>Basic Class Definition</h4>
                        <div class="code-block">
<code># Simple class
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def introduce(self):
        return f"My name is {self.name} and I am {self.age} years old."

# Creating objects
person1 = Person("Alice", 25)
person2 = Person("Bob", 30)

print(person1.introduce())  # "My name is Alice and I am 25 years old."
print(person2.name)         # "Bob"

# Class with methods
class Calculator:
    def __init__(self):
        self.result = 0
    
    def add(self, value):
        self.result += value
        return self
    
    def multiply(self, value):
        self.result *= value
        return self
    
    def get_result(self):
        return self.result

calc = Calculator()
result = calc.add(5).multiply(3).get_result()  # 15 (method chaining)</code>
                        </div>
                        
                        <h4>Inheritance</h4>
                        <div class="code-block">
<code># Base class
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        return "Some generic sound"
    
    def info(self):
        return f"{self.name} is a {self.species}"

# Derived class
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name, "Dog")  # Call parent constructor
        self.breed = breed
    
    def make_sound(self):  # Override method
        return "Woof!"
    
    def info(self):
        return f"{super().info()}, breed: {self.breed}"

# Usage
dog = Dog("Buddy", "Golden Retriever")
print(dog.make_sound())  # "Woof!"
print(dog.info())        # "Buddy is a Dog, breed: Golden Retriever"</code>
                        </div>
                        
                        <h4>ML Model Class Example</h4>
                        <div class="code-block">
<code># Example: Simple Linear Regression Model
class LinearRegression:
    def __init__(self, learning_rate=0.01, iterations=1000):
        self.learning_rate = learning_rate
        self.iterations = iterations
        self.weights = None
        self.bias = None
        self.cost_history = []
    
    def fit(self, X, y):
        """
        Train the model
        
        Args:
            X: Feature matrix (list of lists)
            y: Target values (list)
        """
        # Initialize parameters
        n_samples, n_features = len(X), len(X[0])
        self.weights = [0.0] * n_features
        self.bias = 0.0
        
        # Training loop
        for i in range(self.iterations):
            # Predictions
            y_pred = self.predict(X)
            
            # Calculate cost (Mean Squared Error)
            cost = sum((y_pred[j] - y[j])**2 for j in range(n_samples)) / n_samples
            self.cost_history.append(cost)
            
            # Calculate gradients
            dw = [0.0] * n_features
            db = 0.0
            
            for j in range(n_samples):
                error = y_pred[j] - y[j]
                for k in range(n_features):
                    dw[k] += X[j][k] * error
                db += error
            
            # Update parameters
            for k in range(n_features):
                self.weights[k] -= self.learning_rate * (dw[k] / n_samples)
            self.bias -= self.learning_rate * (db / n_samples)
    
    def predict(self, X):
        """Make predictions"""
        predictions = []
        for sample in X:
            pred = sum(self.weights[i] * sample[i] for i in range(len(sample)))
            pred += self.bias
            predictions.append(pred)
        return predictions
    
    def get_parameters(self):
        """Get model parameters"""
        return {
            "weights": self.weights,
            "bias": self.bias
        }

# Usage
model = LinearRegression(learning_rate=0.01, iterations=1000)

# Training data
X_train = [[1], [2], [3], [4], [5]]
y_train = [2, 4, 6, 8, 10]

# Train the model
model.fit(X_train, y_train)

# Make predictions
X_test = [[6], [7], [8]]
predictions = model.predict(X_test)  # [12, 14, 16] (approximately)

# Get parameters
params = model.get_parameters()
print(f"Weights: {params['weights']}")
print(f"Bias: {params['bias']}")</code>
                        </div>
                        
                        <h4>Special Methods (Magic Methods)</h4>
                        <div class="code-block">
<code># Special methods for custom behavior
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    def __len__(self):
        return int((self.x**2 + self.y**2)**0.5)
    
    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

# Usage
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(v1)           # Vector(3, 4)
print(v1 + v2)      # Vector(4, 6)
print(v1 * 2)       # Vector(6, 8)
print(len(v1))      # 5
print(v1 == v2)     # False</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>OOP is crucial for ML because it allows you to encapsulate model logic, make code reusable, and create clean APIs. Most ML libraries (scikit-learn, TensorFlow, PyTorch) use OOP patterns extensively.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: File handling and modules -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>File handling and modules</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>File Operations</h3>
                        <p>Reading and writing files is essential for loading datasets and saving model results.</p>
                        
                        <h4>Reading Files</h4>
                        <div class="code-block">
<code># Reading text files
with open('data.txt', 'r') as file:
    content = file.read()  # Read entire file
    # OR
    lines = file.readlines()  # Read as list of lines

# Reading line by line (memory efficient for large files)
with open('large_dataset.csv', 'r') as file:
    for line in file:
        process_line(line)  # Process each line

# Reading with encoding
with open('data.txt', 'r', encoding='utf-8') as file:
    content = file.read()

# Reading CSV files (basic approach, pandas is better)
with open('data.csv', 'r') as file:
    header = file.readline().strip().split(',')
    data = []
    for line in file:
        values = line.strip().split(',')
        data.append(values)</code>
                        </div>
                        
                        <h4>Writing Files</h4>
                        <div class="code-block">
<code># Writing text files
data = "Hello, World!\nThis is a new line."

with open('output.txt', 'w') as file:
    file.write(data)

# Appending to files
with open('log.txt', 'a') as file:
    file.write("New log entry\n")

# Writing multiple lines
lines = ["Line 1\n", "Line 2\n", "Line 3\n"]
with open('output.txt', 'w') as file:
    file.writelines(lines)

# Writing CSV data
data = [
    ['Name', 'Age', 'City'],
    ['Alice', '25', 'NYC'],
    ['Bob', '30', 'LA']
]

with open('people.csv', 'w') as file:
    for row in data:
        file.write(','.join(row) + '\n')</code>
                        </div>
                        
                        <h4>JSON Files (Common for ML Configs)</h4>
                        <div class="code-block">
<code>import json

# Writing JSON
config = {
    "model_name": "linear_regression",
    "learning_rate": 0.01,
    "epochs": 100,
    "batch_size": 32,
    "features": ["x1", "x2", "x3"]
}

with open('config.json', 'w') as file:
    json.dump(config, file, indent=4)

# Reading JSON
with open('config.json', 'r') as file:
    config = json.load(file)

print(config["learning_rate"])  # 0.01

# JSON string operations
json_string = json.dumps(config)  # Convert to string
config_from_string = json.loads(json_string)  # Parse from string</code>
                        </div>
                        
                        <h4>Modules and Packages</h4>
                        <div class="code-block">
<code># Creating a module (save as ml_utils.py)
# ml_utils.py
def normalize(data):
    """Normalize data to [0, 1]"""
    min_val = min(data)
    max_val = max(data)
    range_val = max_val - min_val
    if range_val == 0:
        return [0.0] * len(data)
    return [(x - min_val) / range_val for x in data]

def mean(data):
    """Calculate mean"""
    return sum(data) / len(data) if data else 0

class DataProcessor:
    def __init__(self):
        self.scaler = None
    
    def fit(self, data):
        self.min = min(data)
        self.max = max(data)
    
    def transform(self, data):
        range_val = self.max - self.min
        if range_val == 0:
            return [0.0] * len(data)
        return [(x - self.min) / range_val for x in data]

# Using the module
# main.py
import ml_utils
from ml_utils import normalize, mean
from ml_utils import DataProcessor

# Using functions
data = [10, 20, 30, 40, 50]
normalized = normalize(data)
avg = mean(data)

# Using class
processor = DataProcessor()
processor.fit(data)
transformed = processor.transform(data)

# Import with alias
import ml_utils as ml
result = ml.normalize(data)

# Import specific items
from ml_utils import normalize as norm
result = norm(data)</code>
                        </div>
                        
                        <h4>Standard Library Modules for ML</h4>
                        <div class="code-block">
<code># math - Mathematical operations
import math
result = math.sqrt(16)        # 4.0
result = math.exp(2)           # 7.389...
result = math.log(10)         # 2.302...

# random - Random number generation
import random
random.seed(42)  # For reproducibility
random_number = random.random()  # 0.0 to 1.0
random_int = random.randint(1, 10)  # 1 to 10
random_choice = random.choice([1, 2, 3, 4, 5])

# collections - Useful data structures
from collections import Counter, defaultdict

# Counter for counting occurrences
data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
counts = Counter(data)  # Counter({4: 4, 3: 3, 2: 2, 1: 1})

# defaultdict for default values
dd = defaultdict(int)
dd['a'] += 1  # No KeyError, defaults to 0

# os - Operating system interface
import os
current_dir = os.getcwd()
files = os.listdir('.')
os.makedirs('data', exist_ok=True)  # Create directory

# pathlib - Modern path handling
from pathlib import Path
data_path = Path('data') / 'dataset.csv'
if data_path.exists():
    print(f"File exists: {data_path}")</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete File Handling for ML</h4>
                            <div class="code-block">
<code>import json
from pathlib import Path

class MLConfig:
    """Manage ML configuration files"""
    
    def __init__(self, config_path='config.json'):
        self.config_path = Path(config_path)
        self.config = {}
    
    def load(self):
        """Load configuration from file"""
        if self.config_path.exists():
            with open(self.config_path, 'r') as f:
                self.config = json.load(f)
        return self.config
    
    def save(self, config=None):
        """Save configuration to file"""
        if config:
            self.config = config
        
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=4)
    
    def get(self, key, default=None):
        """Get configuration value"""
        return self.config.get(key, default)

# Usage
config = MLConfig('model_config.json')

# Save configuration
config.save({
    "model": "neural_network",
    "layers": [128, 64, 32],
    "learning_rate": 0.001,
    "epochs": 100
})

# Load configuration
loaded_config = config.load()
learning_rate = config.get('learning_rate', 0.01)</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Virtual environments setup -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Virtual environments setup</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Virtual Environments</h3>
                        <p>Virtual environments isolate Python packages for different projects, preventing dependency conflicts.</p>
                        
                        <h4>Creating Virtual Environments</h4>
                        <div class="code-block">
<code># Using venv (Python 3.3+)
# Create virtual environment
python -m venv myenv

# On Windows
myenv\Scripts\activate

# On macOS/Linux
source myenv/bin/activate

# Deactivate
deactivate

# Using virtualenv (if venv not available)
pip install virtualenv
virtualenv myenv
source myenv/bin/activate  # macOS/Linux
myenv\Scripts\activate     # Windows

# Using conda (popular for ML)
conda create -n myenv python=3.9
conda activate myenv
conda deactivate</code>
                        </div>
                        
                        <h4>Managing Packages</h4>
                        <div class="code-block">
<code># Install packages
pip install numpy pandas matplotlib

# Install specific version
pip install numpy==1.21.0

# Install from requirements file
pip install -r requirements.txt

# Create requirements file
pip freeze > requirements.txt

# Example requirements.txt for ML project
# requirements.txt
numpy==1.21.0
pandas==1.3.0
matplotlib==3.4.2
scikit-learn==0.24.2
jupyter==1.0.0

# Upgrade packages
pip install --upgrade numpy

# Uninstall packages
pip uninstall numpy

# List installed packages
pip list

# Show package information
pip show numpy</code>
                        </div>
                        
                        <h4>Best Practices</h4>
                        <div class="code-block">
<code># 1. Always use virtual environments
# 2. Create requirements.txt for reproducibility
# 3. Pin package versions
# 4. Use separate environments for different projects

# Project structure
my_ml_project/
    venv/              # Virtual environment (gitignore this)
    data/              # Dataset files
    models/            # Saved models
    notebooks/         # Jupyter notebooks
    src/               # Source code
        __init__.py
        utils.py
        models.py
    tests/             # Test files
    requirements.txt   # Dependencies
    README.md
    .gitignore

# .gitignore example
venv/
env/
*.pyc
__pycache__/
*.pkl
*.h5
.DS_Store
.ipynb_checkpoints/</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Always activate your virtual environment before working on a project. This ensures you're using the correct package versions and prevents conflicts between projects.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: Jupyter notebooks mastery -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Jupyter notebooks mastery</span>
                    <span class="topic-icon">‚ñº</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Jupyter Notebooks</h3>
                        <p>Jupyter Notebooks are essential for ML development, allowing interactive coding, visualization, and documentation.</p>
                        
                        <h4>Installation and Setup</h4>
                        <div class="code-block">
<code># Install Jupyter
pip install jupyter

# Install JupyterLab (modern interface)
pip install jupyterlab

# Start Jupyter Notebook
jupyter notebook

# Start JupyterLab
jupyter lab

# Install extensions
pip install jupyter_contrib_nbextensions
jupyter contrib nbextension install --user

# Install specific kernels
pip install ipykernel
python -m ipykernel install --user --name=myenv</code>
                        </div>
                        
                        <h4>Notebook Cells</h4>
                        <div class="code-block">
<code># Code cells - Execute Python code
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Markdown cells - Documentation
# # Heading 1
# ## Heading 2
# **Bold text**
# *Italic text*
# - Bullet point
# 1. Numbered list
# `code` inline code
# ```python
# code block
# ```

# Raw cells - Unformatted text

# Cell execution
# Shift + Enter: Execute and move to next cell
# Ctrl + Enter: Execute and stay in current cell
# Alt + Enter: Execute and insert new cell below</code>
                        </div>
                        
                        <h4>Magic Commands</h4>
                        <div class="code-block">
<code># Line magic commands (single %)
%timeit sum(range(100))  # Time execution
%matplotlib inline        # Show plots inline
%load_ext autoreload      # Auto-reload modules
%autoreload 2

# Cell magic commands (double %%)
%%time
# Code to time
result = sum(range(1000000))

%%writefile script.py
# Write cell content to file
print("Hello, World!")

%%bash
# Execute bash commands
ls -la
pwd

# Useful magic commands for ML
%matplotlib inline         # Inline plots
%config InlineBackend.figure_format = 'retina'  # High-res plots
%load_ext autoreload
%autoreload 2              # Auto-reload imported modules
%timeit                    # Quick timing
%%time                     # Cell timing
%debug                     # Debug mode
%pdb on                    # Automatic debugger</code>
                        </div>
                        
                        <h4>Notebook Best Practices</h4>
                        <div class="code-block">
<code># 1. Clear structure
# - Introduction and imports at top
# - Data loading
# - Data exploration
# - Data preprocessing
# - Model training
# - Model evaluation
# - Results and conclusions

# 2. Use markdown for documentation
# Explain what each section does
# Document assumptions
# Include references

# 3. Keep cells focused
# One logical operation per cell
# Don't make cells too long

# 4. Use clear variable names
# data instead of d
# model instead of m
# predictions instead of preds

# 5. Save intermediate results
import pickle

# Save model
with open('model.pkl', 'wb') as f:
    pickle.dump(model, f)

# Load model
with open('model.pkl', 'rb') as f:
    model = pickle.load(f)

# 6. Display results clearly
from IPython.display import display, HTML

# Display DataFrames nicely
display(df.head())
display(df.describe())

# HTML output
display(HTML('<h2>Results</h2>'))

# 7. Handle errors gracefully
try:
    result = risky_operation()
except Exception as e:
    print(f"Error: {e}")
    # Continue execution</code>
                        </div>
                        
                        <h4>Example ML Notebook Structure</h4>
                        <div class="code-block">
<code># Cell 1: Title and Introduction (Markdown)
# # Machine Learning Project
# This notebook demonstrates a complete ML workflow.

# Cell 2: Imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

# Cell 3: Configuration
%matplotlib inline
sns.set_style('whitegrid')
plt.rcParams['figure.figsize'] = (10, 6)

# Cell 4: Load Data (Markdown)
# ## 1. Load and Explore Data

# Cell 5: Load dataset
df = pd.read_csv('data.csv')
print(f"Dataset shape: {df.shape}")
display(df.head())

# Cell 6: Data Exploration
print(df.info())
print(df.describe())
df.hist(bins=50, figsize=(12, 8))
plt.tight_layout()
plt.show()

# Cell 7: Preprocessing (Markdown)
# ## 2. Data Preprocessing

# Cell 8: Preprocessing code
X = df.drop('target', axis=1)
y = df['target']
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

# Cell 9: Model Training (Markdown)
# ## 3. Model Training

# Cell 10: Train model
model = LinearRegression()
model.fit(X_train, y_train)

# Cell 11: Evaluation (Markdown)
# ## 4. Model Evaluation

# Cell 12: Evaluate
predictions = model.predict(X_test)
mse = mean_squared_error(y_test, predictions)
print(f"Mean Squared Error: {mse:.4f}")

# Cell 13: Visualization
plt.scatter(y_test, predictions)
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.title('Predictions vs Actual')
plt.show()</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>üí° Tip</h4>
                            <p>Use Jupyter Notebooks for exploration and experimentation, but move production code to Python modules (.py files) for better version control and testing.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Additional videos will follow the same structure -->
        <div class="video-section" style="text-align: center; padding: 40px; color: #64748b;">
            <p><strong>Note:</strong> Videos 02-20 will follow the same format with detailed content for each topic.</p>
        </div>
    </div>
    
    <script src="notes-theme.js"></script>
    <script src="notes-script.js"></script>
</body>
</html>

