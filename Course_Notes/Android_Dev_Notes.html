<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Android App Development - Complete Notes</title>
    <link rel="stylesheet" href="notes-styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <!-- Back to Website Button -->
    <div class="back-button-container">
        <a href="#" id="back-to-website" class="back-button">
            <i class="fas fa-arrow-left"></i> Back to Website
        </a>
    </div>
    
    <div class="container">
        <header>
            <h1>Android App Development - Complete Notes</h1>
            <p class="subtitle">18 Videos - Comprehensive Study Guide with Examples and Explanations</p>
        </header>
        
        <div class="toc no-print">
            <h2>Table of Contents</h2>
            <ul id="toc-list">
                <!-- TOC will be generated by JavaScript -->
            </ul>
        </div>
        
        <!-- Video 01: Kotlin Programming Fundamentals -->
        <div class="video-section" id="video-01">
            <div class="video-header">
                <span class="video-number">Video 01</span>
                <h2 class="video-title">Kotlin Programming Fundamentals</h2>
            </div>
            
            <!-- Topic 1: Kotlin syntax & basics -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Kotlin syntax & basics</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Introduction to Kotlin</h3>
                        <p>Kotlin is a modern, statically-typed programming language developed by JetBrains. It's the official language for Android development and is designed to be concise, safe, and interoperable with Java.</p>
                        
                        <h4>Basic Syntax</h4>
                        <div class="code-block">
<code>// Hello World in Kotlin
fun main() {
    println("Hello, World!")
}

// Functions
fun greet(name: String): String {
    return "Hello, $name!"
}

// Single-expression function
fun add(a: Int, b: Int) = a + b

// Variables
val immutable = "Cannot be changed"  // Read-only (like final in Java)
var mutable = "Can be changed"        // Mutable

// Type inference
val name = "Kotlin"  // Type inferred as String
val age = 25         // Type inferred as Int
val price = 99.99    // Type inferred as Double

// Explicit types
val explicit: String = "Explicit type"
val number: Int = 42

// Comments
// Single-line comment
/* Multi-line
   comment */
/** Documentation comment */</code>
                        </div>
                        
                        <h4>Data Types</h4>
                        <table>
                            <tr>
                                <th>Type</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                            <tr>
                                <td>Byte</td>
                                <td>8-bit signed integer</td>
                                <td>127</td>
                            </tr>
                            <tr>
                                <td>Short</td>
                                <td>16-bit signed integer</td>
                                <td>32767</td>
                            </tr>
                            <tr>
                                <td>Int</td>
                                <td>32-bit signed integer</td>
                                <td>2147483647</td>
                            </tr>
                            <tr>
                                <td>Long</td>
                                <td>64-bit signed integer</td>
                                <td>9223372036854775807L</td>
                            </tr>
                            <tr>
                                <td>Float</td>
                                <td>32-bit floating point</td>
                                <td>3.14f</td>
                            </tr>
                            <tr>
                                <td>Double</td>
                                <td>64-bit floating point</td>
                                <td>3.14159</td>
                            </tr>
                            <tr>
                                <td>Char</td>
                                <td>Single character</td>
                                <td>'A'</td>
                            </tr>
                            <tr>
                                <td>Boolean</td>
                                <td>True or false</td>
                                <td>true, false</td>
                            </tr>
                            <tr>
                                <td>String</td>
                                <td>Sequence of characters</td>
                                <td>"Hello"</td>
                            </tr>
                        </table>
                        
                        <h4>String Templates</h4>
                        <div class="code-block">
<code>// String interpolation
val name = "Alice"
val age = 30

// Simple interpolation
val message = "Name: $name, Age: $age"

// Expression interpolation
val greeting = "Hello, ${name.toUpperCase()}!"

// Multi-line strings
val multiline = """
    This is a
    multi-line
    string
""".trimIndent()

// String operations
val text = "Kotlin"
text.length           // 6
text.uppercase()      // "KOTLIN"
text.lowercase()      // "kotlin"
text.substring(0, 3)  // "Kot"
text.contains("lin")  // true</code>
                        </div>
                        
                        <h4>Control Flow</h4>
                        <div class="code-block">
<code>// If-else as expression
val max = if (a > b) a else b

// When expression (like switch)
val result = when (x) {
    1 -> "One"
    2 -> "Two"
    3, 4 -> "Three or Four"
    in 5..10 -> "Between 5 and 10"
    else -> "Other"
}

// When without argument
when {
    x > 0 -> "Positive"
    x < 0 -> "Negative"
    else -> "Zero"
}

// For loops
for (i in 1..5) {
    println(i)  // 1, 2, 3, 4, 5
}

for (i in 1 until 5) {
    println(i)  // 1, 2, 3, 4
}

for (i in 5 downTo 1) {
    println(i)  // 5, 4, 3, 2, 1
}

for (i in 1..10 step 2) {
    println(i)  // 1, 3, 5, 7, 9
}

// While loops
var i = 0
while (i < 5) {
    println(i)
    i++
}

// Do-while
do {
    println(i)
    i--
} while (i > 0)</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Basic Kotlin Program</h4>
                            <div class="code-block">
<code>fun main() {
    // Variables
    val appName = "MyApp"
    var version = 1.0
    
    // Function call
    displayInfo(appName, version)
    
    // Control flow
    val status = when (version) {
        in 0.0..1.0 -> "Beta"
        in 1.0..2.0 -> "Stable"
        else -> "Unknown"
    }
    
    println("Status: $status")
}

fun displayInfo(name: String, version: Double) {
    println("App: $name")
    println("Version: $version")
}</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 2: Variables, functions, classes -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Variables, functions, classes</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Variables</h3>
                        <p>Kotlin has two types of variable declarations: <code>val</code> (immutable) and <code>var</code> (mutable).</p>
                        
                        <h4>Variable Declarations</h4>
                        <div class="code-block">
<code>// val - Immutable (read-only)
val name = "Kotlin"
val pi = 3.14159
// name = "Java"  // Error: val cannot be reassigned

// var - Mutable
var count = 0
count = 10  // OK

// Late initialization
lateinit var user: User
// Initialize later
user = User("Alice")

// Lazy initialization
val expensive: String by lazy {
    // Computed only when first accessed
    "Expensive computation result"
}

// Property initialization
class Person {
    val name: String = "Default"
    var age: Int = 0
        get() = field
        set(value) {
            if (value > 0) {
                field = value
            }
        }
}</code>
                        </div>
                        
                        <h4>Functions</h4>
                        <div class="code-block">
<code>// Function declaration
fun functionName(param1: Type1, param2: Type2): ReturnType {
    // Function body
    return result
}

// Single-expression function
fun multiply(a: Int, b: Int): Int = a * b

// Default parameters
fun greet(name: String, greeting: String = "Hello") {
    println("$greeting, $name!")
}

greet("Alice")                    // "Hello, Alice!"
greet("Bob", "Hi")                // "Hi, Bob!"

// Named parameters
fun createUser(name: String, age: Int, email: String) {
    // ...
}

createUser(
    name = "Alice",
    age = 30,
    email = "alice@example.com"
)

// Variable number of arguments
fun sum(vararg numbers: Int): Int {
    return numbers.sum()
}

sum(1, 2, 3, 4, 5)  // 15

// Extension functions
fun String.removeSpaces(): String {
    return this.replace(" ", "")
}

val text = "Hello World"
text.removeSpaces()  // "HelloWorld"

// Infix functions
infix fun Int.times(str: String) = str.repeat(this)
3 times "Hello"  // "HelloHelloHello"</code>
                        </div>
                        
                        <h4>Classes</h4>
                        <div class="code-block">
<code>// Basic class
class Person {
    var name: String = ""
    var age: Int = 0
}

// Primary constructor
class Person(val name: String, var age: Int) {
    init {
        println("Person created: $name")
    }
}

// Secondary constructor
class Person(val name: String) {
    var age: Int = 0
    
    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}

// Data class (automatically generates equals, hashCode, toString, copy)
data class User(
    val id: Int,
    val name: String,
    val email: String
)

val user1 = User(1, "Alice", "alice@example.com")
val user2 = user1.copy(name = "Bob")  // Copy with modification

// Sealed class (restricted class hierarchies)
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
}

// Enum class
enum class Status {
    PENDING,
    IN_PROGRESS,
    COMPLETED,
    CANCELLED
}

enum class Color(val rgb: Int) {
    RED(0xFF0000),
    GREEN(0x00FF00),
    BLUE(0x0000FF)
}</code>
                        </div>
                        
                        <h4>Properties and Getters/Setters</h4>
                        <div class="code-block">
<code>class Rectangle(val width: Int, val height: Int) {
    // Computed property
    val area: Int
        get() = width * height
    
    // Custom getter and setter
    var description: String = ""
        get() = "Rectangle: ${width}x${height}"
        set(value) {
            field = value.uppercase()
        }
    
    // Backing field
    private var _count: Int = 0
    var count: Int
        get() = _count
        set(value) {
            if (value >= 0) {
                _count = value
            }
        }
}

// Usage
val rect = Rectangle(10, 5)
println(rect.area)  // 50
rect.description = "large rectangle"
println(rect.description)  // "Rectangle: 10x5"</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Class with Functions</h4>
                            <div class="code-block">
<code>// Android-related example: User model
data class User(
    val id: Long,
    val name: String,
    val email: String,
    var isActive: Boolean = true
) {
    // Extension function
    fun getDisplayName(): String {
        return if (name.isNotEmpty()) name else email
    }
    
    // Companion object (like static in Java)
    companion object {
        const val DEFAULT_NAME = "Guest"
        
        fun createGuest(): User {
            return User(
                id = 0,
                name = DEFAULT_NAME,
                email = "guest@example.com",
                isActive = false
            )
        }
    }
}

// Usage
val user = User(1, "Alice", "alice@example.com")
println(user.getDisplayName())  // "Alice"

val guest = User.createGuest()
println(guest.name)  // "Guest"</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 3: Null safety -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Null safety</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Null Safety in Kotlin</h3>
                        <p>Kotlin's type system is designed to eliminate null pointer exceptions. By default, types are non-nullable, and you must explicitly mark types as nullable.</p>
                        
                        <h4>Nullable Types</h4>
                        <div class="code-block">
<code>// Non-nullable (default)
var name: String = "Kotlin"
// name = null  // Error: Null can not be a value of a non-null type

// Nullable type (use ?)
var nullableName: String? = "Kotlin"
nullableName = null  // OK

// Safe call operator
val length = nullableName?.length  // Returns Int? (nullable)
// If nullableName is null, returns null instead of throwing exception

// Elvis operator (default value)
val lengthOrZero = nullableName?.length ?: 0
// If nullableName is null, use 0

// Not-null assertion (use with caution!)
val length = nullableName!!.length
// Throws NullPointerException if nullableName is null

// Safe call with let
nullableName?.let {
    println("Name is not null: $it")
    // 'it' refers to nullableName
}

// Multiple safe calls
val city = user?.address?.city  // Returns String?</code>
                        </div>
                        
                        <h4>Null Safety Patterns</h4>
                        <div class="code-block">
<code>// Pattern 1: Safe call with default
fun getLength(text: String?): Int {
    return text?.length ?: 0
}

// Pattern 2: Early return
fun processUser(user: User?) {
    if (user == null) return
    // user is now non-null (smart cast)
    println(user.name)
}

// Pattern 3: Safe call chain
fun getCityName(user: User?): String? {
    return user?.address?.city?.name
}

// Pattern 4: let for null checks
fun sendEmail(user: User?) {
    user?.let {
        // Execute only if user is not null
        emailService.send(it.email)
    }
}

// Pattern 5: run for null checks
fun initialize(user: User?) {
    user?.run {
        // 'this' refers to user
        name = "Updated"
        email = "new@example.com"
    }
}

// Pattern 6: also for side effects
fun logUser(user: User?) {
    user?.also {
        println("Processing user: ${it.name}")
    }?.let {
        process(it)
    }
}</code>
                        </div>
                        
                        <h4>Smart Casts</h4>
                        <div class="code-block">
<code>// Smart cast after null check
fun processString(text: String?) {
    if (text != null) {
        // text is automatically cast to non-null String
        println(text.length)  // No need for ?. or !!
    }
}

// Smart cast with when
fun describe(obj: Any?): String {
    return when (obj) {
        null -> "null"
        is String -> "String of length ${obj.length}"  // Smart cast
        is Int -> "Integer: $obj"  // Smart cast
        else -> "Unknown type"
    }
}

// Type checks
fun checkType(obj: Any?) {
    if (obj is String) {
        // obj is automatically cast to String
        println(obj.uppercase())
    }
    
    if (obj !is String) {
        // obj is NOT a String
        return
    }
    // obj is String here (smart cast)
    println(obj.length)
}</code>
                        </div>
                        
                        <h4>Android-Specific Null Safety</h4>
                        <div class="code-block">
<code>// Handling nullable from Android APIs
class MainActivity : AppCompatActivity() {
    private var textView: TextView? = null
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // findViewById can return null in some cases
        textView = findViewById(R.id.textView)
        
        // Safe call
        textView?.text = "Hello"
        
        // Or use view binding (recommended)
        // binding.textView.text = "Hello"
    }
    
    // Nullable Bundle
    fun processIntent(intent: Intent?) {
        val data = intent?.getStringExtra("key")
        val result = data ?: "default"
    }
    
    // Nullable Context
    fun getStringResource(context: Context?): String? {
        return context?.getString(R.string.app_name)
    }
}

// Safe handling of nullable collections
fun processList(items: List<String>?) {
    items?.forEach { item ->
        println(item)
    }
    
    // Or with default empty list
    (items ?: emptyList()).forEach { item ->
        println(item)
    }
}</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>ðŸ’¡ Tip</h4>
                            <p>Always prefer nullable types when a value can be null. Use safe call operator (?.) instead of not-null assertion (!!). The Elvis operator (?:) is great for providing default values. Use smart casts to avoid unnecessary null checks. In Android, use View Binding or Data Binding to avoid nullable views.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 4: Collections & lambdas -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Collections & lambdas</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Collections</h3>
                        <p>Kotlin provides rich collection APIs with both mutable and immutable collections.</p>
                        
                        <h4>Collection Types</h4>
                        <div class="code-block">
<code>// Lists
val immutableList = listOf(1, 2, 3, 4, 5)  // Read-only
val mutableList = mutableListOf(1, 2, 3)  // Mutable
mutableList.add(4)

// Sets (unique elements)
val immutableSet = setOf(1, 2, 3, 3)  // [1, 2, 3]
val mutableSet = mutableSetOf(1, 2, 3)

// Maps (key-value pairs)
val immutableMap = mapOf(
    "name" to "Alice",
    "age" to 30
)
val mutableMap = mutableMapOf<String, Int>()
mutableMap["key"] = 42

// Arrays
val array = arrayOf(1, 2, 3, 4, 5)
val intArray = intArrayOf(1, 2, 3)  // Primitive array</code>
                        </div>
                        
                        <h4>Collection Operations</h4>
                        <div class="code-block">
<code>val numbers = listOf(1, 2, 3, 4, 5)

// Transformations
numbers.map { it * 2 }              // [2, 4, 6, 8, 10]
numbers.mapIndexed { index, value -> index * value }

// Filtering
numbers.filter { it > 3 }           // [4, 5]
numbers.filterNot { it > 3 }        // [1, 2, 3]
numbers.filterIndexed { index, _ -> index % 2 == 0 }

// Searching
numbers.find { it > 3 }             // 4 (first element)
numbers.firstOrNull { it > 10 }    // null
numbers.any { it > 3 }              // true
numbers.all { it > 0 }             // true
numbers.none { it < 0 }            // true

// Aggregation
numbers.sum()                       // 15
numbers.average()                   // 3.0
numbers.maxOrNull()                // 5
numbers.minOrNull()                // 1
numbers.count { it > 3 }           // 2

// Sorting
numbers.sorted()                    // [1, 2, 3, 4, 5]
numbers.sortedDescending()         // [5, 4, 3, 2, 1]
numbers.sortedBy { -it }           // Custom sort

// Grouping
val grouped = numbers.groupBy { it % 2 }
// {0=[2, 4], 1=[1, 3, 5]}

// Partitioning
val (evens, odds) = numbers.partition { it % 2 == 0 }
// evens = [2, 4], odds = [1, 3, 5]

// Flattening
val nested = listOf(listOf(1, 2), listOf(3, 4))
nested.flatten()                    // [1, 2, 3, 4]
nested.flatMap { it.map { n -> n * 2 } }  // [2, 4, 6, 8]</code>
                        </div>
                        
                        <h4>Lambdas and Higher-Order Functions</h4>
                        <div class="code-block">
<code>// Lambda syntax
val sum = { a: Int, b: Int -> a + b }
sum(3, 4)  // 7

// Lambda with single parameter (it)
val double = { x: Int -> x * 2 }
listOf(1, 2, 3).map { it * 2 }  // [2, 4, 6]

// Higher-order function
fun operation(x: Int, y: Int, op: (Int, Int) -> Int): Int {
    return op(x, y)
}

operation(5, 3, { a, b -> a + b })      // 8
operation(5, 3) { a, b -> a * b }       // 15 (trailing lambda)

// Function types
val add: (Int, Int) -> Int = { a, b -> a + b }
val printMessage: (String) -> Unit = { println(it) }

// Lambda with receiver (DSL-style)
val stringBuilder = StringBuilder().apply {
    append("Hello")
    append(" ")
    append("World")
}

// Common higher-order functions
val numbers = listOf(1, 2, 3, 4, 5)

numbers.forEach { println(it) }
numbers.forEachIndexed { index, value ->
    println("$index: $value")
}

val result = numbers.fold(0) { acc, n -> acc + n }  // 15
val reversed = numbers.foldRight(emptyList<Int>()) { n, acc -> acc + n }

numbers.reduce { acc, n -> acc + n }  // 15
numbers.reduceIndexed { index, acc, n -> acc + n }</code>
                        </div>
                        
                        <h4>Android Collection Examples</h4>
                        <div class="code-block">
<code>// Processing list of users
data class User(val id: Int, val name: String, val age: Int)

val users = listOf(
    User(1, "Alice", 25),
    User(2, "Bob", 30),
    User(3, "Charlie", 25)
)

// Filter and transform
val adultNames = users
    .filter { it.age >= 18 }
    .map { it.name }
    .sorted()

// Group by age
val usersByAge = users.groupBy { it.age }
// {25=[User(1, "Alice", 25), User(3, "Charlie", 25)], 30=[User(2, "Bob", 30)]}

// Find user
val user = users.find { it.id == 2 }  // User(2, "Bob", 30)

// Check conditions
val allAdults = users.all { it.age >= 18 }  // true
val hasTeen = users.any { it.age < 18 }    // false

// Transform to map
val userMap = users.associateBy { it.id }
// {1=User(1, "Alice", 25), 2=User(2, "Bob", 30), 3=User(3, "Charlie", 25)}

// Chaining operations
val result = users
    .filter { it.age > 20 }
    .map { it.name.uppercase() }
    .take(2)
    .joinToString(", ")
// "ALICE, BOB"</code>
                        </div>
                        
                        <div class="example-box">
                            <h4>Example: Complete Collection Usage</h4>
                            <div class="code-block">
<code>// Android example: Processing API response
data class ApiResponse(
    val users: List<User>,
    val total: Int
)

fun processApiResponse(response: ApiResponse?): List<String> {
    return response?.users
        ?.filter { it.age >= 18 }
        ?.map { "${it.name} (${it.age})" }
        ?.sorted()
        ?: emptyList()
}

// Usage with null safety
val response: ApiResponse? = getApiResponse()
val processedNames = processApiResponse(response)</code>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 5: Coroutines intro -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>Coroutines intro</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Introduction to Coroutines</h3>
                        <p>Coroutines are Kotlin's way of writing asynchronous, non-blocking code. They're lightweight threads that can be suspended and resumed.</p>
                        
                        <h4>Basic Coroutines</h4>
                        <div class="code-block">
<code>// Add dependency to build.gradle
// implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"

import kotlinx.coroutines.*

// Launch a coroutine
fun main() {
    GlobalScope.launch {
        delay(1000L)  // Non-blocking delay
        println("World!")
    }
    println("Hello,")
    Thread.sleep(2000L)  // Block main thread
}

// Coroutine scope
class MyActivity {
    private val scope = CoroutineScope(Dispatchers.Main)
    
    fun startCoroutine() {
        scope.launch {
            // Coroutine code
            val result = fetchData()
            updateUI(result)
        }
    }
}

// Suspend functions
suspend fun fetchData(): String {
    delay(1000L)  // Simulate network call
    return "Data"
}

// Calling suspend function
fun loadData() {
    CoroutineScope(Dispatchers.IO).launch {
        val data = fetchData()
        withContext(Dispatchers.Main) {
            // Update UI on main thread
            updateUI(data)
        }
    }
}</code>
                        </div>
                        
                        <h4>Coroutine Dispatchers</h4>
                        <div class="code-block">
<code>// Dispatchers determine which thread coroutine runs on
CoroutineScope(Dispatchers.Main).launch {
    // Main thread - UI operations
    updateUI()
}

CoroutineScope(Dispatchers.IO).launch {
    // Background thread - I/O operations
    val data = readFile()
}

CoroutineScope(Dispatchers.Default).launch {
    // Background thread - CPU-intensive work
    val result = computeHeavyTask()
}

CoroutineScope(Dispatchers.Unconfined).launch {
    // Unconfined - not recommended for production
}

// Switching dispatchers
fun loadData() {
    CoroutineScope(Dispatchers.IO).launch {
        // Network call on IO thread
        val data = api.getData()
        
        withContext(Dispatchers.Main) {
            // Switch to Main thread for UI update
            textView.text = data
        }
    }
}</code>
                        </div>
                        
                        <h4>Async and Await</h4>
                        <div class="code-block">
<code>// async for concurrent operations
fun loadMultipleData() {
    CoroutineScope(Dispatchers.IO).launch {
        // Start multiple operations concurrently
        val userDeferred = async { fetchUser() }
        val postsDeferred = async { fetchPosts() }
        val commentsDeferred = async { fetchComments() }
        
        // Wait for all to complete
        val user = userDeferred.await()
        val posts = postsDeferred.await()
        val comments = commentsDeferred.await()
        
        // All data loaded
        displayData(user, posts, comments)
    }
}

// Parallel processing
suspend fun processItems(items: List<Item>) {
    items.map { item ->
        async { processItem(item) }
    }.awaitAll()  // Wait for all to complete
}

// Sequential vs Concurrent
suspend fun sequential() {
    val result1 = fetchData1()  // Wait for completion
    val result2 = fetchData2()  // Then start this
    // Total time: time1 + time2
}

suspend fun concurrent() {
    val deferred1 = async { fetchData1() }
    val deferred2 = async { fetchData2() }
    val result1 = deferred1.await()
    val result2 = deferred2.await()
    // Total time: max(time1, time2)
}</code>
                        </div>
                        
                        <h4>Android Coroutine Examples</h4>
                        <div class="code-block">
<code>// ViewModel with coroutines
class MainViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data
    
    fun loadData() {
        viewModelScope.launch {
            try {
                val result = repository.fetchData()
                _data.value = result
            } catch (e: Exception) {
                // Handle error
                _data.value = "Error: ${e.message}"
            }
        }
    }
}

// Repository with suspend function
class UserRepository {
    suspend fun getUser(id: Int): User {
        return withContext(Dispatchers.IO) {
            apiService.getUser(id)
        }
    }
    
    suspend fun getUsers(): List<User> {
        return withContext(Dispatchers.IO) {
            apiService.getUsers()
        }
    }
}

// Activity/Fragment usage
class MainActivity : AppCompatActivity() {
    private val viewModel: MainViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            viewModel.data.observe(this@MainActivity) { data ->
                textView.text = data
            }
        }
        
        viewModel.loadData()
    }
}</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>ðŸ’¡ Tip</h4>
                            <p>Use <code>viewModelScope</code> in ViewModels and <code>lifecycleScope</code> in Activities/Fragments - they automatically cancel when the lifecycle ends. Use <code>Dispatchers.IO</code> for network/disk operations and <code>Dispatchers.Main</code> for UI updates. Use <code>async</code> for parallel operations. Always handle exceptions in coroutines with try-catch.</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Topic 6: OOP in Kotlin -->
            <div class="topic-dropdown">
                <div class="topic-header">
                    <span>OOP in Kotlin</span>
                    <span class="topic-icon">â–¼</span>
                </div>
                <div class="topic-content">
                    <div class="topic-body">
                        <h3>Object-Oriented Programming</h3>
                        <p>Kotlin is a fully object-oriented language with classes, inheritance, interfaces, and more.</p>
                        
                        <h4>Classes and Inheritance</h4>
                        <div class="code-block">
<code>// Open class (can be inherited - unlike Java, classes are final by default)
open class Animal(val name: String) {
    open fun makeSound() {
        println("Some sound")
    }
}

// Inheritance
class Dog(name: String) : Animal(name) {
    override fun makeSound() {
        println("Woof!")
    }
}

// Abstract class
abstract class Shape {
    abstract fun area(): Double
    
    fun description(): String {
        return "Shape with area ${area()}"
    }
}

class Circle(val radius: Double) : Shape() {
    override fun area(): Double {
        return Math.PI * radius * radius
    }
}

// Interface
interface Clickable {
    fun click()
    fun doubleClick() {
        println("Double clicked")  // Default implementation
    }
}

interface Focusable {
    fun focus()
}

// Implementing interfaces
class Button : Clickable, Focusable {
    override fun click() {
        println("Button clicked")
    }
    
    override fun focus() {
        println("Button focused")
    }
}</code>
                        </div>
                        
                        <h4>Visibility Modifiers</h4>
                        <div class="code-block">
<code>// Visibility modifiers
class Example {
    public val publicProperty = "Public"        // Default, visible everywhere
    private val privateProperty = "Private"     // Visible in same class
    protected val protectedProperty = "Protected" // Visible in class and subclasses
    internal val internalProperty = "Internal"  // Visible in same module
    
    // Same applies to functions
    private fun privateFunction() {}
    protected fun protectedFunction() {}
}

// Top-level declarations
private val topLevelPrivate = "Private"  // Visible in same file
internal val topLevelInternal = "Internal"  // Visible in same module
val topLevelPublic = "Public"  // Visible everywhere</code>
                        </div>
                        
                        <h4>Object Declarations and Companion Objects</h4>
                        <div class="code-block">
<code>// Singleton object
object DatabaseManager {
    fun connect() {
        println("Connected to database")
    }
    
    fun disconnect() {
        println("Disconnected from database")
    }
}

// Usage
DatabaseManager.connect()

// Companion object (like static in Java)
class MyClass {
    companion object {
        const val CONSTANT = "Constant value"
        
        fun create(): MyClass {
            return MyClass()
        }
    }
}

// Usage
val constant = MyClass.CONSTANT
val instance = MyClass.create()

// Named companion object
class Factory {
    companion object Named {
        fun create(): Factory = Factory()
    }
}

// Accessing
Factory.Named.create()</code>
                        </div>
                        
                        <h4>Data Classes and Sealed Classes</h4>
                        <div class="code-block">
<code>// Data class (automatically generates equals, hashCode, toString, copy)
data class User(
    val id: Int,
    val name: String,
    val email: String
)

val user1 = User(1, "Alice", "alice@example.com")
val user2 = user1.copy(name = "Bob")  // Copy with modification
println(user1)  // User(id=1, name=Alice, email=alice@example.com)

// Component destructuring
val (id, name, email) = user1
println("ID: $id, Name: $name, Email: $email")

// Sealed class (restricted class hierarchies)
sealed class Result<out T> {
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()
}

// Usage with when (exhaustive)
fun handleResult(result: Result<String>) {
    when (result) {
        is Result.Success -> println("Success: ${result.data}")
        is Result.Error -> println("Error: ${result.message}")
        Result.Loading -> println("Loading...")
    }
}</code>
                        </div>
                        
                        <h4>Android OOP Examples</h4>
                        <div class="code-block">
<code>// Base Activity
abstract class BaseActivity : AppCompatActivity() {
    abstract fun getLayoutId(): Int
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(getLayoutId())
        setupViews()
        observeData()
    }
    
    protected open fun setupViews() {}
    protected open fun observeData() {}
}

// Concrete implementation
class MainActivity : BaseActivity() {
    override fun getLayoutId() = R.layout.activity_main
    
    override fun setupViews() {
        // Setup views
    }
}

// Repository pattern
interface UserRepository {
    suspend fun getUser(id: Int): User
    suspend fun getUsers(): List<User>
}

class UserRepositoryImpl(
    private val apiService: ApiService,
    private val database: UserDatabase
) : UserRepository {
    override suspend fun getUser(id: Int): User {
        return apiService.getUser(id)
    }
    
    override suspend fun getUsers(): List<User> {
        return database.userDao().getAllUsers()
    }
}

// ViewModel with inheritance
abstract class BaseViewModel : ViewModel() {
    protected val _error = MutableLiveData<String>()
    val error: LiveData<String> = _error
    
    protected fun handleError(e: Exception) {
        _error.value = e.message
    }
}

class MainViewModel : BaseViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data
    
    fun loadData() {
        viewModelScope.launch {
            try {
                val result = repository.fetchData()
                _data.value = result
            } catch (e: Exception) {
                handleError(e)
            }
        }
    }
}</code>
                        </div>
                        
                        <div class="note-tip">
                            <h4>ðŸ’¡ Tip</h4>
                            <p>Use <code>data class</code> for models that primarily hold data. Use <code>sealed class</code> for restricted hierarchies (great for state management). Use <code>object</code> for singletons. Remember that classes are <code>final</code> by default - use <code>open</code> to allow inheritance. Use interfaces for contracts and multiple inheritance. Companion objects replace Java's static members.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Additional videos will follow the same structure -->
        <div class="video-section" style="text-align: center; padding: 40px; color: #64748b;">
            <p><strong>Note:</strong> Videos 02-18 will follow the same format with detailed content for each topic.</p>
        </div>
    </div>
    
    <script src="notes-theme.js"></script>
    <script src="notes-script.js"></script>
</body>
</html>

